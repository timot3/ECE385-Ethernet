
ethernet.elf:     file format elf32-littlenios2
ethernet.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000180

Program Header:
    LOAD off    0x00001000 vaddr 0x08000000 paddr 0x08000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x08000020 paddr 0x08000020 align 2**12
         filesz 0x00006818 memsz 0x00006818 flags r-x
    LOAD off    0x00007838 vaddr 0x08006838 paddr 0x08006954 align 2**12
         filesz 0x0000011c memsz 0x0000011c flags rw-
    LOAD off    0x00007a70 vaddr 0x08006a70 paddr 0x08006a70 align 2**12
         filesz 0x00000000 memsz 0x00000468 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  08000000  08000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000160  08000020  08000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000064f4  08000180  08000180  00001180  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000001c4  08006674  08006674  00007674  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000011c  08006838  08006954  00007838  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000468  08006a70  08006a70  00007a70  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_0 00000000  00000000  00000000  00007954  2**0
                  CONTENTS
  7 .sdram        00000000  08006ed8  08006ed8  00007954  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00007954  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000758  00000000  00000000  00007978  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000d6db  00000000  00000000  000080d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00003f49  00000000  00000000  000157ab  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000490e  00000000  00000000  000196f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00001654  00000000  00000000  0001e004  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000037bb  00000000  00000000  0001f658  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00004538  00000000  00000000  00022e13  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000010  00000000  00000000  0002734c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000007b0  00000000  00000000  00027360  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  0002ab86  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0002ab89  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0002ab95  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0002ab96  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0002ab97  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0002ab9b  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0002ab9f  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0002aba3  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000b  00000000  00000000  0002abae  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000b  00000000  00000000  0002abb9  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000008  00000000  00000000  0002abc4  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000032  00000000  00000000  0002abcc  2**0
                  CONTENTS, READONLY
 30 .jdi          00004f1b  00000000  00000000  0002abfe  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     000643f1  00000000  00000000  0002fb19  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
08000000 l    d  .entry	00000000 .entry
08000020 l    d  .exceptions	00000000 .exceptions
08000180 l    d  .text	00000000 .text
08006674 l    d  .rodata	00000000 .rodata
08006838 l    d  .rwdata	00000000 .rwdata
08006a70 l    d  .bss	00000000 .bss
00000000 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
08006ed8 l    d  .sdram	00000000 .sdram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../ethernet_bsp//obj/HAL/src/crt0.o
080001b8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 EtherCard.cpp
00000000 l    df *ABS*	00000000 dns.cpp
08006a98 l     O .bss	00000001 _ZL8dnstid_l
0800021c l     F .text	000001f0 _ZL10dnsRequestPKcb
0800040c l     F .text	000001e8 _ZL17checkForDnsAnswert
00000000 l    df *ABS*	00000000 enc28j60.cpp
08006a9f l     O .bss	00000001 _ZL12Enc28j60Bank
08006aa0 l     O .bss	00000001 _ZL9selectPin
08000994 l     F .text	0000006c _ZL7xferSPIh
08000a00 l     F .text	00000070 _ZL7writeOphhh
08000a70 l     F .text	0000008c _ZL6readOphh
08000afc l     F .text	00000080 _ZL7SetBankh
08000b7c l     F .text	0000005c _ZL12writeRegBytehh
08000bd8 l     F .text	00000074 _ZL8writeReght
08000c4c l     F .text	00000048 _ZL11readRegByteh
08000c94 l     F .text	00000064 _ZL7readRegh
08000cf8 l     F .text	00000078 _ZL8writePhyht
08000d70 l     F .text	00000080 _ZL11readPhyByteh
0800105c l     F .text	00000078 _ZL7readBuftPh
080010d4 l     F .text	00000074 _ZL8writeBuftPKh
08006aa1 l     O .bss	00000001 _ZZN8ENC28J6013packetReceiveEvE16unreleasedPacket
08006aa2 l     O .bss	00000002 _ZZN8ENC28J6013packetReceiveEvE14gNextPacketPtr
00000000 l    df *ABS*	00000000 tcpip.cpp
08006920 l     O .rwdata	00000001 _ZL20tcpclient_src_port_l
08006aa4 l     O .bss	00000001 _ZL6tcp_fd
08006aa5 l     O .bss	00000001 _ZL16tcp_client_state
08006aa6 l     O .bss	00000001 _ZL17tcp_client_port_h
08006aa7 l     O .bss	00000001 _ZL17tcp_client_port_l
08006aa8 l     O .bss	00000004 _ZL20client_tcp_result_cb
08006aac l     O .bss	00000004 _ZL22client_tcp_datafill_cb
08006ab0 l     O .bss	00000001 _ZL6www_fd
08006ab4 l     O .bss	00000004 _ZL17client_browser_cb
08006ab8 l     O .bss	00000004 _ZL27client_additionalheaderline
08006abc l     O .bss	00000004 _ZL14client_postval
08006ac0 l     O .bss	00000004 _ZL13client_urlbuf
08006ac4 l     O .bss	00000004 _ZL17client_urlbuf_var
08006ac8 l     O .bss	00000004 _ZL14client_hoststr
08006acc l     O .bss	00000004 _ZL7icmp_cb
08006ad0 l     O .bss	00000006 _ZL11destmacaddr
08006ad6 l     O .bss	00000001 _ZL19waiting_for_dns_mac
08006ad7 l     O .bss	00000001 _ZL11has_dns_mac
08006ad8 l     O .bss	00000001 _ZL20waiting_for_dest_mac
08006ad9 l     O .bss	00000001 _ZL12has_dest_mac
08006ada l     O .bss	00000006 _ZL9gwmacaddr
08006ae0 l     O .bss	00000001 _ZL9waitgwmac
08006ae2 l     O .bss	00000002 _ZL13info_data_len
08006921 l     O .rwdata	00000001 _ZL6seqnum
08006922 l     O .rwdata	00000001 _ZL9result_fd
08006ae4 l     O .bss	00000004 _ZL10result_ptr
08006ae8 l     O .bss	00000004 _ZL3SEQ
08006929 l     O .rwdata	00000008 _ZL9arpreqhdr
08006674 l     O .rodata	00000009 _ZL5iphdr
0800667d l     O .rodata	0000000a _ZL9ntpreqhdr
08001448 l     F .text	00000184 _ZL13fill_checksumhhth
080015cc l     F .text	00000050 _ZL7setMACsPKh
0800161c l     F .text	00000060 _ZL12setMACandIPsPKhS0_
0800167c l     F .text	00000044 _ZL24check_ip_message_is_fromPKh
080016c0 l     F .text	000000bc _ZL6is_lanPKhS0_
0800177c l     F .text	00000090 _ZL25eth_type_is_arp_and_my_ipt
0800180c l     F .text	000000dc _ZL24eth_type_is_ip_and_my_ipt
080018e8 l     F .text	00000080 _ZL20fill_ip_hdr_checksumv
08001968 l     F .text	0000006c _ZL11make_eth_ipv
080019d4 l     F .text	00000100 _ZL8step_seqth
08001ad4 l     F .text	000000e4 _ZL12make_tcpheadth
08001bb8 l     F .text	000000bc _ZL28make_arp_answer_from_requestv
08001c74 l     F .text	000000a4 _ZL28make_echo_reply_from_requestt
08001e98 l     F .text	0000012c _ZL24make_tcp_synack_from_synv
08002054 l     F .text	000000f0 _ZL21make_tcp_ack_from_anysh
08002144 l     F .text	000000b8 _ZL30make_tcp_ack_with_data_noflagst
08002264 l     F .text	000000a8 _ZL16getBigEndianLongh
0800230c l     F .text	00000088 _ZL17setSequenceNumberm
08002cd0 l     F .text	000000c8 _ZL17client_arp_whohasPh
08002e18 l     F .text	00000068 _ZL16client_store_macPhS_
08002f44 l     F .text	00000204 _ZL10client_synhhh
080031b4 l     F .text	00000028 _ZL31www_client_internal_datafill_cbh
080031dc l     F .text	000000f8 _ZL29www_client_internal_result_cbhhtt
08003444 l     F .text	00000028 _ZL15tcp_datafill_cbh
0800346c l     F .text	00000064 _ZL13tcp_result_cbhhtt
00000000 l    df *ABS*	00000000 webutil.cpp
00000000 l    df *ABS*	00000000 main.cpp
08006931 l     O .rwdata	00000006 _ZL5mymac
08003fbc l     F .text	0000003c _ZL9gotPingedPh
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 clock.c
00000000 l    df *ABS*	00000000 difftime.c
00000000 l    df *ABS*	00000000 impure.c
08006838 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 time.c
00000000 l    df *ABS*	00000000 timesr.c
00000000 l    df *ABS*	00000000 vfprintf.c
08004de0 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 gettimeofdayr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 alt_gettod.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_times.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_close.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
08006b18 g     O .bss	00000004 alt_instruction_exception_handler
08004d0c g     F .text	0000001c putchar
08005b58 g     F .text	00000040 alt_main
08006dd8 g     O .bss	00000100 alt_irq
080033c0 g     F .text	00000084 _ZN9EtherCard8httpPostEPKcS1_S1_S1_PFvhttE
08003f3c g     F .text	00000040 _ZN9EtherCard7copyMacEPhPKh
08006954 g       *ABS*	00000000 __flash_rwdata_start
0800544c g     F .text	00000054 _gettimeofday_r
08004cb8 g     F .text	0000004c printf
08001024 g     F .text	00000038 _ZN8ENC28J608isLinkUpEv
08003590 g     F .text	00000088 _ZN9EtherCard24packetLoopIcmpCheckReplyEPKh
080041c8 g     F .text	000000dc .hidden __gtdf2
08005f9c g     F .text	00000008 altera_nios2_gen2_irq_init
08000000 g     F .entry	0000000c __reset
08005c84 g     F .text	00000060 times
08003338 g     F .text	00000088 _ZN9EtherCard9browseUrlEPKcS1_S1_S1_PFvhttE
08000020 g       *ABS*	00000000 __flash_exceptions_start
08006aec g     O .bss	00000004 errno
080005f4 g     F .text	00000204 _ZN9EtherCard9dnsLookupEPKcb
08006b08 g     O .bss	00000004 alt_argv
0800e918 g       *ABS*	00000000 _gp
08006a87 g     O .bss	00000004 _ZN9EtherCard6dhcpipE
08004d04 g     F .text	00000008 _putchar_r
08004dd8 g     F .text	00000008 _times_r
08004c34 g     F .text	00000028 memcpy
08005774 g     F .text	000000dc .hidden __floatsidf
08005f28 g     F .text	00000074 alt_exception_cause_generated_bad_addr
08006a70 g     O .bss	00000001 ether
08004c7c g     F .text	0000003c _printf_r
00000000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
080056b8 g     F .text	00000064 .hidden __udivsi3
08002dc4 g     F .text	00000054 _ZN9EtherCard16clientWaitingDnsEv
08006af8 g     O .bss	00000008 alt_timezone
08006a9e g     O .bss	00000001 SPDR
08002758 g     F .text	000000f4 _ZN9EtherCard16ntpProcessAnswerEPmh
0800691c g     O .rwdata	00000004 GPIO_PIO
08001fc4 g     F .text	00000090 _ZN9EtherCard19getTcpPayloadLengthEv
080008f4 g     F .text	000000a0 _Z12digitalWritehh
08000df0 g     F .text	00000234 _ZN8ENC28J6010initializeEtPKhh
080060b0 g     F .text	000005c4 .hidden __umoddi3
08006938 g     O .rwdata	00000004 _global_impure_ptr
08006ed8 g       *ABS*	00000000 __bss_end
08005a10 g     F .text	00000068 alt_iic_isr_register
08005bcc g     F .text	000000b8 alt_tick
080007f8 g     F .text	00000058 _Z5delayi
080059f8 g     F .text	00000018 alt_ic_irq_enabled
0800240c g     F .text	00000070 _ZN9EtherCard26httpServerReply_with_flagsEth
08005b98 g     F .text	00000034 alt_alarm_stop
08006b00 g     O .bss	00000004 alt_irq_active
0800284c g     F .text	00000188 _ZN9EtherCard10udpPrepareEtPKht
080000fc g     F .exceptions	00000060 alt_irq_handler
08006a96 g     O .bss	00000002 _ZN9EtherCard8delaycntE
08006a8f g     O .bss	00000004 _ZN9EtherCard5hisipE
08005ec4 g     F .text	00000004 alt_dcache_flush_all
08006954 g       *ABS*	00000000 __ram_rwdata_end
08006a7f g     O .bss	00000004 _ZN9EtherCard11broadcastipE
08005ce4 g     F .text	00000060 write
080054f4 g     F .text	00000058 _putc_r
08006838 g       *ABS*	00000000 __ram_rodata_end
0800694c g     O .rwdata	00000004 jtag_uart_0
08003e68 g     F .text	00000050 _ZN9EtherCard7printIpEPKcPKh
0800247c g     F .text	0000015c _ZN9EtherCard17clientIcmpRequestEPKh
0800571c g     F .text	00000058 .hidden __umodsi3
08001404 g     F .text	00000044 _Z8memcpy_PPvPKvj
08003564 g     F .text	0000002c _ZN9EtherCard20registerPingCallbackEPFvPhE
08006ed8 g       *ABS*	00000000 end
08002b40 g     F .text	00000190 _ZN9EtherCard7sendWolEPh
0800015c g     F .exceptions	00000024 alt_instruction_exception_entry
08006674 g       *ABS*	00000000 __CTOR_LIST__
0c000000 g       *ABS*	00000000 __alt_stack_pointer
08006a9d g     O .bss	00000001 _ZN8ENC28J6019promiscuous_enabledE
08004b10 g     F .text	00000064 .hidden __clzsi2
08003148 g     F .text	0000006c _ZN9EtherCard12clientTcpReqEPFhhhttEPFthEt
08005d68 g     F .text	00000034 altera_avalon_jtag_uart_write
08004e4c g     F .text	0000052c ___vfprintf_internal_r
08006a7b g     O .bss	00000004 _ZN9EtherCard7netmaskE
080021fc g     F .text	00000068 _ZN9EtherCard15httpServerReplyEt
080032d4 g     F .text	00000064 _ZN9EtherCard9browseUrlEPKcS1_S1_PFvhttE
08006a77 g     O .bss	00000004 _ZN9EtherCard4myipE
08000180 g     F .text	0000003c _start
08006b14 g     O .bss	00000004 _alt_tick_rate
08005d9c g     F .text	000000e8 alt_avalon_spi_command
08006b10 g     O .bss	00000004 _alt_nticks
08005d64 g     F .text	00000004 alt_sys_init
08004d28 g     F .text	00000060 strncmp
08003618 g     F .text	0000011c _ZN9EtherCard6acceptEtt
08001148 g     F .text	00000140 _ZN8ENC28J6013packetReceiveEv
08004b74 g     F .text	00000028 .hidden __mulsi3
08006838 g       *ABS*	00000000 __ram_rwdata_start
08006674 g       *ABS*	00000000 __ram_rodata_start
08006a9c g     O .bss	00000001 _ZN8ENC28J6017broadcast_enabledE
08004c04 g     F .text	00000030 memcmp
08006ed8 g       *ABS*	00000000 __alt_stack_base
08006918 g     O .rwdata	00000002 _ZN9EtherCard7hisportE
08003734 g     F .text	00000704 _ZN9EtherCard10packetLoopEt
08001288 g     F .text	00000158 _ZN8ENC28J6010packetSendEt
080042a4 g     F .text	0000086c .hidden __muldf3
08002394 g     F .text	0000002c _ZN9EtherCard17getSequenceNumberEv
08006b1c g     O .bss	000002bc _ZN8ENC28J606bufferE
080034d0 g     F .text	0000004c _ZN9EtherCard7tcpSendEv
08005394 g     F .text	000000b8 __sfvwrite_small_dev
08005850 g     F .text	00000134 gettimeofday
08006a70 g       *ABS*	00000000 __bss_start
08001d18 g     F .text	00000180 _ZN9EtherCard12makeUdpReplyEPKcht
08004c5c g     F .text	00000020 memset
08003ff8 g     F .text	000001d0 main
080023c0 g     F .text	0000004c _ZN9EtherCard18httpServerReplyAckEv
08006b04 g     O .bss	00000004 alt_envp
08000850 g     F .text	0000003c _Z7bitReadhh
08004d88 g     F .text	00000050 time
08006950 g     O .rwdata	00000004 alt_errno
08006a71 g     O .bss	00000006 _ZN9EtherCard5mymacE
080054a0 g     F .text	00000054 putc
080055c0 g     F .text	00000084 .hidden __divsi3
08006674 g       *ABS*	00000000 __CTOR_END__
08006674 g       *ABS*	00000000 __flash_rodata_start
08006a9a g     O .bss	00000002 _ZN8ENC28J6010bufferSizeE
08006a8b g     O .bss	00000004 _ZN9EtherCard5dnsipE
08005d44 g     F .text	00000020 alt_irq_init
080029d4 g     F .text	000000d0 _ZN9EtherCard11udpTransmitEt
08006736 g     O .rodata	00000100 .hidden __clz_tab
08004be8 g     F .text	0000001c difftime
08005568 g     F .text	00000058 _write_r
08002e80 g     F .text	00000044 _ZN9EtherCard7setGwIpEPKh
0800693c g     O .rwdata	00000004 _impure_ptr
08006b0c g     O .bss	00000004 alt_argc
0800351c g     F .text	00000048 _ZN9EtherCard8tcpReplyEh
08003f7c g     F .text	00000040 _ZN9EtherCard6copyIpEPhPKh
0800088c g     F .text	00000034 _Z11disableChipv
08000020 g       .exceptions	00000000 alt_irq_entry
080013e0 g     F .text	00000024 _Z4PSTRPc
08006af0 g     O .bss	00000008 alt_resettime
08000020 g       *ABS*	00000000 __ram_exceptions_start
080001bc g     F .text	00000060 _ZN9EtherCard5beginEtPKhh
08006923 g     O .rwdata	00000006 allOnes
08005984 g     F .text	00000004 alt_ic_isr_register
080008c0 g     F .text	00000034 _Z10enableChipv
08006954 g       *ABS*	00000000 _edata
08006ed8 g       *ABS*	00000000 _end
08000180 g       *ABS*	00000000 __ram_exceptions_end
080059c0 g     F .text	00000038 alt_ic_irq_disable
08006a83 g     O .bss	00000004 _ZN9EtherCard4gwipE
08003e38 g     F .text	00000030 _ZN9EtherCard20persistTcpConnectionEb
08002d98 g     F .text	0000002c _ZN9EtherCard15clientWaitingGwEv
08005644 g     F .text	00000074 .hidden __modsi3
0c000000 g       *ABS*	00000000 __alt_data_end
08000020 g     F .exceptions	00000000 alt_exception
08000000 g       *ABS*	00000000 __alt_mem_sdram
080025d8 g     F .text	00000180 _ZN9EtherCard10ntpRequestEPhh
08005f10 g     F .text	00000014 _exit
08005fa4 g     F .text	0000010c .hidden __muldi3
0800554c g     F .text	0000001c strlen
080041c8 g     F .text	000000dc .hidden __gedf2
08004b9c g     F .text	0000004c clock
08006a94 g     O .bss	00000001 _ZN9EtherCard22persist_tcp_connectionE
08005f24 g     F .text	00000004 alt_icache_flush_all
08006940 g     O .rwdata	00000004 alt_priority_mask
08006a93 g     O .bss	00000001 _ZN9EtherCard10using_dhcpE
08005988 g     F .text	00000038 alt_ic_irq_enable
08005378 g     F .text	0000001c __vfprintf_internal
08006944 g     O .rwdata	00000008 alt_alarm_list
08005ec8 g     F .text	00000048 _do_ctors
08002aa4 g     F .text	0000009c _ZN9EtherCard7sendUdpEPKchtPKht
08003eb8 g     F .text	00000084 _ZN9EtherCard7printIpEPKh
08005e84 g     F .text	00000040 close
08005a78 g     F .text	000000e0 alt_load
08002ec4 g     F .text	00000080 _ZN9EtherCard22updateBroadcastAddressEv



Disassembly of section .entry:

08000000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 8000000:	00420034 	movhi	at,2048
    ori r1, r1, %lo(_start)
 8000004:	08406014 	ori	at,at,384
    jmp r1
 8000008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

08000020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 8000020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 8000024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 8000028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 800002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 8000030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 8000034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 8000038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 800003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 8000040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 8000044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 8000048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 800004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 8000050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 8000054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 8000058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 800005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 8000060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 8000064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 8000068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 800006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 8000070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 8000074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 8000078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 800007c:	10000326 	beq	r2,zero,800008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 8000080:	20000226 	beq	r4,zero,800008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 8000084:	80000fc0 	call	80000fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 8000088:	00000706 	br	80000a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 800008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 8000090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 8000094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 8000098:	800015c0 	call	800015c <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 800009c:	1000021e 	bne	r2,zero,80000a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 80000a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 80000a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 80000a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 80000ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 80000b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 80000b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 80000b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 80000bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 80000c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 80000c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 80000c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 80000cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 80000d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 80000d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 80000d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 80000dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 80000e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 80000e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 80000e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 80000ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 80000f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 80000f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 80000f8:	ef80083a 	eret

080000fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 80000fc:	defffe04 	addi	sp,sp,-8
 8000100:	dfc00115 	stw	ra,4(sp)
 8000104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8000108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 800010c:	04020034 	movhi	r16,2048
 8000110:	841b7604 	addi	r16,r16,28120

  active = alt_irq_pending ();

  do
  {
    i = 0;
 8000114:	0005883a 	mov	r2,zero
    mask = 1;
 8000118:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 800011c:	20ca703a 	and	r5,r4,r3
 8000120:	28000b26 	beq	r5,zero,8000150 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 8000124:	100490fa 	slli	r2,r2,3
 8000128:	8085883a 	add	r2,r16,r2
 800012c:	10c00017 	ldw	r3,0(r2)
 8000130:	11000117 	ldw	r4,4(r2)
 8000134:	183ee83a 	callr	r3
 8000138:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
 800013c:	203ff51e 	bne	r4,zero,8000114 <__alt_data_end+0xfc000114>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
 8000140:	dfc00117 	ldw	ra,4(sp)
 8000144:	dc000017 	ldw	r16,0(sp)
 8000148:	dec00204 	addi	sp,sp,8
 800014c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 8000150:	18c7883a 	add	r3,r3,r3
      i++;
 8000154:	10800044 	addi	r2,r2,1

    } while (1);
 8000158:	003ff006 	br	800011c <__alt_data_end+0xfc00011c>

0800015c <alt_instruction_exception_entry>:
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 800015c:	d0a08017 	ldw	r2,-32256(gp)
 8000160:	10000426 	beq	r2,zero,8000174 <alt_instruction_exception_entry+0x18>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 8000164:	200b883a 	mov	r5,r4
 8000168:	000d883a 	mov	r6,zero
 800016c:	013fffc4 	movi	r4,-1
 8000170:	1000683a 	jmp	r2
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 8000174:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
 8000178:	0005883a 	mov	r2,zero
 800017c:	f800283a 	ret

Disassembly of section .text:

08000180 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8000180:	06c30034 	movhi	sp,3072
    ori sp, sp, %lo(__alt_stack_pointer)
 8000184:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 8000188:	06820034 	movhi	gp,2048
    ori gp, gp, %lo(_gp)
 800018c:	d6ba4614 	ori	gp,gp,59672
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8000190:	00820034 	movhi	r2,2048
    ori r2, r2, %lo(__bss_start)
 8000194:	109a9c14 	ori	r2,r2,27248

    movhi r3, %hi(__bss_end)
 8000198:	00c20034 	movhi	r3,2048
    ori r3, r3, %lo(__bss_end)
 800019c:	18dbb614 	ori	r3,r3,28376

    beq r2, r3, 1f
 80001a0:	10c00326 	beq	r2,r3,80001b0 <_start+0x30>

0:
    stw zero, (r2)
 80001a4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 80001a8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 80001ac:	10fffd36 	bltu	r2,r3,80001a4 <__alt_data_end+0xfc0001a4>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 80001b0:	8005a780 	call	8005a78 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 80001b4:	8005b580 	call	8005b58 <alt_main>

080001b8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 80001b8:	003fff06 	br	80001b8 <__alt_data_end+0xfc0001b8>

080001bc <_ZN9EtherCard5beginEtPKhh>:
bool EtherCard::using_dhcp = false;
bool EtherCard::persist_tcp_connection = false;
uint16_t EtherCard::delaycnt = 0; //request gateway ARP lookup

uint8_t EtherCard::begin(const uint16_t size, const uint8_t *macaddr,
                         uint8_t csPin) {
 80001bc:	defffb04 	addi	sp,sp,-20
 80001c0:	dfc00415 	stw	ra,16(sp)
 80001c4:	df000315 	stw	fp,12(sp)
 80001c8:	df000304 	addi	fp,sp,12
 80001cc:	2007883a 	mov	r3,r4
 80001d0:	e17ffe15 	stw	r5,-8(fp)
 80001d4:	3005883a 	mov	r2,r6
 80001d8:	e0fffd0d 	sth	r3,-12(fp)
 80001dc:	e0bfff05 	stb	r2,-4(fp)
  using_dhcp = false;
 80001e0:	d0205ec5 	stb	zero,-32389(gp)
  copyMac(mymac, macaddr);
 80001e4:	e17ffe17 	ldw	r5,-8(fp)
 80001e8:	d1205644 	addi	r4,gp,-32423
 80001ec:	8003f3c0 	call	8003f3c <_ZN9EtherCard7copyMacEPhPKh>
  return initialize(size, mymac, csPin);
 80001f0:	e0bffd0b 	ldhu	r2,-12(fp)
 80001f4:	e0ffff03 	ldbu	r3,-4(fp)
 80001f8:	180d883a 	mov	r6,r3
 80001fc:	d1605644 	addi	r5,gp,-32423
 8000200:	1009883a 	mov	r4,r2
 8000204:	8000df00 	call	8000df0 <_ZN8ENC28J6010initializeEtPKhh>
}
 8000208:	e037883a 	mov	sp,fp
 800020c:	dfc00117 	ldw	ra,4(sp)
 8000210:	df000017 	ldw	fp,0(sp)
 8000214:	dec00204 	addi	sp,sp,8
 8000218:	f800283a 	ret

0800021c <_ZL10dnsRequestPKcb>:
#define DNSCLIENT_SRC_PORT_H 0xE0

#define DNS_TYPE_A 1
#define DNS_CLASS_IN 1

static void dnsRequest (const char *hostname, bool fromRam) {
 800021c:	defffa04 	addi	sp,sp,-24
 8000220:	dfc00515 	stw	ra,20(sp)
 8000224:	df000415 	stw	fp,16(sp)
 8000228:	df000404 	addi	fp,sp,16
 800022c:	e13ffe15 	stw	r4,-8(fp)
 8000230:	2805883a 	mov	r2,r5
 8000234:	e0bfff05 	stb	r2,-4(fp)
    ++dnstid_l; // increment for next request, finally wrap
 8000238:	d0a06003 	ldbu	r2,-32384(gp)
 800023c:	10800044 	addi	r2,r2,1
 8000240:	d0a06005 	stb	r2,-32384(gp)
    if (ether.dnsip[0] == 0)
 8000244:	d0a05cc3 	ldbu	r2,-32397(gp)
 8000248:	10803fcc 	andi	r2,r2,255
 800024c:	1000041e 	bne	r2,zero,8000260 <_ZL10dnsRequestPKcb+0x44>
        memset(ether.dnsip, 8, IP_LEN); // use 8.8.8.8 Google DNS as default
 8000250:	01800104 	movi	r6,4
 8000254:	01400204 	movi	r5,8
 8000258:	d1205cc4 	addi	r4,gp,-32397
 800025c:	8004c5c0 	call	8004c5c <memset>
    ether.udpPrepare((DNSCLIENT_SRC_PORT_H << 8) | dnstid_l, ether.dnsip, DNS_PORT);
 8000260:	d0a06003 	ldbu	r2,-32384(gp)
 8000264:	10c03fcc 	andi	r3,r2,255
 8000268:	00b80004 	movi	r2,-8192
 800026c:	1884b03a 	or	r2,r3,r2
 8000270:	10bfffcc 	andi	r2,r2,65535
 8000274:	01800d44 	movi	r6,53
 8000278:	d1605cc4 	addi	r5,gp,-32397
 800027c:	1009883a 	mov	r4,r2
 8000280:	800284c0 	call	800284c <_ZN9EtherCard10udpPrepareEtPKht>
    memset(gPB + UDP_DATA_P, 0, 12);
 8000284:	00820034 	movhi	r2,2048
 8000288:	109ad184 	addi	r2,r2,27462
 800028c:	01800304 	movi	r6,12
 8000290:	000b883a 	mov	r5,zero
 8000294:	1009883a 	mov	r4,r2
 8000298:	8004c5c0 	call	8004c5c <memset>

    byte *p = gPB + UDP_DATA_P + 12;
 800029c:	00820034 	movhi	r2,2048
 80002a0:	109ad484 	addi	r2,r2,27474
 80002a4:	e0bffc15 	stw	r2,-16(fp)
    char c;
    do {
        byte n = 0;
 80002a8:	e03ffd05 	stb	zero,-12(fp)
        for(;;) {
//            c = fromRam ? *hostname : pgm_read_byte(hostname);
        	c = *hostname;
 80002ac:	e0bffe17 	ldw	r2,-8(fp)
 80002b0:	10800003 	ldbu	r2,0(r2)
 80002b4:	e0bffd45 	stb	r2,-11(fp)
            ++hostname;
 80002b8:	e0bffe17 	ldw	r2,-8(fp)
 80002bc:	10800044 	addi	r2,r2,1
 80002c0:	e0bffe15 	stw	r2,-8(fp)
            if (c == '.' || c == 0)
 80002c4:	e0bffd47 	ldb	r2,-11(fp)
 80002c8:	10800ba0 	cmpeqi	r2,r2,46
 80002cc:	10000b1e 	bne	r2,zero,80002fc <_ZL10dnsRequestPKcb+0xe0>
 80002d0:	e0bffd47 	ldb	r2,-11(fp)
 80002d4:	10000926 	beq	r2,zero,80002fc <_ZL10dnsRequestPKcb+0xe0>
                break;
            p[++n] = c;
 80002d8:	e0bffd03 	ldbu	r2,-12(fp)
 80002dc:	10800044 	addi	r2,r2,1
 80002e0:	e0bffd05 	stb	r2,-12(fp)
 80002e4:	e0bffd03 	ldbu	r2,-12(fp)
 80002e8:	e0fffc17 	ldw	r3,-16(fp)
 80002ec:	1885883a 	add	r2,r3,r2
 80002f0:	e0fffd43 	ldbu	r3,-11(fp)
 80002f4:	10c00005 	stb	r3,0(r2)

    byte *p = gPB + UDP_DATA_P + 12;
    char c;
    do {
        byte n = 0;
        for(;;) {
 80002f8:	003fec06 	br	80002ac <__alt_data_end+0xfc0002ac>
            ++hostname;
            if (c == '.' || c == 0)
                break;
            p[++n] = c;
        }
        *p++ = n;
 80002fc:	e0bffc17 	ldw	r2,-16(fp)
 8000300:	10c00044 	addi	r3,r2,1
 8000304:	e0fffc15 	stw	r3,-16(fp)
 8000308:	e0fffd03 	ldbu	r3,-12(fp)
 800030c:	10c00005 	stb	r3,0(r2)
        p += n;
 8000310:	e0bffd03 	ldbu	r2,-12(fp)
 8000314:	e0fffc17 	ldw	r3,-16(fp)
 8000318:	1885883a 	add	r2,r3,r2
 800031c:	e0bffc15 	stw	r2,-16(fp)
    } while (c != 0);
 8000320:	e0bffd47 	ldb	r2,-11(fp)
 8000324:	10000126 	beq	r2,zero,800032c <_ZL10dnsRequestPKcb+0x110>
    ether.udpPrepare((DNSCLIENT_SRC_PORT_H << 8) | dnstid_l, ether.dnsip, DNS_PORT);
    memset(gPB + UDP_DATA_P, 0, 12);

    byte *p = gPB + UDP_DATA_P + 12;
    char c;
    do {
 8000328:	003fdf06 	br	80002a8 <__alt_data_end+0xfc0002a8>
        }
        *p++ = n;
        p += n;
    } while (c != 0);

    *p++ = 0; // terminate with zero, means root domain.
 800032c:	e0bffc17 	ldw	r2,-16(fp)
 8000330:	10c00044 	addi	r3,r2,1
 8000334:	e0fffc15 	stw	r3,-16(fp)
 8000338:	10000005 	stb	zero,0(r2)
    *p++ = 0;
 800033c:	e0bffc17 	ldw	r2,-16(fp)
 8000340:	10c00044 	addi	r3,r2,1
 8000344:	e0fffc15 	stw	r3,-16(fp)
 8000348:	10000005 	stb	zero,0(r2)
    *p++ = DNS_TYPE_A;
 800034c:	e0bffc17 	ldw	r2,-16(fp)
 8000350:	10c00044 	addi	r3,r2,1
 8000354:	e0fffc15 	stw	r3,-16(fp)
 8000358:	00c00044 	movi	r3,1
 800035c:	10c00005 	stb	r3,0(r2)
    *p++ = 0;
 8000360:	e0bffc17 	ldw	r2,-16(fp)
 8000364:	10c00044 	addi	r3,r2,1
 8000368:	e0fffc15 	stw	r3,-16(fp)
 800036c:	10000005 	stb	zero,0(r2)
    *p++ = DNS_CLASS_IN;
 8000370:	e0bffc17 	ldw	r2,-16(fp)
 8000374:	10c00044 	addi	r3,r2,1
 8000378:	e0fffc15 	stw	r3,-16(fp)
 800037c:	00c00044 	movi	r3,1
 8000380:	10c00005 	stb	r3,0(r2)
    byte i = p - gPB - UDP_DATA_P;
 8000384:	e0bffc17 	ldw	r2,-16(fp)
 8000388:	1007883a 	mov	r3,r2
 800038c:	00820034 	movhi	r2,2048
 8000390:	109ac704 	addi	r2,r2,27420
 8000394:	1009883a 	mov	r4,r2
 8000398:	00bff584 	movi	r2,-42
 800039c:	1105c83a 	sub	r2,r2,r4
 80003a0:	1885883a 	add	r2,r3,r2
 80003a4:	e0bffd85 	stb	r2,-10(fp)
    gPB[UDP_DATA_P] = i;
 80003a8:	00820034 	movhi	r2,2048
 80003ac:	109ac704 	addi	r2,r2,27420
 80003b0:	e0fffd83 	ldbu	r3,-10(fp)
 80003b4:	10c00a85 	stb	r3,42(r2)
    gPB[UDP_DATA_P+1] = dnstid_l;
 80003b8:	d0e06003 	ldbu	r3,-32384(gp)
 80003bc:	00820034 	movhi	r2,2048
 80003c0:	109ac704 	addi	r2,r2,27420
 80003c4:	10c00ac5 	stb	r3,43(r2)
    gPB[UDP_DATA_P+2] = 1; // flags, standard recursive query
 80003c8:	00820034 	movhi	r2,2048
 80003cc:	109ac704 	addi	r2,r2,27420
 80003d0:	00c00044 	movi	r3,1
 80003d4:	10c00b05 	stb	r3,44(r2)
    gPB[UDP_DATA_P+5] = 1; // 1 question
 80003d8:	00820034 	movhi	r2,2048
 80003dc:	109ac704 	addi	r2,r2,27420
 80003e0:	00c00044 	movi	r3,1
 80003e4:	10c00bc5 	stb	r3,47(r2)
    ether.udpTransmit(i);
 80003e8:	e0bffd83 	ldbu	r2,-10(fp)
 80003ec:	1009883a 	mov	r4,r2
 80003f0:	80029d40 	call	80029d4 <_ZN9EtherCard11udpTransmitEt>
}
 80003f4:	0001883a 	nop
 80003f8:	e037883a 	mov	sp,fp
 80003fc:	dfc00117 	ldw	ra,4(sp)
 8000400:	df000017 	ldw	fp,0(sp)
 8000404:	dec00204 	addi	sp,sp,8
 8000408:	f800283a 	ret

0800040c <_ZL17checkForDnsAnswert>:

static bool checkForDnsAnswer (uint16_t plen) {
 800040c:	defffc04 	addi	sp,sp,-16
 8000410:	dfc00315 	stw	ra,12(sp)
 8000414:	df000215 	stw	fp,8(sp)
 8000418:	df000204 	addi	fp,sp,8
 800041c:	2005883a 	mov	r2,r4
 8000420:	e0bfff0d 	sth	r2,-4(fp)
    byte *p = gPB + UDP_DATA_P; //start of UDP payload
 8000424:	00820034 	movhi	r2,2048
 8000428:	109ad184 	addi	r2,r2,27462
 800042c:	e0bffe15 	stw	r2,-8(fp)
    if (plen < 70 || gPB[UDP_SRC_PORT_L_P] != DNS_PORT || //from DNS source port
 8000430:	e0bfff0b 	ldhu	r2,-4(fp)
 8000434:	108011b0 	cmpltui	r2,r2,70
 8000438:	10001a1e 	bne	r2,zero,80004a4 <_ZL17checkForDnsAnswert+0x98>
 800043c:	00820034 	movhi	r2,2048
 8000440:	109ac704 	addi	r2,r2,27420
 8000444:	108008c3 	ldbu	r2,35(r2)
 8000448:	10803fcc 	andi	r2,r2,255
 800044c:	10800d58 	cmpnei	r2,r2,53
 8000450:	1000141e 	bne	r2,zero,80004a4 <_ZL17checkForDnsAnswert+0x98>
            gPB[UDP_DST_PORT_H_P] != DNSCLIENT_SRC_PORT_H || //response to same port as we sent from (MSB)
 8000454:	00820034 	movhi	r2,2048
 8000458:	109ac704 	addi	r2,r2,27420
 800045c:	10800903 	ldbu	r2,36(r2)
    ether.udpTransmit(i);
}

static bool checkForDnsAnswer (uint16_t plen) {
    byte *p = gPB + UDP_DATA_P; //start of UDP payload
    if (plen < 70 || gPB[UDP_SRC_PORT_L_P] != DNS_PORT || //from DNS source port
 8000460:	10803fcc 	andi	r2,r2,255
 8000464:	10803818 	cmpnei	r2,r2,224
 8000468:	10000e1e 	bne	r2,zero,80004a4 <_ZL17checkForDnsAnswert+0x98>
            gPB[UDP_DST_PORT_H_P] != DNSCLIENT_SRC_PORT_H || //response to same port as we sent from (MSB)
            gPB[UDP_DST_PORT_L_P] != dnstid_l || //response to same port as we sent from (LSB)
 800046c:	00820034 	movhi	r2,2048
 8000470:	109ac704 	addi	r2,r2,27420
 8000474:	10c00943 	ldbu	r3,37(r2)
 8000478:	d0a06003 	ldbu	r2,-32384(gp)
}

static bool checkForDnsAnswer (uint16_t plen) {
    byte *p = gPB + UDP_DATA_P; //start of UDP payload
    if (plen < 70 || gPB[UDP_SRC_PORT_L_P] != DNS_PORT || //from DNS source port
            gPB[UDP_DST_PORT_H_P] != DNSCLIENT_SRC_PORT_H || //response to same port as we sent from (MSB)
 800047c:	18c03fcc 	andi	r3,r3,255
 8000480:	10803fcc 	andi	r2,r2,255
 8000484:	1880071e 	bne	r3,r2,80004a4 <_ZL17checkForDnsAnswert+0x98>
            gPB[UDP_DST_PORT_L_P] != dnstid_l || //response to same port as we sent from (LSB)
            p[1] != dnstid_l) //message id same as we sent
 8000488:	e0bffe17 	ldw	r2,-8(fp)
 800048c:	10800044 	addi	r2,r2,1
 8000490:	10c00003 	ldbu	r3,0(r2)
 8000494:	d0a06003 	ldbu	r2,-32384(gp)

static bool checkForDnsAnswer (uint16_t plen) {
    byte *p = gPB + UDP_DATA_P; //start of UDP payload
    if (plen < 70 || gPB[UDP_SRC_PORT_L_P] != DNS_PORT || //from DNS source port
            gPB[UDP_DST_PORT_H_P] != DNSCLIENT_SRC_PORT_H || //response to same port as we sent from (MSB)
            gPB[UDP_DST_PORT_L_P] != dnstid_l || //response to same port as we sent from (LSB)
 8000498:	18c03fcc 	andi	r3,r3,255
 800049c:	10803fcc 	andi	r2,r2,255
 80004a0:	18800226 	beq	r3,r2,80004ac <_ZL17checkForDnsAnswert+0xa0>
            p[1] != dnstid_l) //message id same as we sent
        return false; //not our DNS response
 80004a4:	0005883a 	mov	r2,zero
 80004a8:	00004d06 	br	80005e0 <_ZL17checkForDnsAnswert+0x1d4>
    if((p[3] & 0x0F) != 0)
 80004ac:	e0bffe17 	ldw	r2,-8(fp)
 80004b0:	108000c4 	addi	r2,r2,3
 80004b4:	10800003 	ldbu	r2,0(r2)
 80004b8:	10803fcc 	andi	r2,r2,255
 80004bc:	108003cc 	andi	r2,r2,15
 80004c0:	10000226 	beq	r2,zero,80004cc <_ZL17checkForDnsAnswert+0xc0>
        return true; //DNS response received with error
 80004c4:	00800044 	movi	r2,1
 80004c8:	00004506 	br	80005e0 <_ZL17checkForDnsAnswert+0x1d4>

    p += *p; // we encoded the query len into tid
 80004cc:	e0bffe17 	ldw	r2,-8(fp)
 80004d0:	10800003 	ldbu	r2,0(r2)
 80004d4:	10803fcc 	andi	r2,r2,255
 80004d8:	e0fffe17 	ldw	r3,-8(fp)
 80004dc:	1885883a 	add	r2,r3,r2
 80004e0:	e0bffe15 	stw	r2,-8(fp)
    for (;;) {
        if (*p & 0xC0)
 80004e4:	e0bffe17 	ldw	r2,-8(fp)
 80004e8:	10800003 	ldbu	r2,0(r2)
 80004ec:	10803fcc 	andi	r2,r2,255
 80004f0:	1080300c 	andi	r2,r2,192
 80004f4:	10000426 	beq	r2,zero,8000508 <_ZL17checkForDnsAnswert+0xfc>
            p += 2;
 80004f8:	e0bffe17 	ldw	r2,-8(fp)
 80004fc:	10800084 	addi	r2,r2,2
 8000500:	e0bffe15 	stw	r2,-8(fp)
 8000504:	00001206 	br	8000550 <_ZL17checkForDnsAnswert+0x144>
        else
            while (++p < gPB + plen) {
 8000508:	e0bffe17 	ldw	r2,-8(fp)
 800050c:	10800044 	addi	r2,r2,1
 8000510:	e0bffe15 	stw	r2,-8(fp)
 8000514:	e0ffff0b 	ldhu	r3,-4(fp)
 8000518:	00820034 	movhi	r2,2048
 800051c:	109ac704 	addi	r2,r2,27420
 8000520:	1885883a 	add	r2,r3,r2
 8000524:	e0fffe17 	ldw	r3,-8(fp)
 8000528:	1885803a 	cmpltu	r2,r3,r2
 800052c:	10803fcc 	andi	r2,r2,255
 8000530:	10000726 	beq	r2,zero,8000550 <_ZL17checkForDnsAnswert+0x144>
                if (*p == 0) {
 8000534:	e0bffe17 	ldw	r2,-8(fp)
 8000538:	10800003 	ldbu	r2,0(r2)
 800053c:	10803fcc 	andi	r2,r2,255
 8000540:	103ff11e 	bne	r2,zero,8000508 <__alt_data_end+0xfc000508>
                    ++p;
 8000544:	e0bffe17 	ldw	r2,-8(fp)
 8000548:	10800044 	addi	r2,r2,1
 800054c:	e0bffe15 	stw	r2,-8(fp)
                    break;
                }
            }
        if (p + 14 > gPB + plen)
 8000550:	e0bffe17 	ldw	r2,-8(fp)
 8000554:	10c00384 	addi	r3,r2,14
 8000558:	e13fff0b 	ldhu	r4,-4(fp)
 800055c:	00820034 	movhi	r2,2048
 8000560:	109ac704 	addi	r2,r2,27420
 8000564:	2085883a 	add	r2,r4,r2
 8000568:	10c01b36 	bltu	r2,r3,80005d8 <_ZL17checkForDnsAnswert+0x1cc>
            break;
        if (p[1] == DNS_TYPE_A && p[9] == 4) { // type "A" and IPv4
 800056c:	e0bffe17 	ldw	r2,-8(fp)
 8000570:	10800044 	addi	r2,r2,1
 8000574:	10800003 	ldbu	r2,0(r2)
 8000578:	10803fcc 	andi	r2,r2,255
 800057c:	10800058 	cmpnei	r2,r2,1
 8000580:	10000c1e 	bne	r2,zero,80005b4 <_ZL17checkForDnsAnswert+0x1a8>
 8000584:	e0bffe17 	ldw	r2,-8(fp)
 8000588:	10800244 	addi	r2,r2,9
 800058c:	10800003 	ldbu	r2,0(r2)
 8000590:	10803fcc 	andi	r2,r2,255
 8000594:	10800118 	cmpnei	r2,r2,4
 8000598:	1000061e 	bne	r2,zero,80005b4 <_ZL17checkForDnsAnswert+0x1a8>
            ether.copyIp(ether.hisip, p + 10);
 800059c:	e0bffe17 	ldw	r2,-8(fp)
 80005a0:	10800284 	addi	r2,r2,10
 80005a4:	100b883a 	mov	r5,r2
 80005a8:	d1205dc4 	addi	r4,gp,-32393
 80005ac:	8003f7c0 	call	8003f7c <_ZN9EtherCard6copyIpEPhPKh>
            break;
 80005b0:	00000a06 	br	80005dc <_ZL17checkForDnsAnswert+0x1d0>
        }
        p += p[9] + 10;
 80005b4:	e0bffe17 	ldw	r2,-8(fp)
 80005b8:	10800244 	addi	r2,r2,9
 80005bc:	10800003 	ldbu	r2,0(r2)
 80005c0:	10803fcc 	andi	r2,r2,255
 80005c4:	10800284 	addi	r2,r2,10
 80005c8:	e0fffe17 	ldw	r3,-8(fp)
 80005cc:	1885883a 	add	r2,r3,r2
 80005d0:	e0bffe15 	stw	r2,-8(fp)
        return false; //not our DNS response
    if((p[3] & 0x0F) != 0)
        return true; //DNS response received with error

    p += *p; // we encoded the query len into tid
    for (;;) {
 80005d4:	003fc306 	br	80004e4 <__alt_data_end+0xfc0004e4>
                    ++p;
                    break;
                }
            }
        if (p + 14 > gPB + plen)
            break;
 80005d8:	0001883a 	nop
            ether.copyIp(ether.hisip, p + 10);
            break;
        }
        p += p[9] + 10;
    }
    return false; //No error
 80005dc:	0005883a 	mov	r2,zero
}
 80005e0:	e037883a 	mov	sp,fp
 80005e4:	dfc00117 	ldw	ra,4(sp)
 80005e8:	df000017 	ldw	fp,0(sp)
 80005ec:	dec00204 	addi	sp,sp,8
 80005f0:	f800283a 	ret

080005f4 <_ZN9EtherCard9dnsLookupEPKcb>:

bool EtherCard::dnsLookup (const char* name, bool fromRam) {
 80005f4:	defffa04 	addi	sp,sp,-24
 80005f8:	dfc00515 	stw	ra,20(sp)
 80005fc:	df000415 	stw	fp,16(sp)
 8000600:	dc000315 	stw	r16,12(sp)
 8000604:	df000404 	addi	fp,sp,16
 8000608:	e13ffd15 	stw	r4,-12(fp)
 800060c:	2805883a 	mov	r2,r5
 8000610:	e0bffe05 	stb	r2,-8(fp)
    uint16_t start = time(NULL);
 8000614:	0009883a 	mov	r4,zero
 8000618:	8004d880 	call	8004d88 <time>
 800061c:	e0bffc0d 	sth	r2,-16(fp)

    while(!isLinkUp())
 8000620:	80010240 	call	8001024 <_ZN8ENC28J608isLinkUpEv>
 8000624:	1080005c 	xori	r2,r2,1
 8000628:	10803fcc 	andi	r2,r2,255
 800062c:	10001526 	beq	r2,zero,8000684 <_ZN9EtherCard9dnsLookupEPKcb+0x90>
    {
        if (difftime(time(NULL), start) >= 30000 / 1000)
 8000630:	0009883a 	mov	r4,zero
 8000634:	8004d880 	call	8004d88 <time>
 8000638:	1007883a 	mov	r3,r2
 800063c:	e0bffc0b 	ldhu	r2,-16(fp)
 8000640:	100b883a 	mov	r5,r2
 8000644:	1809883a 	mov	r4,r3
 8000648:	8004be80 	call	8004be8 <difftime>
 800064c:	1011883a 	mov	r8,r2
 8000650:	1813883a 	mov	r9,r3
 8000654:	04000044 	movi	r16,1
 8000658:	000d883a 	mov	r6,zero
 800065c:	01d00fb4 	movhi	r7,16446
 8000660:	4009883a 	mov	r4,r8
 8000664:	480b883a 	mov	r5,r9
 8000668:	80041c80 	call	80041c8 <__gedf2>
 800066c:	1000010e 	bge	r2,zero,8000674 <_ZN9EtherCard9dnsLookupEPKcb+0x80>
 8000670:	0021883a 	mov	r16,zero
 8000674:	80803fcc 	andi	r2,r16,255
 8000678:	103fe926 	beq	r2,zero,8000620 <__alt_data_end+0xfc000620>
            return false; //timeout waiting for link
 800067c:	0005883a 	mov	r2,zero
 8000680:	00005706 	br	80007e0 <_ZN9EtherCard9dnsLookupEPKcb+0x1ec>
    }
    while(clientWaitingDns())
 8000684:	8002dc40 	call	8002dc4 <_ZN9EtherCard16clientWaitingDnsEv>
 8000688:	10803fcc 	andi	r2,r2,255
 800068c:	1004c03a 	cmpne	r2,r2,zero
 8000690:	10803fcc 	andi	r2,r2,255
 8000694:	10001926 	beq	r2,zero,80006fc <_ZN9EtherCard9dnsLookupEPKcb+0x108>
    {
        packetLoop(packetReceive());
 8000698:	80011480 	call	8001148 <_ZN8ENC28J6013packetReceiveEv>
 800069c:	10bfffcc 	andi	r2,r2,65535
 80006a0:	1009883a 	mov	r4,r2
 80006a4:	80037340 	call	8003734 <_ZN9EtherCard10packetLoopEt>
        if (difftime(time(NULL), start) >= 30000 / 1000)
 80006a8:	0009883a 	mov	r4,zero
 80006ac:	8004d880 	call	8004d88 <time>
 80006b0:	1007883a 	mov	r3,r2
 80006b4:	e0bffc0b 	ldhu	r2,-16(fp)
 80006b8:	100b883a 	mov	r5,r2
 80006bc:	1809883a 	mov	r4,r3
 80006c0:	8004be80 	call	8004be8 <difftime>
 80006c4:	1011883a 	mov	r8,r2
 80006c8:	1813883a 	mov	r9,r3
 80006cc:	04000044 	movi	r16,1
 80006d0:	000d883a 	mov	r6,zero
 80006d4:	01d00fb4 	movhi	r7,16446
 80006d8:	4009883a 	mov	r4,r8
 80006dc:	480b883a 	mov	r5,r9
 80006e0:	80041c80 	call	80041c8 <__gedf2>
 80006e4:	1000010e 	bge	r2,zero,80006ec <_ZN9EtherCard9dnsLookupEPKcb+0xf8>
 80006e8:	0021883a 	mov	r16,zero
 80006ec:	80803fcc 	andi	r2,r16,255
 80006f0:	103fe426 	beq	r2,zero,8000684 <__alt_data_end+0xfc000684>
            return false; //timeout waiting for gateway ARP
 80006f4:	0005883a 	mov	r2,zero
 80006f8:	00003906 	br	80007e0 <_ZN9EtherCard9dnsLookupEPKcb+0x1ec>
    }

    memset(hisip, 0, IP_LEN);
 80006fc:	01800104 	movi	r6,4
 8000700:	000b883a 	mov	r5,zero
 8000704:	d1205dc4 	addi	r4,gp,-32393
 8000708:	8004c5c0 	call	8004c5c <memset>
    dnsRequest(name, fromRam);
 800070c:	e0bffe03 	ldbu	r2,-8(fp)
 8000710:	100b883a 	mov	r5,r2
 8000714:	e13ffd17 	ldw	r4,-12(fp)
 8000718:	800021c0 	call	800021c <_ZL10dnsRequestPKcb>

    start = time(NULL);
 800071c:	0009883a 	mov	r4,zero
 8000720:	8004d880 	call	8004d88 <time>
 8000724:	e0bffc0d 	sth	r2,-16(fp)
    while (hisip[0] == 0) {
 8000728:	d0a05dc3 	ldbu	r2,-32393(gp)
 800072c:	10803fcc 	andi	r2,r2,255
 8000730:	10002a1e 	bne	r2,zero,80007dc <_ZN9EtherCard9dnsLookupEPKcb+0x1e8>
        if (difftime(time(NULL), start) >= 30000 / 1000)
 8000734:	0009883a 	mov	r4,zero
 8000738:	8004d880 	call	8004d88 <time>
 800073c:	1007883a 	mov	r3,r2
 8000740:	e0bffc0b 	ldhu	r2,-16(fp)
 8000744:	100b883a 	mov	r5,r2
 8000748:	1809883a 	mov	r4,r3
 800074c:	8004be80 	call	8004be8 <difftime>
 8000750:	1011883a 	mov	r8,r2
 8000754:	1813883a 	mov	r9,r3
 8000758:	04000044 	movi	r16,1
 800075c:	000d883a 	mov	r6,zero
 8000760:	01d00fb4 	movhi	r7,16446
 8000764:	4009883a 	mov	r4,r8
 8000768:	480b883a 	mov	r5,r9
 800076c:	80041c80 	call	80041c8 <__gedf2>
 8000770:	1000010e 	bge	r2,zero,8000778 <_ZN9EtherCard9dnsLookupEPKcb+0x184>
 8000774:	0021883a 	mov	r16,zero
 8000778:	80803fcc 	andi	r2,r16,255
 800077c:	10000226 	beq	r2,zero,8000788 <_ZN9EtherCard9dnsLookupEPKcb+0x194>
            return false; //timeout waiting for dns response
 8000780:	0005883a 	mov	r2,zero
 8000784:	00001606 	br	80007e0 <_ZN9EtherCard9dnsLookupEPKcb+0x1ec>
        uint16_t len = packetReceive();
 8000788:	80011480 	call	8001148 <_ZN8ENC28J6013packetReceiveEv>
 800078c:	e0bffc8d 	sth	r2,-14(fp)
        if (len > 0 && packetLoop(len) == 0) //packet not handled by tcp/ip packet loop
 8000790:	e0bffc8b 	ldhu	r2,-14(fp)
 8000794:	10000726 	beq	r2,zero,80007b4 <_ZN9EtherCard9dnsLookupEPKcb+0x1c0>
 8000798:	e0bffc8b 	ldhu	r2,-14(fp)
 800079c:	1009883a 	mov	r4,r2
 80007a0:	80037340 	call	8003734 <_ZN9EtherCard10packetLoopEt>
 80007a4:	10bfffcc 	andi	r2,r2,65535
 80007a8:	1000021e 	bne	r2,zero,80007b4 <_ZN9EtherCard9dnsLookupEPKcb+0x1c0>
 80007ac:	00800044 	movi	r2,1
 80007b0:	00000106 	br	80007b8 <_ZN9EtherCard9dnsLookupEPKcb+0x1c4>
 80007b4:	0005883a 	mov	r2,zero
 80007b8:	10803fcc 	andi	r2,r2,255
 80007bc:	103fda26 	beq	r2,zero,8000728 <__alt_data_end+0xfc000728>
            if(checkForDnsAnswer(len))
 80007c0:	e0bffc8b 	ldhu	r2,-14(fp)
 80007c4:	1009883a 	mov	r4,r2
 80007c8:	800040c0 	call	800040c <_ZL17checkForDnsAnswert>
 80007cc:	10803fcc 	andi	r2,r2,255
 80007d0:	103fd526 	beq	r2,zero,8000728 <__alt_data_end+0xfc000728>
                return false; //DNS response received with error
 80007d4:	0005883a 	mov	r2,zero
 80007d8:	00000106 	br	80007e0 <_ZN9EtherCard9dnsLookupEPKcb+0x1ec>
    }

    return true;
 80007dc:	00800044 	movi	r2,1
}
 80007e0:	e6ffff04 	addi	sp,fp,-4
 80007e4:	dfc00217 	ldw	ra,8(sp)
 80007e8:	df000117 	ldw	fp,4(sp)
 80007ec:	dc000017 	ldw	r16,0(sp)
 80007f0:	dec00304 	addi	sp,sp,12
 80007f4:	f800283a 	ret

080007f8 <_Z5delayi>:
struct transmit_status_vector {
    uint8_t bytes[7];
};

void delay(int milli_seconds)
{
 80007f8:	defffc04 	addi	sp,sp,-16
 80007fc:	dfc00315 	stw	ra,12(sp)
 8000800:	df000215 	stw	fp,8(sp)
 8000804:	df000204 	addi	fp,sp,8
 8000808:	e13fff15 	stw	r4,-4(fp)
    // Converting time into milli_seconds
    // Storing start time
    clock_t start_time = clock();
 800080c:	8004b9c0 	call	8004b9c <clock>
 8000810:	e0bffe15 	stw	r2,-8(fp)

    // looping till required time is not achieved
    while (clock() < start_time + milli_seconds)
 8000814:	8004b9c0 	call	8004b9c <clock>
 8000818:	1009883a 	mov	r4,r2
 800081c:	e0ffff17 	ldw	r3,-4(fp)
 8000820:	e0bffe17 	ldw	r2,-8(fp)
 8000824:	1885883a 	add	r2,r3,r2
 8000828:	2085803a 	cmpltu	r2,r4,r2
 800082c:	10803fcc 	andi	r2,r2,255
 8000830:	10000126 	beq	r2,zero,8000838 <_Z5delayi+0x40>
 8000834:	003ff706 	br	8000814 <__alt_data_end+0xfc000814>
        ;
}
 8000838:	0001883a 	nop
 800083c:	e037883a 	mov	sp,fp
 8000840:	dfc00117 	ldw	ra,4(sp)
 8000844:	df000017 	ldw	fp,0(sp)
 8000848:	dec00204 	addi	sp,sp,8
 800084c:	f800283a 	ret

08000850 <_Z7bitReadhh>:

// Returns nth bit of x
uint8_t bitRead(uint8_t x, uint8_t n) {
 8000850:	defffd04 	addi	sp,sp,-12
 8000854:	df000215 	stw	fp,8(sp)
 8000858:	df000204 	addi	fp,sp,8
 800085c:	2007883a 	mov	r3,r4
 8000860:	2805883a 	mov	r2,r5
 8000864:	e0fffe05 	stb	r3,-8(fp)
 8000868:	e0bfff05 	stb	r2,-4(fp)
    return (x >> n) & 0x1;
 800086c:	e0fffe03 	ldbu	r3,-8(fp)
 8000870:	e0bfff03 	ldbu	r2,-4(fp)
 8000874:	1885d83a 	sra	r2,r3,r2
 8000878:	1080004c 	andi	r2,r2,1
}
 800087c:	e037883a 	mov	sp,fp
 8000880:	df000017 	ldw	fp,0(sp)
 8000884:	dec00104 	addi	sp,sp,4
 8000888:	f800283a 	ret

0800088c <_Z11disableChipv>:

// disableChip, enableChip -- pass in
// IRQ ID's after creating the SPI module for the ethernet controller
void disableChip() {
 800088c:	defffe04 	addi	sp,sp,-8
 8000890:	dfc00115 	stw	ra,4(sp)
 8000894:	df000015 	stw	fp,0(sp)
 8000898:	d839883a 	mov	fp,sp
  // TODO set slave select to high (it's active low)
  alt_ic_irq_disable(SPI_0_IRQ_INTERRUPT_CONTROLLER_ID, SPI_0_IRQ);
 800089c:	014000c4 	movi	r5,3
 80008a0:	0009883a 	mov	r4,zero
 80008a4:	80059c00 	call	80059c0 <alt_ic_irq_disable>
}
 80008a8:	0001883a 	nop
 80008ac:	e037883a 	mov	sp,fp
 80008b0:	dfc00117 	ldw	ra,4(sp)
 80008b4:	df000017 	ldw	fp,0(sp)
 80008b8:	dec00204 	addi	sp,sp,8
 80008bc:	f800283a 	ret

080008c0 <_Z10enableChipv>:

// disableChip, enableChip -- pass in
// IRQ ID's after creating the SPI module for the ethernet controller
void enableChip() {
 80008c0:	defffe04 	addi	sp,sp,-8
 80008c4:	dfc00115 	stw	ra,4(sp)
 80008c8:	df000015 	stw	fp,0(sp)
 80008cc:	d839883a 	mov	fp,sp
  alt_ic_irq_enable(SPI_0_IRQ_INTERRUPT_CONTROLLER_ID, SPI_0_IRQ);
 80008d0:	014000c4 	movi	r5,3
 80008d4:	0009883a 	mov	r4,zero
 80008d8:	80059880 	call	8005988 <alt_ic_irq_enable>
  // TODO set slave select to low (it's active low)
}
 80008dc:	0001883a 	nop
 80008e0:	e037883a 	mov	sp,fp
 80008e4:	dfc00117 	ldw	ra,4(sp)
 80008e8:	df000017 	ldw	fp,0(sp)
 80008ec:	dec00204 	addi	sp,sp,8
 80008f0:	f800283a 	ret

080008f4 <_Z12digitalWritehh>:


// status -- 1 (HIGH), 0 (LOW)
int digitalWrite(uint8_t whichPin, uint8_t status) {
 80008f4:	defffd04 	addi	sp,sp,-12
 80008f8:	df000215 	stw	fp,8(sp)
 80008fc:	df000204 	addi	fp,sp,8
 8000900:	2007883a 	mov	r3,r4
 8000904:	2805883a 	mov	r2,r5
 8000908:	e0fffe05 	stb	r3,-8(fp)
 800090c:	e0bfff05 	stb	r2,-4(fp)
  if (status != LOW || status != HIGH) return -1;
 8000910:	e0bfff03 	ldbu	r2,-4(fp)
 8000914:	1000031e 	bne	r2,zero,8000924 <_Z12digitalWritehh+0x30>
 8000918:	e0bfff03 	ldbu	r2,-4(fp)
 800091c:	10800060 	cmpeqi	r2,r2,1
 8000920:	1000021e 	bne	r2,zero,800092c <_Z12digitalWritehh+0x38>
 8000924:	00bfffc4 	movi	r2,-1
 8000928:	00001606 	br	8000984 <_Z12digitalWritehh+0x90>
  if (status == HIGH) {
 800092c:	e0bfff03 	ldbu	r2,-4(fp)
 8000930:	10800058 	cmpnei	r2,r2,1
 8000934:	1000091e 	bne	r2,zero,800095c <_Z12digitalWritehh+0x68>
    *GPIO_PIO |= 1 << whichPin;
 8000938:	d0a00117 	ldw	r2,-32764(gp)
 800093c:	d0e00117 	ldw	r3,-32764(gp)
 8000940:	18c00017 	ldw	r3,0(r3)
 8000944:	e13ffe03 	ldbu	r4,-8(fp)
 8000948:	01400044 	movi	r5,1
 800094c:	2908983a 	sll	r4,r5,r4
 8000950:	1906b03a 	or	r3,r3,r4
 8000954:	10c00015 	stw	r3,0(r2)
 8000958:	00000906 	br	8000980 <_Z12digitalWritehh+0x8c>
  } else {// status == LOW
    *GPIO_PIO &= ~(1 << whichPin);
 800095c:	d0a00117 	ldw	r2,-32764(gp)
 8000960:	d0e00117 	ldw	r3,-32764(gp)
 8000964:	18c00017 	ldw	r3,0(r3)
 8000968:	e13ffe03 	ldbu	r4,-8(fp)
 800096c:	01400044 	movi	r5,1
 8000970:	2908983a 	sll	r4,r5,r4
 8000974:	0108303a 	nor	r4,zero,r4
 8000978:	1906703a 	and	r3,r3,r4
 800097c:	10c00015 	stw	r3,0(r2)
  }
  return 0;
 8000980:	0005883a 	mov	r2,zero
}
 8000984:	e037883a 	mov	sp,fp
 8000988:	df000017 	ldw	fp,0(sp)
 800098c:	dec00104 	addi	sp,sp,4
 8000990:	f800283a 	ret

08000994 <_ZL7xferSPIh>:

static void xferSPI (uint8_t data) {
 8000994:	defff904 	addi	sp,sp,-28
 8000998:	dfc00615 	stw	ra,24(sp)
 800099c:	df000515 	stw	fp,20(sp)
 80009a0:	df000504 	addi	fp,sp,20
 80009a4:	2005883a 	mov	r2,r4
 80009a8:	e0bfff05 	stb	r2,-4(fp)
  SPDR[0] = data;
 80009ac:	e0bfff03 	ldbu	r2,-4(fp)
 80009b0:	d0a06185 	stb	r2,-32378(gp)
  uint8_t write_data[1] = {data};
 80009b4:	e0bfff03 	ldbu	r2,-4(fp)
 80009b8:	e0bffe05 	stb	r2,-8(fp)
                            ETHERNET_CHIP_SLAVE,
                            1, // write one byte
                            write_data, // write data
                            1, // Read one byte
                            SPDR, // read into SPDR
                            0); // no flags
 80009bc:	d8000215 	stw	zero,8(sp)
 80009c0:	d0a06184 	addi	r2,gp,-32378
 80009c4:	d8800115 	stw	r2,4(sp)
 80009c8:	00800044 	movi	r2,1
 80009cc:	d8800015 	stw	r2,0(sp)
 80009d0:	e1fffe04 	addi	r7,fp,-8
 80009d4:	01800044 	movi	r6,1
 80009d8:	000b883a 	mov	r5,zero
 80009dc:	01000074 	movhi	r4,1
 80009e0:	21042804 	addi	r4,r4,4256
 80009e4:	8005d9c0 	call	8005d9c <alt_avalon_spi_command>
}
 80009e8:	0001883a 	nop
 80009ec:	e037883a 	mov	sp,fp
 80009f0:	dfc00117 	ldw	ra,4(sp)
 80009f4:	df000017 	ldw	fp,0(sp)
 80009f8:	dec00204 	addi	sp,sp,8
 80009fc:	f800283a 	ret

08000a00 <_ZL7writeOphhh>:

static void writeOp (uint8_t op, uint8_t address, uint8_t data) {
 8000a00:	defffb04 	addi	sp,sp,-20
 8000a04:	dfc00415 	stw	ra,16(sp)
 8000a08:	df000315 	stw	fp,12(sp)
 8000a0c:	df000304 	addi	fp,sp,12
 8000a10:	2807883a 	mov	r3,r5
 8000a14:	3005883a 	mov	r2,r6
 8000a18:	e13ffd05 	stb	r4,-12(fp)
 8000a1c:	e0fffe05 	stb	r3,-8(fp)
 8000a20:	e0bfff05 	stb	r2,-4(fp)
    enableChip();
 8000a24:	80008c00 	call	80008c0 <_Z10enableChipv>
    xferSPI(op | (address & ADDR_MASK));
 8000a28:	e0bffe03 	ldbu	r2,-8(fp)
 8000a2c:	108007cc 	andi	r2,r2,31
 8000a30:	1007883a 	mov	r3,r2
 8000a34:	e0bffd03 	ldbu	r2,-12(fp)
 8000a38:	1884b03a 	or	r2,r3,r2
 8000a3c:	10803fcc 	andi	r2,r2,255
 8000a40:	1009883a 	mov	r4,r2
 8000a44:	80009940 	call	8000994 <_ZL7xferSPIh>
    xferSPI(data);
 8000a48:	e0bfff03 	ldbu	r2,-4(fp)
 8000a4c:	1009883a 	mov	r4,r2
 8000a50:	80009940 	call	8000994 <_ZL7xferSPIh>
    disableChip();
 8000a54:	800088c0 	call	800088c <_Z11disableChipv>
}
 8000a58:	0001883a 	nop
 8000a5c:	e037883a 	mov	sp,fp
 8000a60:	dfc00117 	ldw	ra,4(sp)
 8000a64:	df000017 	ldw	fp,0(sp)
 8000a68:	dec00204 	addi	sp,sp,8
 8000a6c:	f800283a 	ret

08000a70 <_ZL6readOphh>:

static uint8_t readOp (uint8_t op, uint8_t address) {
 8000a70:	defffb04 	addi	sp,sp,-20
 8000a74:	dfc00415 	stw	ra,16(sp)
 8000a78:	df000315 	stw	fp,12(sp)
 8000a7c:	df000304 	addi	fp,sp,12
 8000a80:	2007883a 	mov	r3,r4
 8000a84:	2805883a 	mov	r2,r5
 8000a88:	e0fffe05 	stb	r3,-8(fp)
 8000a8c:	e0bfff05 	stb	r2,-4(fp)
    enableChip();
 8000a90:	80008c00 	call	80008c0 <_Z10enableChipv>
    xferSPI(op | (address & ADDR_MASK));
 8000a94:	e0bfff03 	ldbu	r2,-4(fp)
 8000a98:	108007cc 	andi	r2,r2,31
 8000a9c:	1007883a 	mov	r3,r2
 8000aa0:	e0bffe03 	ldbu	r2,-8(fp)
 8000aa4:	1884b03a 	or	r2,r3,r2
 8000aa8:	10803fcc 	andi	r2,r2,255
 8000aac:	1009883a 	mov	r4,r2
 8000ab0:	80009940 	call	8000994 <_ZL7xferSPIh>
    xferSPI(0x00);
 8000ab4:	0009883a 	mov	r4,zero
 8000ab8:	80009940 	call	8000994 <_ZL7xferSPIh>
    if (address & 0x80)
 8000abc:	e0bfff03 	ldbu	r2,-4(fp)
 8000ac0:	10803fcc 	andi	r2,r2,255
 8000ac4:	1080201c 	xori	r2,r2,128
 8000ac8:	10bfe004 	addi	r2,r2,-128
 8000acc:	1000020e 	bge	r2,zero,8000ad8 <_ZL6readOphh+0x68>
        xferSPI(0x00);
 8000ad0:	0009883a 	mov	r4,zero
 8000ad4:	80009940 	call	8000994 <_ZL7xferSPIh>
    uint8_t result = SPDR[0];
 8000ad8:	d0a06183 	ldbu	r2,-32378(gp)
 8000adc:	e0bffd05 	stb	r2,-12(fp)
    disableChip();
 8000ae0:	800088c0 	call	800088c <_Z11disableChipv>
    return result;
 8000ae4:	e0bffd03 	ldbu	r2,-12(fp)
}
 8000ae8:	e037883a 	mov	sp,fp
 8000aec:	dfc00117 	ldw	ra,4(sp)
 8000af0:	df000017 	ldw	fp,0(sp)
 8000af4:	dec00204 	addi	sp,sp,8
 8000af8:	f800283a 	ret

08000afc <_ZL7SetBankh>:

static void SetBank (uint8_t address) {
 8000afc:	defffd04 	addi	sp,sp,-12
 8000b00:	dfc00215 	stw	ra,8(sp)
 8000b04:	df000115 	stw	fp,4(sp)
 8000b08:	df000104 	addi	fp,sp,4
 8000b0c:	2005883a 	mov	r2,r4
 8000b10:	e0bfff05 	stb	r2,-4(fp)
    if ((address & BANK_MASK) != Enc28j60Bank) {
 8000b14:	e0bfff03 	ldbu	r2,-4(fp)
 8000b18:	10c0180c 	andi	r3,r2,96
 8000b1c:	d0a061c3 	ldbu	r2,-32377(gp)
 8000b20:	10803fcc 	andi	r2,r2,255
 8000b24:	18800f26 	beq	r3,r2,8000b64 <_ZL7SetBankh+0x68>
        writeOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_BSEL1|ECON1_BSEL0);
 8000b28:	018000c4 	movi	r6,3
 8000b2c:	014007c4 	movi	r5,31
 8000b30:	01002804 	movi	r4,160
 8000b34:	8000a000 	call	8000a00 <_ZL7writeOphhh>
        Enc28j60Bank = address & BANK_MASK;
 8000b38:	e0bfff03 	ldbu	r2,-4(fp)
 8000b3c:	1080180c 	andi	r2,r2,96
 8000b40:	d0a061c5 	stb	r2,-32377(gp)
        writeOp(ENC28J60_BIT_FIELD_SET, ECON1, Enc28j60Bank>>5);
 8000b44:	d0a061c3 	ldbu	r2,-32377(gp)
 8000b48:	10803fcc 	andi	r2,r2,255
 8000b4c:	1005d17a 	srai	r2,r2,5
 8000b50:	10803fcc 	andi	r2,r2,255
 8000b54:	100d883a 	mov	r6,r2
 8000b58:	014007c4 	movi	r5,31
 8000b5c:	01002004 	movi	r4,128
 8000b60:	8000a000 	call	8000a00 <_ZL7writeOphhh>
    }
}
 8000b64:	0001883a 	nop
 8000b68:	e037883a 	mov	sp,fp
 8000b6c:	dfc00117 	ldw	ra,4(sp)
 8000b70:	df000017 	ldw	fp,0(sp)
 8000b74:	dec00204 	addi	sp,sp,8
 8000b78:	f800283a 	ret

08000b7c <_ZL12writeRegBytehh>:

static void writeRegByte (uint8_t address, uint8_t data) {
 8000b7c:	defffc04 	addi	sp,sp,-16
 8000b80:	dfc00315 	stw	ra,12(sp)
 8000b84:	df000215 	stw	fp,8(sp)
 8000b88:	df000204 	addi	fp,sp,8
 8000b8c:	2007883a 	mov	r3,r4
 8000b90:	2805883a 	mov	r2,r5
 8000b94:	e0fffe05 	stb	r3,-8(fp)
 8000b98:	e0bfff05 	stb	r2,-4(fp)
    SetBank(address);
 8000b9c:	e0bffe03 	ldbu	r2,-8(fp)
 8000ba0:	1009883a 	mov	r4,r2
 8000ba4:	8000afc0 	call	8000afc <_ZL7SetBankh>
    writeOp(ENC28J60_WRITE_CTRL_REG, address, data);
 8000ba8:	e0bffe03 	ldbu	r2,-8(fp)
 8000bac:	e0ffff03 	ldbu	r3,-4(fp)
 8000bb0:	180d883a 	mov	r6,r3
 8000bb4:	100b883a 	mov	r5,r2
 8000bb8:	01001004 	movi	r4,64
 8000bbc:	8000a000 	call	8000a00 <_ZL7writeOphhh>
}
 8000bc0:	0001883a 	nop
 8000bc4:	e037883a 	mov	sp,fp
 8000bc8:	dfc00117 	ldw	ra,4(sp)
 8000bcc:	df000017 	ldw	fp,0(sp)
 8000bd0:	dec00204 	addi	sp,sp,8
 8000bd4:	f800283a 	ret

08000bd8 <_ZL8writeReght>:

static void writeReg(uint8_t address, uint16_t data) {
 8000bd8:	defffc04 	addi	sp,sp,-16
 8000bdc:	dfc00315 	stw	ra,12(sp)
 8000be0:	df000215 	stw	fp,8(sp)
 8000be4:	df000204 	addi	fp,sp,8
 8000be8:	2007883a 	mov	r3,r4
 8000bec:	2805883a 	mov	r2,r5
 8000bf0:	e0fffe05 	stb	r3,-8(fp)
 8000bf4:	e0bfff0d 	sth	r2,-4(fp)
    writeRegByte(address, data);
 8000bf8:	e0bffe03 	ldbu	r2,-8(fp)
 8000bfc:	e0ffff0b 	ldhu	r3,-4(fp)
 8000c00:	18c03fcc 	andi	r3,r3,255
 8000c04:	180b883a 	mov	r5,r3
 8000c08:	1009883a 	mov	r4,r2
 8000c0c:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
    writeRegByte(address + 1, data >> 8);
 8000c10:	e0bffe03 	ldbu	r2,-8(fp)
 8000c14:	10800044 	addi	r2,r2,1
 8000c18:	10c03fcc 	andi	r3,r2,255
 8000c1c:	e0bfff0b 	ldhu	r2,-4(fp)
 8000c20:	1004d23a 	srli	r2,r2,8
 8000c24:	10bfffcc 	andi	r2,r2,65535
 8000c28:	100b883a 	mov	r5,r2
 8000c2c:	1809883a 	mov	r4,r3
 8000c30:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
}
 8000c34:	0001883a 	nop
 8000c38:	e037883a 	mov	sp,fp
 8000c3c:	dfc00117 	ldw	ra,4(sp)
 8000c40:	df000017 	ldw	fp,0(sp)
 8000c44:	dec00204 	addi	sp,sp,8
 8000c48:	f800283a 	ret

08000c4c <_ZL11readRegByteh>:



static uint8_t readRegByte (uint8_t address) {
 8000c4c:	defffd04 	addi	sp,sp,-12
 8000c50:	dfc00215 	stw	ra,8(sp)
 8000c54:	df000115 	stw	fp,4(sp)
 8000c58:	df000104 	addi	fp,sp,4
 8000c5c:	2005883a 	mov	r2,r4
 8000c60:	e0bfff05 	stb	r2,-4(fp)
    SetBank(address);
 8000c64:	e0bfff03 	ldbu	r2,-4(fp)
 8000c68:	1009883a 	mov	r4,r2
 8000c6c:	8000afc0 	call	8000afc <_ZL7SetBankh>
    return readOp(ENC28J60_READ_CTRL_REG, address);
 8000c70:	e0bfff03 	ldbu	r2,-4(fp)
 8000c74:	100b883a 	mov	r5,r2
 8000c78:	0009883a 	mov	r4,zero
 8000c7c:	8000a700 	call	8000a70 <_ZL6readOphh>
}
 8000c80:	e037883a 	mov	sp,fp
 8000c84:	dfc00117 	ldw	ra,4(sp)
 8000c88:	df000017 	ldw	fp,0(sp)
 8000c8c:	dec00204 	addi	sp,sp,8
 8000c90:	f800283a 	ret

08000c94 <_ZL7readRegh>:

static uint16_t readReg(byte address) {
 8000c94:	defffc04 	addi	sp,sp,-16
 8000c98:	dfc00315 	stw	ra,12(sp)
 8000c9c:	df000215 	stw	fp,8(sp)
 8000ca0:	dc000115 	stw	r16,4(sp)
 8000ca4:	df000204 	addi	fp,sp,8
 8000ca8:	2005883a 	mov	r2,r4
 8000cac:	e0bffe05 	stb	r2,-8(fp)
    return readRegByte(address) + (readRegByte(address+1) << 8);
 8000cb0:	e0bffe03 	ldbu	r2,-8(fp)
 8000cb4:	1009883a 	mov	r4,r2
 8000cb8:	8000c4c0 	call	8000c4c <_ZL11readRegByteh>
 8000cbc:	14003fcc 	andi	r16,r2,255
 8000cc0:	e0bffe03 	ldbu	r2,-8(fp)
 8000cc4:	10800044 	addi	r2,r2,1
 8000cc8:	10803fcc 	andi	r2,r2,255
 8000ccc:	1009883a 	mov	r4,r2
 8000cd0:	8000c4c0 	call	8000c4c <_ZL11readRegByteh>
 8000cd4:	10803fcc 	andi	r2,r2,255
 8000cd8:	1004923a 	slli	r2,r2,8
 8000cdc:	8085883a 	add	r2,r16,r2
}
 8000ce0:	e6ffff04 	addi	sp,fp,-4
 8000ce4:	dfc00217 	ldw	ra,8(sp)
 8000ce8:	df000117 	ldw	fp,4(sp)
 8000cec:	dc000017 	ldw	r16,0(sp)
 8000cf0:	dec00304 	addi	sp,sp,12
 8000cf4:	f800283a 	ret

08000cf8 <_ZL8writePhyht>:


static void writePhy (uint8_t address, uint16_t data) {
 8000cf8:	defffc04 	addi	sp,sp,-16
 8000cfc:	dfc00315 	stw	ra,12(sp)
 8000d00:	df000215 	stw	fp,8(sp)
 8000d04:	df000204 	addi	fp,sp,8
 8000d08:	2007883a 	mov	r3,r4
 8000d0c:	2805883a 	mov	r2,r5
 8000d10:	e0fffe05 	stb	r3,-8(fp)
 8000d14:	e0bfff0d 	sth	r2,-4(fp)
    writeRegByte(MIREGADR, address);
 8000d18:	e0bffe03 	ldbu	r2,-8(fp)
 8000d1c:	100b883a 	mov	r5,r2
 8000d20:	01003504 	movi	r4,212
 8000d24:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
    writeReg(MIWR, data);
 8000d28:	e0bfff0b 	ldhu	r2,-4(fp)
 8000d2c:	100b883a 	mov	r5,r2
 8000d30:	01003584 	movi	r4,214
 8000d34:	8000bd80 	call	8000bd8 <_ZL8writeReght>
    while (readRegByte(MISTAT) & MISTAT_BUSY)
 8000d38:	01003a84 	movi	r4,234
 8000d3c:	8000c4c0 	call	8000c4c <_ZL11readRegByteh>
 8000d40:	10803fcc 	andi	r2,r2,255
 8000d44:	1080004c 	andi	r2,r2,1
 8000d48:	1004c03a 	cmpne	r2,r2,zero
 8000d4c:	10803fcc 	andi	r2,r2,255
 8000d50:	10000126 	beq	r2,zero,8000d58 <_ZL8writePhyht+0x60>
 8000d54:	003ff806 	br	8000d38 <__alt_data_end+0xfc000d38>
        ;
}
 8000d58:	0001883a 	nop
 8000d5c:	e037883a 	mov	sp,fp
 8000d60:	dfc00117 	ldw	ra,4(sp)
 8000d64:	df000017 	ldw	fp,0(sp)
 8000d68:	dec00204 	addi	sp,sp,8
 8000d6c:	f800283a 	ret

08000d70 <_ZL11readPhyByteh>:

static uint16_t readPhyByte (uint8_t address) {
 8000d70:	defffd04 	addi	sp,sp,-12
 8000d74:	dfc00215 	stw	ra,8(sp)
 8000d78:	df000115 	stw	fp,4(sp)
 8000d7c:	df000104 	addi	fp,sp,4
 8000d80:	2005883a 	mov	r2,r4
 8000d84:	e0bfff05 	stb	r2,-4(fp)
    writeRegByte(MIREGADR, address);
 8000d88:	e0bfff03 	ldbu	r2,-4(fp)
 8000d8c:	100b883a 	mov	r5,r2
 8000d90:	01003504 	movi	r4,212
 8000d94:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
    writeRegByte(MICMD, MICMD_MIIRD);
 8000d98:	01400044 	movi	r5,1
 8000d9c:	01003484 	movi	r4,210
 8000da0:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
    while (readRegByte(MISTAT) & MISTAT_BUSY)
 8000da4:	01003a84 	movi	r4,234
 8000da8:	8000c4c0 	call	8000c4c <_ZL11readRegByteh>
 8000dac:	10803fcc 	andi	r2,r2,255
 8000db0:	1080004c 	andi	r2,r2,1
 8000db4:	1004c03a 	cmpne	r2,r2,zero
 8000db8:	10803fcc 	andi	r2,r2,255
 8000dbc:	10000126 	beq	r2,zero,8000dc4 <_ZL11readPhyByteh+0x54>
 8000dc0:	003ff806 	br	8000da4 <__alt_data_end+0xfc000da4>
        ;
    writeRegByte(MICMD, 0x00);
 8000dc4:	000b883a 	mov	r5,zero
 8000dc8:	01003484 	movi	r4,210
 8000dcc:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
    return readRegByte(MIRD+1);
 8000dd0:	01003644 	movi	r4,217
 8000dd4:	8000c4c0 	call	8000c4c <_ZL11readRegByteh>
 8000dd8:	10803fcc 	andi	r2,r2,255
}
 8000ddc:	e037883a 	mov	sp,fp
 8000de0:	dfc00117 	ldw	ra,4(sp)
 8000de4:	df000017 	ldw	fp,0(sp)
 8000de8:	dec00204 	addi	sp,sp,8
 8000dec:	f800283a 	ret

08000df0 <_ZN8ENC28J6010initializeEtPKhh>:


uint8_t ENC28J60::initialize(uint16_t size, const uint8_t *macaddr,
                             uint8_t csPin) {
 8000df0:	defffa04 	addi	sp,sp,-24
 8000df4:	dfc00515 	stw	ra,20(sp)
 8000df8:	df000415 	stw	fp,16(sp)
 8000dfc:	df000404 	addi	fp,sp,16
 8000e00:	2007883a 	mov	r3,r4
 8000e04:	e17ffe15 	stw	r5,-8(fp)
 8000e08:	3005883a 	mov	r2,r6
 8000e0c:	e0fffd0d 	sth	r3,-12(fp)
 8000e10:	e0bfff05 	stb	r2,-4(fp)
  bufferSize = size;
 8000e14:	e0bffd0b 	ldhu	r2,-12(fp)
 8000e18:	d0a0608d 	sth	r2,-32382(gp)

  selectPin = csPin;
 8000e1c:	e0bfff03 	ldbu	r2,-4(fp)
 8000e20:	d0a06205 	stb	r2,-32376(gp)

  // if (bitRead(SPCR, SPE) == 0)
  //   initSPI();

  // pinMode(selectPin, OUTPUT);
  disableChip();
 8000e24:	800088c0 	call	800088c <_Z11disableChipv>

  writeOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);
 8000e28:	01803fc4 	movi	r6,255
 8000e2c:	000b883a 	mov	r5,zero
 8000e30:	01003fc4 	movi	r4,255
 8000e34:	8000a000 	call	8000a00 <_ZL7writeOphhh>
  delay(2); // errata B7/2
 8000e38:	01000084 	movi	r4,2
 8000e3c:	80007f80 	call	80007f8 <_Z5delayi>
  while (!(readOp(ENC28J60_READ_CTRL_REG, ESTAT) & ESTAT_CLKRDY))
 8000e40:	01400744 	movi	r5,29
 8000e44:	0009883a 	mov	r4,zero
 8000e48:	8000a700 	call	8000a70 <_ZL6readOphh>
 8000e4c:	10803fcc 	andi	r2,r2,255
 8000e50:	1080004c 	andi	r2,r2,1
 8000e54:	1005003a 	cmpeq	r2,r2,zero
 8000e58:	10803fcc 	andi	r2,r2,255
 8000e5c:	10000126 	beq	r2,zero,8000e64 <_ZN8ENC28J6010initializeEtPKhh+0x74>
 8000e60:	003ff706 	br	8000e40 <__alt_data_end+0xfc000e40>
    ;

  writeReg(ERXST, RXSTART_INIT);
 8000e64:	000b883a 	mov	r5,zero
 8000e68:	01000204 	movi	r4,8
 8000e6c:	8000bd80 	call	8000bd8 <_ZL8writeReght>
  writeReg(ERXRDPT, RXSTART_INIT);
 8000e70:	000b883a 	mov	r5,zero
 8000e74:	01000304 	movi	r4,12
 8000e78:	8000bd80 	call	8000bd8 <_ZL8writeReght>
  writeReg(ERXND, RXSTOP_INIT);
 8000e7c:	0142ffc4 	movi	r5,3071
 8000e80:	01000284 	movi	r4,10
 8000e84:	8000bd80 	call	8000bd8 <_ZL8writeReght>
  writeReg(ETXST, TXSTART_INIT);
 8000e88:	01430004 	movi	r5,3072
 8000e8c:	01000104 	movi	r4,4
 8000e90:	8000bd80 	call	8000bd8 <_ZL8writeReght>
  writeReg(ETXND, TXSTOP_INIT);
 8000e94:	01447fc4 	movi	r5,4607
 8000e98:	01000184 	movi	r4,6
 8000e9c:	8000bd80 	call	8000bd8 <_ZL8writeReght>

  // Stretch pulses for LED, LED_A=Link, LED_B=activity
  writePhy(PHLCON, 0x476);
 8000ea0:	01411d84 	movi	r5,1142
 8000ea4:	01000504 	movi	r4,20
 8000ea8:	8000cf80 	call	8000cf8 <_ZL8writePhyht>

  writeRegByte(ERXFCON,
               ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN | ERXFCON_BCEN);
 8000eac:	01402c44 	movi	r5,177
 8000eb0:	01000e04 	movi	r4,56
 8000eb4:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
  writeReg(EPMM0, 0x303f);
 8000eb8:	014c0fc4 	movi	r5,12351
 8000ebc:	01000a04 	movi	r4,40
 8000ec0:	8000bd80 	call	8000bd8 <_ZL8writeReght>
  writeReg(EPMCS, 0xf7f9);
 8000ec4:	017dfe54 	movui	r5,63481
 8000ec8:	01000c04 	movi	r4,48
 8000ecc:	8000bd80 	call	8000bd8 <_ZL8writeReght>
  writeRegByte(MACON1, MACON1_MARXEN);
 8000ed0:	01400044 	movi	r5,1
 8000ed4:	01003004 	movi	r4,192
 8000ed8:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
  writeOp(ENC28J60_BIT_FIELD_SET, MACON3,
          MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN);
 8000edc:	01800c84 	movi	r6,50
 8000ee0:	01403084 	movi	r5,194
 8000ee4:	01002004 	movi	r4,128
 8000ee8:	8000a000 	call	8000a00 <_ZL7writeOphhh>
  writeReg(MAIPG, 0x0C12);
 8000eec:	01430484 	movi	r5,3090
 8000ef0:	01003184 	movi	r4,198
 8000ef4:	8000bd80 	call	8000bd8 <_ZL8writeReght>
  writeRegByte(MABBIPG, 0x12);
 8000ef8:	01400484 	movi	r5,18
 8000efc:	01003104 	movi	r4,196
 8000f00:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
  writeReg(MAMXFL, MAX_FRAMELEN);
 8000f04:	01417704 	movi	r5,1500
 8000f08:	01003284 	movi	r4,202
 8000f0c:	8000bd80 	call	8000bd8 <_ZL8writeReght>
  writeRegByte(MAADR5, macaddr[0]);
 8000f10:	e0bffe17 	ldw	r2,-8(fp)
 8000f14:	10800003 	ldbu	r2,0(r2)
 8000f18:	10803fcc 	andi	r2,r2,255
 8000f1c:	100b883a 	mov	r5,r2
 8000f20:	01003904 	movi	r4,228
 8000f24:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
  writeRegByte(MAADR4, macaddr[1]);
 8000f28:	e0bffe17 	ldw	r2,-8(fp)
 8000f2c:	10800044 	addi	r2,r2,1
 8000f30:	10800003 	ldbu	r2,0(r2)
 8000f34:	10803fcc 	andi	r2,r2,255
 8000f38:	100b883a 	mov	r5,r2
 8000f3c:	01003944 	movi	r4,229
 8000f40:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
  writeRegByte(MAADR3, macaddr[2]);
 8000f44:	e0bffe17 	ldw	r2,-8(fp)
 8000f48:	10800084 	addi	r2,r2,2
 8000f4c:	10800003 	ldbu	r2,0(r2)
 8000f50:	10803fcc 	andi	r2,r2,255
 8000f54:	100b883a 	mov	r5,r2
 8000f58:	01003884 	movi	r4,226
 8000f5c:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
  writeRegByte(MAADR2, macaddr[3]);
 8000f60:	e0bffe17 	ldw	r2,-8(fp)
 8000f64:	108000c4 	addi	r2,r2,3
 8000f68:	10800003 	ldbu	r2,0(r2)
 8000f6c:	10803fcc 	andi	r2,r2,255
 8000f70:	100b883a 	mov	r5,r2
 8000f74:	010038c4 	movi	r4,227
 8000f78:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
  writeRegByte(MAADR1, macaddr[4]);
 8000f7c:	e0bffe17 	ldw	r2,-8(fp)
 8000f80:	10800104 	addi	r2,r2,4
 8000f84:	10800003 	ldbu	r2,0(r2)
 8000f88:	10803fcc 	andi	r2,r2,255
 8000f8c:	100b883a 	mov	r5,r2
 8000f90:	01003804 	movi	r4,224
 8000f94:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
  writeRegByte(MAADR0, macaddr[5]);
 8000f98:	e0bffe17 	ldw	r2,-8(fp)
 8000f9c:	10800144 	addi	r2,r2,5
 8000fa0:	10800003 	ldbu	r2,0(r2)
 8000fa4:	10803fcc 	andi	r2,r2,255
 8000fa8:	100b883a 	mov	r5,r2
 8000fac:	01003844 	movi	r4,225
 8000fb0:	8000b7c0 	call	8000b7c <_ZL12writeRegBytehh>
  writePhy(PHCON2, PHCON2_HDLDIS);
 8000fb4:	01404004 	movi	r5,256
 8000fb8:	01000404 	movi	r4,16
 8000fbc:	8000cf80 	call	8000cf8 <_ZL8writePhyht>
  SetBank(ECON1);
 8000fc0:	010007c4 	movi	r4,31
 8000fc4:	8000afc0 	call	8000afc <_ZL7SetBankh>
  writeOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE | EIE_PKTIE);
 8000fc8:	01803004 	movi	r6,192
 8000fcc:	014006c4 	movi	r5,27
 8000fd0:	01002004 	movi	r4,128
 8000fd4:	8000a000 	call	8000a00 <_ZL7writeOphhh>
  writeOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
 8000fd8:	01800104 	movi	r6,4
 8000fdc:	014007c4 	movi	r5,31
 8000fe0:	01002004 	movi	r4,128
 8000fe4:	8000a000 	call	8000a00 <_ZL7writeOphhh>

  uint8_t rev = readRegByte(EREVID);
 8000fe8:	01001c84 	movi	r4,114
 8000fec:	8000c4c0 	call	8000c4c <_ZL11readRegByteh>
 8000ff0:	e0bffc05 	stb	r2,-16(fp)
  // microchip forgot to step the number on the silicon when they
  // released the revision B7. 6 is now rev B7. We still have
  // to see what they do when they release B8. At the moment
  // there is no B8 out yet
  if (rev > 5)
 8000ff4:	e0bffc03 	ldbu	r2,-16(fp)
 8000ff8:	108001b0 	cmpltui	r2,r2,6
 8000ffc:	1000031e 	bne	r2,zero,800100c <_ZN8ENC28J6010initializeEtPKhh+0x21c>
    ++rev;
 8001000:	e0bffc03 	ldbu	r2,-16(fp)
 8001004:	10800044 	addi	r2,r2,1
 8001008:	e0bffc05 	stb	r2,-16(fp)
  return rev;
 800100c:	e0bffc03 	ldbu	r2,-16(fp)
}
 8001010:	e037883a 	mov	sp,fp
 8001014:	dfc00117 	ldw	ra,4(sp)
 8001018:	df000017 	ldw	fp,0(sp)
 800101c:	dec00204 	addi	sp,sp,8
 8001020:	f800283a 	ret

08001024 <_ZN8ENC28J608isLinkUpEv>:

bool ENC28J60::isLinkUp() {
 8001024:	defffe04 	addi	sp,sp,-8
 8001028:	dfc00115 	stw	ra,4(sp)
 800102c:	df000015 	stw	fp,0(sp)
 8001030:	d839883a 	mov	fp,sp
    return (readPhyByte(PHSTAT2) >> 2) & 1;
 8001034:	01000444 	movi	r4,17
 8001038:	8000d700 	call	8000d70 <_ZL11readPhyByteh>
 800103c:	10bfffcc 	andi	r2,r2,65535
 8001040:	1080010c 	andi	r2,r2,4
 8001044:	1004c03a 	cmpne	r2,r2,zero
}
 8001048:	e037883a 	mov	sp,fp
 800104c:	dfc00117 	ldw	ra,4(sp)
 8001050:	df000017 	ldw	fp,0(sp)
 8001054:	dec00204 	addi	sp,sp,8
 8001058:	f800283a 	ret

0800105c <_ZL7readBuftPh>:


static void readBuf(uint16_t len, byte* data) {
 800105c:	defff904 	addi	sp,sp,-28
 8001060:	dfc00615 	stw	ra,24(sp)
 8001064:	df000515 	stw	fp,20(sp)
 8001068:	df000504 	addi	fp,sp,20
 800106c:	2005883a 	mov	r2,r4
 8001070:	e17fff15 	stw	r5,-4(fp)
 8001074:	e0bffe0d 	sth	r2,-8(fp)
    uint8_t nextbyte;

    enableChip();
 8001078:	80008c00 	call	80008c0 <_Z10enableChipv>
    if (len != 0) {
 800107c:	e0bffe0b 	ldhu	r2,-8(fp)
 8001080:	10000d26 	beq	r2,zero,80010b8 <_ZL7readBuftPh+0x5c>
        xferSPI(ENC28J60_READ_BUF_MEM);
 8001084:	01000e84 	movi	r4,58
 8001088:	80009940 	call	8000994 <_ZL7xferSPIh>
    	alt_avalon_spi_command( SPI_0_BASE,
 800108c:	e0bffe0b 	ldhu	r2,-8(fp)
    							ETHERNET_CHIP_SLAVE,
    							0, //
    							NULL, // write data
    							len, // Read 8 bytes
    							data, // read into SPDR
    							0); // no flags
 8001090:	d8000215 	stw	zero,8(sp)
 8001094:	e0ffff17 	ldw	r3,-4(fp)
 8001098:	d8c00115 	stw	r3,4(sp)
 800109c:	d8800015 	stw	r2,0(sp)
 80010a0:	000f883a 	mov	r7,zero
 80010a4:	000d883a 	mov	r6,zero
 80010a8:	000b883a 	mov	r5,zero
 80010ac:	01000074 	movhi	r4,1
 80010b0:	21042804 	addi	r4,r4,4256
 80010b4:	8005d9c0 	call	8005d9c <alt_avalon_spi_command>
//        }
//        while (!(SPSR & (1<<SPIF)))
//            ;
//        *data++ = SPDR;
//    }
    disableChip();
 80010b8:	800088c0 	call	800088c <_Z11disableChipv>
}
 80010bc:	0001883a 	nop
 80010c0:	e037883a 	mov	sp,fp
 80010c4:	dfc00117 	ldw	ra,4(sp)
 80010c8:	df000017 	ldw	fp,0(sp)
 80010cc:	dec00204 	addi	sp,sp,8
 80010d0:	f800283a 	ret

080010d4 <_ZL8writeBuftPKh>:

// TODO
static void writeBuf(uint16_t len, const byte* data) {
 80010d4:	defff904 	addi	sp,sp,-28
 80010d8:	dfc00615 	stw	ra,24(sp)
 80010dc:	df000515 	stw	fp,20(sp)
 80010e0:	df000504 	addi	fp,sp,20
 80010e4:	2005883a 	mov	r2,r4
 80010e8:	e17fff15 	stw	r5,-4(fp)
 80010ec:	e0bffe0d 	sth	r2,-8(fp)
    enableChip();
 80010f0:	80008c00 	call	80008c0 <_Z10enableChipv>
    if (len != 0) {
 80010f4:	e0bffe0b 	ldhu	r2,-8(fp)
 80010f8:	10000c26 	beq	r2,zero,800112c <_ZL8writeBuftPKh+0x58>
        xferSPI(ENC28J60_WRITE_BUF_MEM);
 80010fc:	01001e84 	movi	r4,122
 8001100:	80009940 	call	8000994 <_ZL7xferSPIh>

    	alt_avalon_spi_command( SPI_0_BASE,
 8001104:	e0bffe0b 	ldhu	r2,-8(fp)
    							ETHERNET_CHIP_SLAVE,
    							len, // write len bytes
    							data, // write data
    							0, // Read 8 bytes
    							NULL, // read into SPDR
    							0); // no flags
 8001108:	d8000215 	stw	zero,8(sp)
 800110c:	d8000115 	stw	zero,4(sp)
 8001110:	d8000015 	stw	zero,0(sp)
 8001114:	e1ffff17 	ldw	r7,-4(fp)
 8001118:	100d883a 	mov	r6,r2
 800111c:	000b883a 	mov	r5,zero
 8001120:	01000074 	movhi	r4,1
 8001124:	21042804 	addi	r4,r4,4256
 8001128:	8005d9c0 	call	8005d9c <alt_avalon_spi_command>

    }
    disableChip();
 800112c:	800088c0 	call	800088c <_Z11disableChipv>
}
 8001130:	0001883a 	nop
 8001134:	e037883a 	mov	sp,fp
 8001138:	dfc00117 	ldw	ra,4(sp)
 800113c:	df000017 	ldw	fp,0(sp)
 8001140:	dec00204 	addi	sp,sp,8
 8001144:	f800283a 	ret

08001148 <_ZN8ENC28J6013packetReceiveEv>:

uint16_t ENC28J60::packetReceive() {
 8001148:	defffc04 	addi	sp,sp,-16
 800114c:	dfc00315 	stw	ra,12(sp)
 8001150:	df000215 	stw	fp,8(sp)
 8001154:	df000204 	addi	fp,sp,8
    static uint16_t gNextPacketPtr = RXSTART_INIT;
    static bool     unreleasedPacket = false;
    uint16_t len = 0;
 8001158:	e03ffe0d 	sth	zero,-8(fp)

    if (unreleasedPacket) {
 800115c:	d0a06243 	ldbu	r2,-32375(gp)
 8001160:	10803fcc 	andi	r2,r2,255
 8001164:	10000e26 	beq	r2,zero,80011a0 <_ZN8ENC28J6013packetReceiveEv+0x58>
        if (gNextPacketPtr == 0)
 8001168:	d0a0628b 	ldhu	r2,-32374(gp)
 800116c:	10bfffcc 	andi	r2,r2,65535
 8001170:	1000041e 	bne	r2,zero,8001184 <_ZN8ENC28J6013packetReceiveEv+0x3c>
            writeReg(ERXRDPT, RXSTOP_INIT);
 8001174:	0142ffc4 	movi	r5,3071
 8001178:	01000304 	movi	r4,12
 800117c:	8000bd80 	call	8000bd8 <_ZL8writeReght>
 8001180:	00000606 	br	800119c <_ZN8ENC28J6013packetReceiveEv+0x54>
        else
            writeReg(ERXRDPT, gNextPacketPtr - 1);
 8001184:	d0a0628b 	ldhu	r2,-32374(gp)
 8001188:	10bfffc4 	addi	r2,r2,-1
 800118c:	10bfffcc 	andi	r2,r2,65535
 8001190:	100b883a 	mov	r5,r2
 8001194:	01000304 	movi	r4,12
 8001198:	8000bd80 	call	8000bd8 <_ZL8writeReght>
        unreleasedPacket = false;
 800119c:	d0206245 	stb	zero,-32375(gp)
    }

    if (readRegByte(EPKTCNT) > 0) {
 80011a0:	01000e44 	movi	r4,57
 80011a4:	8000c4c0 	call	8000c4c <_ZL11readRegByteh>
 80011a8:	10803fcc 	andi	r2,r2,255
 80011ac:	1004c03a 	cmpne	r2,r2,zero
 80011b0:	10803fcc 	andi	r2,r2,255
 80011b4:	10002e26 	beq	r2,zero,8001270 <_ZN8ENC28J6013packetReceiveEv+0x128>
        writeReg(ERDPT, gNextPacketPtr);
 80011b8:	d0a0628b 	ldhu	r2,-32374(gp)
 80011bc:	10bfffcc 	andi	r2,r2,65535
 80011c0:	100b883a 	mov	r5,r2
 80011c4:	0009883a 	mov	r4,zero
 80011c8:	8000bd80 	call	8000bd8 <_ZL8writeReght>
            uint16_t nextPacket;
            uint16_t byteCount;
            uint16_t status;
        } header;

        readBuf(sizeof header, (byte*) &header);
 80011cc:	00800184 	movi	r2,6
 80011d0:	10bfffcc 	andi	r2,r2,65535
 80011d4:	e0fffe84 	addi	r3,fp,-6
 80011d8:	180b883a 	mov	r5,r3
 80011dc:	1009883a 	mov	r4,r2
 80011e0:	800105c0 	call	800105c <_ZL7readBuftPh>

        gNextPacketPtr  = header.nextPacket;
 80011e4:	e0bffe8b 	ldhu	r2,-6(fp)
 80011e8:	d0a0628d 	sth	r2,-32374(gp)
        len = header.byteCount - 4; //remove the CRC count
 80011ec:	e0bfff0b 	ldhu	r2,-4(fp)
 80011f0:	10bfff04 	addi	r2,r2,-4
 80011f4:	e0bffe0d 	sth	r2,-8(fp)
        if (len>bufferSize-1)
 80011f8:	e0bffe0b 	ldhu	r2,-8(fp)
 80011fc:	d0e0608b 	ldhu	r3,-32382(gp)
 8001200:	18ffffcc 	andi	r3,r3,65535
 8001204:	18ffffc4 	addi	r3,r3,-1
 8001208:	1880030e 	bge	r3,r2,8001218 <_ZN8ENC28J6013packetReceiveEv+0xd0>
            len=bufferSize-1;
 800120c:	d0a0608b 	ldhu	r2,-32382(gp)
 8001210:	10bfffc4 	addi	r2,r2,-1
 8001214:	e0bffe0d 	sth	r2,-8(fp)
        if ((header.status & 0x80)==0)
 8001218:	e0bfff8b 	ldhu	r2,-2(fp)
 800121c:	10bfffcc 	andi	r2,r2,65535
 8001220:	1080200c 	andi	r2,r2,128
 8001224:	1000021e 	bne	r2,zero,8001230 <_ZN8ENC28J6013packetReceiveEv+0xe8>
            len = 0;
 8001228:	e03ffe0d 	sth	zero,-8(fp)
 800122c:	00000506 	br	8001244 <_ZN8ENC28J6013packetReceiveEv+0xfc>
        else
            readBuf(len, buffer);
 8001230:	e0bffe0b 	ldhu	r2,-8(fp)
 8001234:	01420034 	movhi	r5,2048
 8001238:	295ac704 	addi	r5,r5,27420
 800123c:	1009883a 	mov	r4,r2
 8001240:	800105c0 	call	800105c <_ZL7readBuftPh>
        buffer[len] = 0;
 8001244:	e0fffe0b 	ldhu	r3,-8(fp)
 8001248:	00820034 	movhi	r2,2048
 800124c:	109ac704 	addi	r2,r2,27420
 8001250:	10c5883a 	add	r2,r2,r3
 8001254:	10000005 	stb	zero,0(r2)
        unreleasedPacket = true;
 8001258:	00800044 	movi	r2,1
 800125c:	d0a06245 	stb	r2,-32375(gp)

        writeOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
 8001260:	01801004 	movi	r6,64
 8001264:	01400784 	movi	r5,30
 8001268:	01002004 	movi	r4,128
 800126c:	8000a000 	call	8000a00 <_ZL7writeOphhh>
    }
    return len;
 8001270:	e0bffe0b 	ldhu	r2,-8(fp)
}
 8001274:	e037883a 	mov	sp,fp
 8001278:	dfc00117 	ldw	ra,4(sp)
 800127c:	df000017 	ldw	fp,0(sp)
 8001280:	dec00204 	addi	sp,sp,8
 8001284:	f800283a 	ret

08001288 <_ZN8ENC28J6010packetSendEt>:


void ENC28J60::packetSend(uint16_t len) {
 8001288:	defffa04 	addi	sp,sp,-24
 800128c:	dfc00515 	stw	ra,20(sp)
 8001290:	df000415 	stw	fp,16(sp)
 8001294:	df000404 	addi	fp,sp,16
 8001298:	2005883a 	mov	r2,r4
 800129c:	e0bfff0d 	sth	r2,-4(fp)
    byte retry = 0;
 80012a0:	e03ffc85 	stb	zero,-14(fp)
        // the Microchip TCP/IP stack implementation used to first check
        // whether TXERIF is set and only then reset the transmit logic
        // but this has been changed in later versions; possibly they
        // have a reason for this; they don't mention this in the errata
        // sheet
        writeOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRST);
 80012a4:	01802004 	movi	r6,128
 80012a8:	014007c4 	movi	r5,31
 80012ac:	01002004 	movi	r4,128
 80012b0:	8000a000 	call	8000a00 <_ZL7writeOphhh>
        writeOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRST);
 80012b4:	01802004 	movi	r6,128
 80012b8:	014007c4 	movi	r5,31
 80012bc:	01002804 	movi	r4,160
 80012c0:	8000a000 	call	8000a00 <_ZL7writeOphhh>
        writeOp(ENC28J60_BIT_FIELD_CLR, EIR, EIR_TXERIF|EIR_TXIF);
 80012c4:	01800284 	movi	r6,10
 80012c8:	01400704 	movi	r5,28
 80012cc:	01002804 	movi	r4,160
 80012d0:	8000a000 	call	8000a00 <_ZL7writeOphhh>

        // prepare new transmission
        if (retry == 0) {
 80012d4:	e0bffc83 	ldbu	r2,-14(fp)
 80012d8:	1000121e 	bne	r2,zero,8001324 <_ZN8ENC28J6010packetSendEt+0x9c>
            writeReg(EWRPT, TXSTART_INIT);
 80012dc:	01430004 	movi	r5,3072
 80012e0:	01000084 	movi	r4,2
 80012e4:	8000bd80 	call	8000bd8 <_ZL8writeReght>
            writeReg(ETXND, TXSTART_INIT+len);
 80012e8:	e0bfff0b 	ldhu	r2,-4(fp)
 80012ec:	10830004 	addi	r2,r2,3072
 80012f0:	10bfffcc 	andi	r2,r2,65535
 80012f4:	100b883a 	mov	r5,r2
 80012f8:	01000184 	movi	r4,6
 80012fc:	8000bd80 	call	8000bd8 <_ZL8writeReght>
            writeOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
 8001300:	000d883a 	mov	r6,zero
 8001304:	000b883a 	mov	r5,zero
 8001308:	01001e84 	movi	r4,122
 800130c:	8000a000 	call	8000a00 <_ZL7writeOphhh>
            writeBuf(len, buffer);
 8001310:	e0bfff0b 	ldhu	r2,-4(fp)
 8001314:	01420034 	movhi	r5,2048
 8001318:	295ac704 	addi	r5,r5,27420
 800131c:	1009883a 	mov	r4,r2
 8001320:	80010d40 	call	80010d4 <_ZL8writeBuftPKh>
        }

        // initiate transmission
        writeOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
 8001324:	01800204 	movi	r6,8
 8001328:	014007c4 	movi	r5,31
 800132c:	01002004 	movi	r4,128
 8001330:	8000a000 	call	8000a00 <_ZL7writeOphhh>
        // wait until transmission has finished; referring to the data sheet and
        // to the errata (Errata Issue 13; Example 1) you only need to wait until either
        // TXIF or TXERIF gets set; however this leads to hangs; apparently Microchip
        // realized this and in later implementations of their tcp/ip stack they introduced
        // a counter to avoid hangs; of course they didn't update the errata sheet
        uint16_t count = 0;
 8001334:	e03ffc0d 	sth	zero,-16(fp)
        while ((readRegByte(EIR) & (EIR_TXIF | EIR_TXERIF)) == 0 && ++count < 1000U)
 8001338:	01000704 	movi	r4,28
 800133c:	8000c4c0 	call	8000c4c <_ZL11readRegByteh>
 8001340:	10803fcc 	andi	r2,r2,255
 8001344:	1080028c 	andi	r2,r2,10
 8001348:	1000081e 	bne	r2,zero,800136c <_ZN8ENC28J6010packetSendEt+0xe4>
 800134c:	e0bffc0b 	ldhu	r2,-16(fp)
 8001350:	10800044 	addi	r2,r2,1
 8001354:	e0bffc0d 	sth	r2,-16(fp)
 8001358:	e0bffc0b 	ldhu	r2,-16(fp)
 800135c:	1080fa28 	cmpgeui	r2,r2,1000
 8001360:	1000021e 	bne	r2,zero,800136c <_ZN8ENC28J6010packetSendEt+0xe4>
 8001364:	00800044 	movi	r2,1
 8001368:	00000106 	br	8001370 <_ZN8ENC28J6010packetSendEt+0xe8>
 800136c:	0005883a 	mov	r2,zero
 8001370:	10803fcc 	andi	r2,r2,255
 8001374:	10000126 	beq	r2,zero,800137c <_ZN8ENC28J6010packetSendEt+0xf4>
 8001378:	003fef06 	br	8001338 <__alt_data_end+0xfc001338>
            ;

        if (!(readRegByte(EIR) & EIR_TXERIF) && count < 1000U) {
 800137c:	01000704 	movi	r4,28
 8001380:	8000c4c0 	call	8000c4c <_ZL11readRegByteh>
 8001384:	10803fcc 	andi	r2,r2,255
 8001388:	1080008c 	andi	r2,r2,2
 800138c:	1000051e 	bne	r2,zero,80013a4 <_ZN8ENC28J6010packetSendEt+0x11c>
 8001390:	e0bffc0b 	ldhu	r2,-16(fp)
 8001394:	1080fa28 	cmpgeui	r2,r2,1000
 8001398:	1000021e 	bne	r2,zero,80013a4 <_ZN8ENC28J6010packetSendEt+0x11c>
 800139c:	00800044 	movi	r2,1
 80013a0:	00000106 	br	80013a8 <_ZN8ENC28J6010packetSendEt+0x120>
 80013a4:	0005883a 	mov	r2,zero
 80013a8:	10803fcc 	andi	r2,r2,255
 80013ac:	1000051e 	bne	r2,zero,80013c4 <_ZN8ENC28J6010packetSendEt+0x13c>
            // no error; start new transmission
            break;
        }

        // cancel previous transmission if stuck
        writeOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
 80013b0:	01800204 	movi	r6,8
 80013b4:	014007c4 	movi	r5,31
 80013b8:	01002804 	movi	r4,160
 80013bc:	8000a000 	call	8000a00 <_ZL7writeOphhh>

    #if ETHERCARD_RETRY_LATECOLLISIONS == 0
        break;
 80013c0:	00000106 	br	80013c8 <_ZN8ENC28J6010packetSendEt+0x140>
        while ((readRegByte(EIR) & (EIR_TXIF | EIR_TXERIF)) == 0 && ++count < 1000U)
            ;

        if (!(readRegByte(EIR) & EIR_TXERIF) && count < 1000U) {
            // no error; start new transmission
            break;
 80013c4:	0001883a 	nop
            break;
        }

        retry++;
    }
}
 80013c8:	0001883a 	nop
 80013cc:	e037883a 	mov	sp,fp
 80013d0:	dfc00117 	ldw	ra,4(sp)
 80013d4:	df000017 	ldw	fp,0(sp)
 80013d8:	dec00204 	addi	sp,sp,8
 80013dc:	f800283a 	ret

080013e0 <_Z4PSTRPc>:
// const unsigned char arpreqhdr[] PROGMEM = { 0,1,8,0,6,4,0,1 }; // ARP request header
// const unsigned char iphdr[] PROGMEM = { 0x45,0,0,0x82,0,0,0x40,0,0x20 }; //IP header
// const unsigned char ntpreqhdr[] PROGMEM = { 0xE3,0,4,0xFA,0,1,0,0,0,1 }; //NTP request header
extern const uint8_t allOnes[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }; // Used for hardware (MAC) and IP broadcast addresses

char* PSTR(char* str){
 80013e0:	defffe04 	addi	sp,sp,-8
 80013e4:	df000115 	stw	fp,4(sp)
 80013e8:	df000104 	addi	fp,sp,4
 80013ec:	e13fff15 	stw	r4,-4(fp)
	return str;
 80013f0:	e0bfff17 	ldw	r2,-4(fp)
}
 80013f4:	e037883a 	mov	sp,fp
 80013f8:	df000017 	ldw	fp,0(sp)
 80013fc:	dec00104 	addi	sp,sp,4
 8001400:	f800283a 	ret

08001404 <_Z8memcpy_PPvPKvj>:
const unsigned char arpreqhdr[] = { 0,1,8,0,6,4,0,1 }; // ARP request header
const unsigned char iphdr[] = { 0x45,0,0,0x82,0,0,0x40,0,0x20 }; //IP header
const unsigned char ntpreqhdr[] = { 0xE3,0,4,0xFA,0,1,0,0,0,1 }; //NTP request header


void* memcpy_P(void* dest, const void* src, std::size_t count) {
 8001404:	defffb04 	addi	sp,sp,-20
 8001408:	dfc00415 	stw	ra,16(sp)
 800140c:	df000315 	stw	fp,12(sp)
 8001410:	df000304 	addi	fp,sp,12
 8001414:	e13ffd15 	stw	r4,-12(fp)
 8001418:	e17ffe15 	stw	r5,-8(fp)
 800141c:	e1bfff15 	stw	r6,-4(fp)
	memcpy(dest, src, count);
 8001420:	e1bfff17 	ldw	r6,-4(fp)
 8001424:	e17ffe17 	ldw	r5,-8(fp)
 8001428:	e13ffd17 	ldw	r4,-12(fp)
 800142c:	8004c340 	call	8004c34 <memcpy>
}
 8001430:	0001883a 	nop
 8001434:	e037883a 	mov	sp,fp
 8001438:	dfc00117 	ldw	ra,4(sp)
 800143c:	df000017 	ldw	fp,0(sp)
 8001440:	dec00204 	addi	sp,sp,8
 8001444:	f800283a 	ret

08001448 <_ZL13fill_checksumhhth>:

static void fill_checksum(uint8_t dest, uint8_t off, uint16_t len,uint8_t type) {
 8001448:	defff804 	addi	sp,sp,-32
 800144c:	df000715 	stw	fp,28(sp)
 8001450:	df000704 	addi	fp,sp,28
 8001454:	2011883a 	mov	r8,r4
 8001458:	2809883a 	mov	r4,r5
 800145c:	3007883a 	mov	r3,r6
 8001460:	3805883a 	mov	r2,r7
 8001464:	e23ffc05 	stb	r8,-16(fp)
 8001468:	e13ffd05 	stb	r4,-12(fp)
 800146c:	e0fffe0d 	sth	r3,-8(fp)
 8001470:	e0bfff05 	stb	r2,-4(fp)
    const uint8_t* ptr = gPB + off;
 8001474:	e0fffd03 	ldbu	r3,-12(fp)
 8001478:	00820034 	movhi	r2,2048
 800147c:	109ac704 	addi	r2,r2,27420
 8001480:	1885883a 	add	r2,r3,r2
 8001484:	e0bff915 	stw	r2,-28(fp)
    uint32_t sum = type==1 ? IP_PROTO_UDP_V+len-8 :
                   type==2 ? IP_PROTO_TCP_V+len-8 : 0;
 8001488:	e0bfff03 	ldbu	r2,-4(fp)
 800148c:	10800058 	cmpnei	r2,r2,1
 8001490:	1000031e 	bne	r2,zero,80014a0 <_ZL13fill_checksumhhth+0x58>
	memcpy(dest, src, count);
}

static void fill_checksum(uint8_t dest, uint8_t off, uint16_t len,uint8_t type) {
    const uint8_t* ptr = gPB + off;
    uint32_t sum = type==1 ? IP_PROTO_UDP_V+len-8 :
 8001494:	e0bffe0b 	ldhu	r2,-8(fp)
 8001498:	10800244 	addi	r2,r2,9
 800149c:	00000706 	br	80014bc <_ZL13fill_checksumhhth+0x74>
                   type==2 ? IP_PROTO_TCP_V+len-8 : 0;
 80014a0:	e0bfff03 	ldbu	r2,-4(fp)
 80014a4:	10800098 	cmpnei	r2,r2,2
 80014a8:	1000031e 	bne	r2,zero,80014b8 <_ZL13fill_checksumhhth+0x70>
 80014ac:	e0bffe0b 	ldhu	r2,-8(fp)
 80014b0:	10bfff84 	addi	r2,r2,-2
 80014b4:	00000106 	br	80014bc <_ZL13fill_checksumhhth+0x74>
 80014b8:	0005883a 	mov	r2,zero
 80014bc:	e0bffa15 	stw	r2,-24(fp)
    while(len >1) {
 80014c0:	e0bffe0b 	ldhu	r2,-8(fp)
 80014c4:	108000b0 	cmpltui	r2,r2,2
 80014c8:	1000151e 	bne	r2,zero,8001520 <_ZL13fill_checksumhhth+0xd8>
        sum += (uint16_t) (((uint32_t)*ptr<<8)|*(ptr+1));
 80014cc:	e0bff917 	ldw	r2,-28(fp)
 80014d0:	10800003 	ldbu	r2,0(r2)
 80014d4:	10803fcc 	andi	r2,r2,255
 80014d8:	1004923a 	slli	r2,r2,8
 80014dc:	1007883a 	mov	r3,r2
 80014e0:	e0bff917 	ldw	r2,-28(fp)
 80014e4:	10800044 	addi	r2,r2,1
 80014e8:	10800003 	ldbu	r2,0(r2)
 80014ec:	10803fcc 	andi	r2,r2,255
 80014f0:	1884b03a 	or	r2,r3,r2
 80014f4:	10bfffcc 	andi	r2,r2,65535
 80014f8:	e0fffa17 	ldw	r3,-24(fp)
 80014fc:	1885883a 	add	r2,r3,r2
 8001500:	e0bffa15 	stw	r2,-24(fp)
        ptr+=2;
 8001504:	e0bff917 	ldw	r2,-28(fp)
 8001508:	10800084 	addi	r2,r2,2
 800150c:	e0bff915 	stw	r2,-28(fp)
        len-=2;
 8001510:	e0bffe0b 	ldhu	r2,-8(fp)
 8001514:	10bfff84 	addi	r2,r2,-2
 8001518:	e0bffe0d 	sth	r2,-8(fp)

static void fill_checksum(uint8_t dest, uint8_t off, uint16_t len,uint8_t type) {
    const uint8_t* ptr = gPB + off;
    uint32_t sum = type==1 ? IP_PROTO_UDP_V+len-8 :
                   type==2 ? IP_PROTO_TCP_V+len-8 : 0;
    while(len >1) {
 800151c:	003fe806 	br	80014c0 <__alt_data_end+0xfc0014c0>
        sum += (uint16_t) (((uint32_t)*ptr<<8)|*(ptr+1));
        ptr+=2;
        len-=2;
    }
    if (len)
 8001520:	e0bffe0b 	ldhu	r2,-8(fp)
 8001524:	10000726 	beq	r2,zero,8001544 <_ZL13fill_checksumhhth+0xfc>
        sum += ((uint32_t)*ptr)<<8;
 8001528:	e0bff917 	ldw	r2,-28(fp)
 800152c:	10800003 	ldbu	r2,0(r2)
 8001530:	10803fcc 	andi	r2,r2,255
 8001534:	1004923a 	slli	r2,r2,8
 8001538:	e0fffa17 	ldw	r3,-24(fp)
 800153c:	1885883a 	add	r2,r3,r2
 8001540:	e0bffa15 	stw	r2,-24(fp)
    while (sum>>16)
 8001544:	e0bffa17 	ldw	r2,-24(fp)
 8001548:	1004d43a 	srli	r2,r2,16
 800154c:	10000726 	beq	r2,zero,800156c <_ZL13fill_checksumhhth+0x124>
        sum = (uint16_t) sum + (sum >> 16);
 8001550:	e0bffa17 	ldw	r2,-24(fp)
 8001554:	10ffffcc 	andi	r3,r2,65535
 8001558:	e0bffa17 	ldw	r2,-24(fp)
 800155c:	1004d43a 	srli	r2,r2,16
 8001560:	1885883a 	add	r2,r3,r2
 8001564:	e0bffa15 	stw	r2,-24(fp)
        ptr+=2;
        len-=2;
    }
    if (len)
        sum += ((uint32_t)*ptr)<<8;
    while (sum>>16)
 8001568:	003ff606 	br	8001544 <__alt_data_end+0xfc001544>
        sum = (uint16_t) sum + (sum >> 16);
    uint16_t ck = ~ (uint16_t) sum;
 800156c:	e0bffa17 	ldw	r2,-24(fp)
 8001570:	0084303a 	nor	r2,zero,r2
 8001574:	e0bffb0d 	sth	r2,-20(fp)
    gPB[dest] = ck>>8;
 8001578:	e0fffc03 	ldbu	r3,-16(fp)
 800157c:	e0bffb0b 	ldhu	r2,-20(fp)
 8001580:	1005d23a 	srai	r2,r2,8
 8001584:	1009883a 	mov	r4,r2
 8001588:	00820034 	movhi	r2,2048
 800158c:	109ac704 	addi	r2,r2,27420
 8001590:	10c5883a 	add	r2,r2,r3
 8001594:	11000005 	stb	r4,0(r2)
    gPB[dest+1] = ck;
 8001598:	e0bffc03 	ldbu	r2,-16(fp)
 800159c:	10c00044 	addi	r3,r2,1
 80015a0:	e0bffb0b 	ldhu	r2,-20(fp)
 80015a4:	1009883a 	mov	r4,r2
 80015a8:	00820034 	movhi	r2,2048
 80015ac:	109ac704 	addi	r2,r2,27420
 80015b0:	10c5883a 	add	r2,r2,r3
 80015b4:	11000005 	stb	r4,0(r2)
}
 80015b8:	0001883a 	nop
 80015bc:	e037883a 	mov	sp,fp
 80015c0:	df000017 	ldw	fp,0(sp)
 80015c4:	dec00104 	addi	sp,sp,4
 80015c8:	f800283a 	ret

080015cc <_ZL7setMACsPKh>:

static void setMACs (const uint8_t *mac) {
 80015cc:	defffd04 	addi	sp,sp,-12
 80015d0:	dfc00215 	stw	ra,8(sp)
 80015d4:	df000115 	stw	fp,4(sp)
 80015d8:	df000104 	addi	fp,sp,4
 80015dc:	e13fff15 	stw	r4,-4(fp)
    EtherCard::copyMac(gPB + ETH_DST_MAC, mac);
 80015e0:	e17fff17 	ldw	r5,-4(fp)
 80015e4:	01020034 	movhi	r4,2048
 80015e8:	211ac704 	addi	r4,r4,27420
 80015ec:	8003f3c0 	call	8003f3c <_ZN9EtherCard7copyMacEPhPKh>
    EtherCard::copyMac(gPB + ETH_SRC_MAC, EtherCard::mymac);
 80015f0:	00820034 	movhi	r2,2048
 80015f4:	109ac884 	addi	r2,r2,27426
 80015f8:	d1605644 	addi	r5,gp,-32423
 80015fc:	1009883a 	mov	r4,r2
 8001600:	8003f3c0 	call	8003f3c <_ZN9EtherCard7copyMacEPhPKh>
}
 8001604:	0001883a 	nop
 8001608:	e037883a 	mov	sp,fp
 800160c:	dfc00117 	ldw	ra,4(sp)
 8001610:	df000017 	ldw	fp,0(sp)
 8001614:	dec00204 	addi	sp,sp,8
 8001618:	f800283a 	ret

0800161c <_ZL12setMACandIPsPKhS0_>:

static void setMACandIPs (const uint8_t *mac, const uint8_t *dst) {
 800161c:	defffc04 	addi	sp,sp,-16
 8001620:	dfc00315 	stw	ra,12(sp)
 8001624:	df000215 	stw	fp,8(sp)
 8001628:	df000204 	addi	fp,sp,8
 800162c:	e13ffe15 	stw	r4,-8(fp)
 8001630:	e17fff15 	stw	r5,-4(fp)
    setMACs(mac);
 8001634:	e13ffe17 	ldw	r4,-8(fp)
 8001638:	80015cc0 	call	80015cc <_ZL7setMACsPKh>
    EtherCard::copyIp(gPB + IP_DST_P, dst);
 800163c:	00820034 	movhi	r2,2048
 8001640:	109ace84 	addi	r2,r2,27450
 8001644:	e17fff17 	ldw	r5,-4(fp)
 8001648:	1009883a 	mov	r4,r2
 800164c:	8003f7c0 	call	8003f7c <_ZN9EtherCard6copyIpEPhPKh>
    EtherCard::copyIp(gPB + IP_SRC_P, EtherCard::myip);
 8001650:	00820034 	movhi	r2,2048
 8001654:	109acd84 	addi	r2,r2,27446
 8001658:	d16057c4 	addi	r5,gp,-32417
 800165c:	1009883a 	mov	r4,r2
 8001660:	8003f7c0 	call	8003f7c <_ZN9EtherCard6copyIpEPhPKh>
}
 8001664:	0001883a 	nop
 8001668:	e037883a 	mov	sp,fp
 800166c:	dfc00117 	ldw	ra,4(sp)
 8001670:	df000017 	ldw	fp,0(sp)
 8001674:	dec00204 	addi	sp,sp,8
 8001678:	f800283a 	ret

0800167c <_ZL24check_ip_message_is_fromPKh>:

static uint8_t check_ip_message_is_from(const uint8_t *ip) {
 800167c:	defffd04 	addi	sp,sp,-12
 8001680:	dfc00215 	stw	ra,8(sp)
 8001684:	df000115 	stw	fp,4(sp)
 8001688:	df000104 	addi	fp,sp,4
 800168c:	e13fff15 	stw	r4,-4(fp)
    return memcmp(gPB + IP_SRC_P, ip, IP_LEN) == 0;
 8001690:	00820034 	movhi	r2,2048
 8001694:	109acd84 	addi	r2,r2,27446
 8001698:	01800104 	movi	r6,4
 800169c:	e17fff17 	ldw	r5,-4(fp)
 80016a0:	1009883a 	mov	r4,r2
 80016a4:	8004c040 	call	8004c04 <memcmp>
 80016a8:	1005003a 	cmpeq	r2,r2,zero
}
 80016ac:	e037883a 	mov	sp,fp
 80016b0:	dfc00117 	ldw	ra,4(sp)
 80016b4:	df000017 	ldw	fp,0(sp)
 80016b8:	dec00204 	addi	sp,sp,8
 80016bc:	f800283a 	ret

080016c0 <_ZL6is_lanPKhS0_>:

static bool is_lan(const uint8_t source[IP_LEN], const uint8_t destination[IP_LEN]) {
 80016c0:	defffc04 	addi	sp,sp,-16
 80016c4:	df000315 	stw	fp,12(sp)
 80016c8:	df000304 	addi	fp,sp,12
 80016cc:	e13ffe15 	stw	r4,-8(fp)
 80016d0:	e17fff15 	stw	r5,-4(fp)
    if(source[0] == 0 || destination[0] == 0) {
 80016d4:	e0bffe17 	ldw	r2,-8(fp)
 80016d8:	10800003 	ldbu	r2,0(r2)
 80016dc:	10803fcc 	andi	r2,r2,255
 80016e0:	10000426 	beq	r2,zero,80016f4 <_ZL6is_lanPKhS0_+0x34>
 80016e4:	e0bfff17 	ldw	r2,-4(fp)
 80016e8:	10800003 	ldbu	r2,0(r2)
 80016ec:	10803fcc 	andi	r2,r2,255
 80016f0:	1000021e 	bne	r2,zero,80016fc <_ZL6is_lanPKhS0_+0x3c>
        return false;
 80016f4:	0005883a 	mov	r2,zero
 80016f8:	00001c06 	br	800176c <_ZL6is_lanPKhS0_+0xac>
    }
    for(int i = 0; i < IP_LEN; i++)
 80016fc:	e03ffd15 	stw	zero,-12(fp)
 8001700:	e0bffd17 	ldw	r2,-12(fp)
 8001704:	10800108 	cmpgei	r2,r2,4
 8001708:	1000171e 	bne	r2,zero,8001768 <_ZL6is_lanPKhS0_+0xa8>
        if((source[i] & EtherCard::netmask[i]) != (destination[i] & EtherCard::netmask[i])) {
 800170c:	e0bffd17 	ldw	r2,-12(fp)
 8001710:	e0fffe17 	ldw	r3,-8(fp)
 8001714:	1885883a 	add	r2,r3,r2
 8001718:	10c00003 	ldbu	r3,0(r2)
 800171c:	e0bffd17 	ldw	r2,-12(fp)
 8001720:	e13fff17 	ldw	r4,-4(fp)
 8001724:	2085883a 	add	r2,r4,r2
 8001728:	10800003 	ldbu	r2,0(r2)
 800172c:	1884f03a 	xor	r2,r3,r2
 8001730:	1009883a 	mov	r4,r2
 8001734:	e0fffd17 	ldw	r3,-12(fp)
 8001738:	d0a058c4 	addi	r2,gp,-32413
 800173c:	1885883a 	add	r2,r3,r2
 8001740:	10800003 	ldbu	r2,0(r2)
 8001744:	2084703a 	and	r2,r4,r2
 8001748:	10803fcc 	andi	r2,r2,255
 800174c:	10000226 	beq	r2,zero,8001758 <_ZL6is_lanPKhS0_+0x98>
            return false;
 8001750:	0005883a 	mov	r2,zero
 8001754:	00000506 	br	800176c <_ZL6is_lanPKhS0_+0xac>

static bool is_lan(const uint8_t source[IP_LEN], const uint8_t destination[IP_LEN]) {
    if(source[0] == 0 || destination[0] == 0) {
        return false;
    }
    for(int i = 0; i < IP_LEN; i++)
 8001758:	e0bffd17 	ldw	r2,-12(fp)
 800175c:	10800044 	addi	r2,r2,1
 8001760:	e0bffd15 	stw	r2,-12(fp)
 8001764:	003fe606 	br	8001700 <__alt_data_end+0xfc001700>
        if((source[i] & EtherCard::netmask[i]) != (destination[i] & EtherCard::netmask[i])) {
            return false;
        }
    return true;
 8001768:	00800044 	movi	r2,1
}
 800176c:	e037883a 	mov	sp,fp
 8001770:	df000017 	ldw	fp,0(sp)
 8001774:	dec00104 	addi	sp,sp,4
 8001778:	f800283a 	ret

0800177c <_ZL25eth_type_is_arp_and_my_ipt>:

static uint8_t eth_type_is_arp_and_my_ip(uint16_t len) {
 800177c:	defffd04 	addi	sp,sp,-12
 8001780:	dfc00215 	stw	ra,8(sp)
 8001784:	df000115 	stw	fp,4(sp)
 8001788:	df000104 	addi	fp,sp,4
 800178c:	2005883a 	mov	r2,r4
 8001790:	e0bfff0d 	sth	r2,-4(fp)
    return len >= 41 && gPB[ETH_TYPE_H_P] == ETHTYPE_ARP_H_V &&
           gPB[ETH_TYPE_L_P] == ETHTYPE_ARP_L_V &&
 8001794:	e0bfff0b 	ldhu	r2,-4(fp)
 8001798:	10800a70 	cmpltui	r2,r2,41
 800179c:	1000151e 	bne	r2,zero,80017f4 <_ZL25eth_type_is_arp_and_my_ipt+0x78>
        }
    return true;
}

static uint8_t eth_type_is_arp_and_my_ip(uint16_t len) {
    return len >= 41 && gPB[ETH_TYPE_H_P] == ETHTYPE_ARP_H_V &&
 80017a0:	00820034 	movhi	r2,2048
 80017a4:	109ac704 	addi	r2,r2,27420
 80017a8:	10800303 	ldbu	r2,12(r2)
 80017ac:	10803fcc 	andi	r2,r2,255
 80017b0:	10800218 	cmpnei	r2,r2,8
 80017b4:	10000f1e 	bne	r2,zero,80017f4 <_ZL25eth_type_is_arp_and_my_ipt+0x78>
           gPB[ETH_TYPE_L_P] == ETHTYPE_ARP_L_V &&
 80017b8:	00820034 	movhi	r2,2048
 80017bc:	109ac704 	addi	r2,r2,27420
 80017c0:	10800343 	ldbu	r2,13(r2)
        }
    return true;
}

static uint8_t eth_type_is_arp_and_my_ip(uint16_t len) {
    return len >= 41 && gPB[ETH_TYPE_H_P] == ETHTYPE_ARP_H_V &&
 80017c4:	10803fcc 	andi	r2,r2,255
 80017c8:	10800198 	cmpnei	r2,r2,6
 80017cc:	1000091e 	bne	r2,zero,80017f4 <_ZL25eth_type_is_arp_and_my_ipt+0x78>
           gPB[ETH_TYPE_L_P] == ETHTYPE_ARP_L_V &&
           memcmp(gPB + ETH_ARP_DST_IP_P, EtherCard::myip, IP_LEN) == 0;
 80017d0:	00820034 	movhi	r2,2048
 80017d4:	109ad084 	addi	r2,r2,27458
 80017d8:	01800104 	movi	r6,4
 80017dc:	d16057c4 	addi	r5,gp,-32417
 80017e0:	1009883a 	mov	r4,r2
 80017e4:	8004c040 	call	8004c04 <memcmp>
    return true;
}

static uint8_t eth_type_is_arp_and_my_ip(uint16_t len) {
    return len >= 41 && gPB[ETH_TYPE_H_P] == ETHTYPE_ARP_H_V &&
           gPB[ETH_TYPE_L_P] == ETHTYPE_ARP_L_V &&
 80017e8:	1000021e 	bne	r2,zero,80017f4 <_ZL25eth_type_is_arp_and_my_ipt+0x78>
 80017ec:	00800044 	movi	r2,1
 80017f0:	00000106 	br	80017f8 <_ZL25eth_type_is_arp_and_my_ipt+0x7c>
 80017f4:	0005883a 	mov	r2,zero
           memcmp(gPB + ETH_ARP_DST_IP_P, EtherCard::myip, IP_LEN) == 0;
}
 80017f8:	e037883a 	mov	sp,fp
 80017fc:	dfc00117 	ldw	ra,4(sp)
 8001800:	df000017 	ldw	fp,0(sp)
 8001804:	dec00204 	addi	sp,sp,8
 8001808:	f800283a 	ret

0800180c <_ZL24eth_type_is_ip_and_my_ipt>:

static uint8_t eth_type_is_ip_and_my_ip(uint16_t len) {
 800180c:	defffd04 	addi	sp,sp,-12
 8001810:	dfc00215 	stw	ra,8(sp)
 8001814:	df000115 	stw	fp,4(sp)
 8001818:	df000104 	addi	fp,sp,4
 800181c:	2005883a 	mov	r2,r4
 8001820:	e0bfff0d 	sth	r2,-4(fp)
    return len >= 42 && gPB[ETH_TYPE_H_P] == ETHTYPE_IP_H_V &&
           gPB[ETH_TYPE_L_P] == ETHTYPE_IP_L_V &&
           gPB[IP_HEADER_LEN_VER_P] == 0x45 &&
 8001824:	e0bfff0b 	ldhu	r2,-4(fp)
 8001828:	10800ab0 	cmpltui	r2,r2,42
 800182c:	1000281e 	bne	r2,zero,80018d0 <_ZL24eth_type_is_ip_and_my_ipt+0xc4>
           gPB[ETH_TYPE_L_P] == ETHTYPE_ARP_L_V &&
           memcmp(gPB + ETH_ARP_DST_IP_P, EtherCard::myip, IP_LEN) == 0;
}

static uint8_t eth_type_is_ip_and_my_ip(uint16_t len) {
    return len >= 42 && gPB[ETH_TYPE_H_P] == ETHTYPE_IP_H_V &&
 8001830:	00820034 	movhi	r2,2048
 8001834:	109ac704 	addi	r2,r2,27420
 8001838:	10800303 	ldbu	r2,12(r2)
 800183c:	10803fcc 	andi	r2,r2,255
 8001840:	10800218 	cmpnei	r2,r2,8
 8001844:	1000221e 	bne	r2,zero,80018d0 <_ZL24eth_type_is_ip_and_my_ipt+0xc4>
           gPB[ETH_TYPE_L_P] == ETHTYPE_IP_L_V &&
 8001848:	00820034 	movhi	r2,2048
 800184c:	109ac704 	addi	r2,r2,27420
 8001850:	10800343 	ldbu	r2,13(r2)
           gPB[ETH_TYPE_L_P] == ETHTYPE_ARP_L_V &&
           memcmp(gPB + ETH_ARP_DST_IP_P, EtherCard::myip, IP_LEN) == 0;
}

static uint8_t eth_type_is_ip_and_my_ip(uint16_t len) {
    return len >= 42 && gPB[ETH_TYPE_H_P] == ETHTYPE_IP_H_V &&
 8001854:	10803fcc 	andi	r2,r2,255
 8001858:	10001d1e 	bne	r2,zero,80018d0 <_ZL24eth_type_is_ip_and_my_ipt+0xc4>
           gPB[ETH_TYPE_L_P] == ETHTYPE_IP_L_V &&
           gPB[IP_HEADER_LEN_VER_P] == 0x45 &&
 800185c:	00820034 	movhi	r2,2048
 8001860:	109ac704 	addi	r2,r2,27420
 8001864:	10800383 	ldbu	r2,14(r2)
           memcmp(gPB + ETH_ARP_DST_IP_P, EtherCard::myip, IP_LEN) == 0;
}

static uint8_t eth_type_is_ip_and_my_ip(uint16_t len) {
    return len >= 42 && gPB[ETH_TYPE_H_P] == ETHTYPE_IP_H_V &&
           gPB[ETH_TYPE_L_P] == ETHTYPE_IP_L_V &&
 8001868:	10803fcc 	andi	r2,r2,255
 800186c:	10801158 	cmpnei	r2,r2,69
 8001870:	1000171e 	bne	r2,zero,80018d0 <_ZL24eth_type_is_ip_and_my_ipt+0xc4>
           gPB[IP_HEADER_LEN_VER_P] == 0x45 &&
           (memcmp(gPB + IP_DST_P, EtherCard::myip, IP_LEN) == 0  //not my IP
 8001874:	00820034 	movhi	r2,2048
 8001878:	109ace84 	addi	r2,r2,27450
 800187c:	01800104 	movi	r6,4
 8001880:	d16057c4 	addi	r5,gp,-32417
 8001884:	1009883a 	mov	r4,r2
 8001888:	8004c040 	call	8004c04 <memcmp>
}

static uint8_t eth_type_is_ip_and_my_ip(uint16_t len) {
    return len >= 42 && gPB[ETH_TYPE_H_P] == ETHTYPE_IP_H_V &&
           gPB[ETH_TYPE_L_P] == ETHTYPE_IP_L_V &&
           gPB[IP_HEADER_LEN_VER_P] == 0x45 &&
 800188c:	10000e26 	beq	r2,zero,80018c8 <_ZL24eth_type_is_ip_and_my_ipt+0xbc>
           (memcmp(gPB + IP_DST_P, EtherCard::myip, IP_LEN) == 0  //not my IP
            || (memcmp(gPB + IP_DST_P, EtherCard::broadcastip, IP_LEN) == 0) //not subnet broadcast
 8001890:	00820034 	movhi	r2,2048
 8001894:	109ace84 	addi	r2,r2,27450
 8001898:	01800104 	movi	r6,4
 800189c:	d16059c4 	addi	r5,gp,-32409
 80018a0:	1009883a 	mov	r4,r2
 80018a4:	8004c040 	call	8004c04 <memcmp>
 80018a8:	10000726 	beq	r2,zero,80018c8 <_ZL24eth_type_is_ip_and_my_ipt+0xbc>
            || (memcmp(gPB + IP_DST_P, allOnes, IP_LEN) == 0)); //not global broadcasts
 80018ac:	00820034 	movhi	r2,2048
 80018b0:	109ace84 	addi	r2,r2,27450
 80018b4:	01800104 	movi	r6,4
 80018b8:	d16002c4 	addi	r5,gp,-32757
 80018bc:	1009883a 	mov	r4,r2
 80018c0:	8004c040 	call	8004c04 <memcmp>
 80018c4:	1000021e 	bne	r2,zero,80018d0 <_ZL24eth_type_is_ip_and_my_ipt+0xc4>
}

static uint8_t eth_type_is_ip_and_my_ip(uint16_t len) {
    return len >= 42 && gPB[ETH_TYPE_H_P] == ETHTYPE_IP_H_V &&
           gPB[ETH_TYPE_L_P] == ETHTYPE_IP_L_V &&
           gPB[IP_HEADER_LEN_VER_P] == 0x45 &&
 80018c8:	00800044 	movi	r2,1
 80018cc:	00000106 	br	80018d4 <_ZL24eth_type_is_ip_and_my_ipt+0xc8>
 80018d0:	0005883a 	mov	r2,zero
           (memcmp(gPB + IP_DST_P, EtherCard::myip, IP_LEN) == 0  //not my IP
            || (memcmp(gPB + IP_DST_P, EtherCard::broadcastip, IP_LEN) == 0) //not subnet broadcast
            || (memcmp(gPB + IP_DST_P, allOnes, IP_LEN) == 0)); //not global broadcasts
    //!@todo Handle multicast
}
 80018d4:	e037883a 	mov	sp,fp
 80018d8:	dfc00117 	ldw	ra,4(sp)
 80018dc:	df000017 	ldw	fp,0(sp)
 80018e0:	dec00204 	addi	sp,sp,8
 80018e4:	f800283a 	ret

080018e8 <_ZL20fill_ip_hdr_checksumv>:

static void fill_ip_hdr_checksum() {
 80018e8:	defffe04 	addi	sp,sp,-8
 80018ec:	dfc00115 	stw	ra,4(sp)
 80018f0:	df000015 	stw	fp,0(sp)
 80018f4:	d839883a 	mov	fp,sp
    gPB[IP_CHECKSUM_P] = 0;
 80018f8:	00820034 	movhi	r2,2048
 80018fc:	109ac704 	addi	r2,r2,27420
 8001900:	10000605 	stb	zero,24(r2)
    gPB[IP_CHECKSUM_P+1] = 0;
 8001904:	00820034 	movhi	r2,2048
 8001908:	109ac704 	addi	r2,r2,27420
 800190c:	10000645 	stb	zero,25(r2)
    gPB[IP_FLAGS_P] = 0x40; // don't fragment
 8001910:	00820034 	movhi	r2,2048
 8001914:	109ac704 	addi	r2,r2,27420
 8001918:	00c01004 	movi	r3,64
 800191c:	10c00505 	stb	r3,20(r2)
    gPB[IP_FLAGS_P+1] = 0;  // fragment offset
 8001920:	00820034 	movhi	r2,2048
 8001924:	109ac704 	addi	r2,r2,27420
 8001928:	10000545 	stb	zero,21(r2)
    gPB[IP_TTL_P] = 64; // ttl
 800192c:	00820034 	movhi	r2,2048
 8001930:	109ac704 	addi	r2,r2,27420
 8001934:	00c01004 	movi	r3,64
 8001938:	10c00585 	stb	r3,22(r2)
    fill_checksum(IP_CHECKSUM_P, IP_P, IP_HEADER_LEN,0);
 800193c:	000f883a 	mov	r7,zero
 8001940:	01800504 	movi	r6,20
 8001944:	01400384 	movi	r5,14
 8001948:	01000604 	movi	r4,24
 800194c:	80014480 	call	8001448 <_ZL13fill_checksumhhth>
}
 8001950:	0001883a 	nop
 8001954:	e037883a 	mov	sp,fp
 8001958:	dfc00117 	ldw	ra,4(sp)
 800195c:	df000017 	ldw	fp,0(sp)
 8001960:	dec00204 	addi	sp,sp,8
 8001964:	f800283a 	ret

08001968 <_ZL11make_eth_ipv>:

static void make_eth_ip() {
 8001968:	defffe04 	addi	sp,sp,-8
 800196c:	dfc00115 	stw	ra,4(sp)
 8001970:	df000015 	stw	fp,0(sp)
 8001974:	d839883a 	mov	fp,sp
    setMACs(gPB + ETH_SRC_MAC);
 8001978:	00820034 	movhi	r2,2048
 800197c:	109ac884 	addi	r2,r2,27426
 8001980:	1009883a 	mov	r4,r2
 8001984:	80015cc0 	call	80015cc <_ZL7setMACsPKh>
    EtherCard::copyIp(gPB + IP_DST_P, gPB + IP_SRC_P);
 8001988:	00820034 	movhi	r2,2048
 800198c:	109ace84 	addi	r2,r2,27450
 8001990:	00c20034 	movhi	r3,2048
 8001994:	18dacd84 	addi	r3,r3,27446
 8001998:	180b883a 	mov	r5,r3
 800199c:	1009883a 	mov	r4,r2
 80019a0:	8003f7c0 	call	8003f7c <_ZN9EtherCard6copyIpEPhPKh>
    EtherCard::copyIp(gPB + IP_SRC_P, EtherCard::myip);
 80019a4:	00820034 	movhi	r2,2048
 80019a8:	109acd84 	addi	r2,r2,27446
 80019ac:	d16057c4 	addi	r5,gp,-32417
 80019b0:	1009883a 	mov	r4,r2
 80019b4:	8003f7c0 	call	8003f7c <_ZN9EtherCard6copyIpEPhPKh>
    fill_ip_hdr_checksum();
 80019b8:	80018e80 	call	80018e8 <_ZL20fill_ip_hdr_checksumv>
}
 80019bc:	0001883a 	nop
 80019c0:	e037883a 	mov	sp,fp
 80019c4:	dfc00117 	ldw	ra,4(sp)
 80019c8:	df000017 	ldw	fp,0(sp)
 80019cc:	dec00204 	addi	sp,sp,8
 80019d0:	f800283a 	ret

080019d4 <_ZL8step_seqth>:

static void step_seq(uint16_t rel_ack_num,uint8_t cp_seq) {
 80019d4:	defffc04 	addi	sp,sp,-16
 80019d8:	df000315 	stw	fp,12(sp)
 80019dc:	df000304 	addi	fp,sp,12
 80019e0:	2007883a 	mov	r3,r4
 80019e4:	2805883a 	mov	r2,r5
 80019e8:	e0fffe0d 	sth	r3,-8(fp)
 80019ec:	e0bfff05 	stb	r2,-4(fp)
    uint8_t i;
    uint8_t tseq;
    i = 4;
 80019f0:	00800104 	movi	r2,4
 80019f4:	e0bffd05 	stb	r2,-12(fp)
    while(i>0) {
 80019f8:	e0bffd03 	ldbu	r2,-12(fp)
 80019fc:	10003026 	beq	r2,zero,8001ac0 <_ZL8step_seqth+0xec>
        rel_ack_num = gPB[TCP_SEQ_H_P+i-1]+rel_ack_num;
 8001a00:	e0bffd03 	ldbu	r2,-12(fp)
 8001a04:	10c00944 	addi	r3,r2,37
 8001a08:	00820034 	movhi	r2,2048
 8001a0c:	109ac704 	addi	r2,r2,27420
 8001a10:	10c5883a 	add	r2,r2,r3
 8001a14:	10800003 	ldbu	r2,0(r2)
 8001a18:	10c03fcc 	andi	r3,r2,255
 8001a1c:	e0bffe0b 	ldhu	r2,-8(fp)
 8001a20:	1885883a 	add	r2,r3,r2
 8001a24:	e0bffe0d 	sth	r2,-8(fp)
        tseq = gPB[TCP_SEQACK_H_P+i-1];
 8001a28:	e0bffd03 	ldbu	r2,-12(fp)
 8001a2c:	10c00a44 	addi	r3,r2,41
 8001a30:	00820034 	movhi	r2,2048
 8001a34:	109ac704 	addi	r2,r2,27420
 8001a38:	10c5883a 	add	r2,r2,r3
 8001a3c:	10800003 	ldbu	r2,0(r2)
 8001a40:	e0bffd45 	stb	r2,-11(fp)
        gPB[TCP_SEQACK_H_P+i-1] = rel_ack_num;
 8001a44:	e0bffd03 	ldbu	r2,-12(fp)
 8001a48:	10c00a44 	addi	r3,r2,41
 8001a4c:	e0bffe0b 	ldhu	r2,-8(fp)
 8001a50:	1009883a 	mov	r4,r2
 8001a54:	00820034 	movhi	r2,2048
 8001a58:	109ac704 	addi	r2,r2,27420
 8001a5c:	10c5883a 	add	r2,r2,r3
 8001a60:	11000005 	stb	r4,0(r2)
        if (cp_seq)
 8001a64:	e0bfff03 	ldbu	r2,-4(fp)
 8001a68:	10000826 	beq	r2,zero,8001a8c <_ZL8step_seqth+0xb8>
            gPB[TCP_SEQ_H_P+i-1] = tseq;
 8001a6c:	e0bffd03 	ldbu	r2,-12(fp)
 8001a70:	10c00944 	addi	r3,r2,37
 8001a74:	00820034 	movhi	r2,2048
 8001a78:	109ac704 	addi	r2,r2,27420
 8001a7c:	10c5883a 	add	r2,r2,r3
 8001a80:	e0fffd43 	ldbu	r3,-11(fp)
 8001a84:	10c00005 	stb	r3,0(r2)
 8001a88:	00000606 	br	8001aa4 <_ZL8step_seqth+0xd0>
        else
            gPB[TCP_SEQ_H_P+i-1] = 0; // some preset value
 8001a8c:	e0bffd03 	ldbu	r2,-12(fp)
 8001a90:	10c00944 	addi	r3,r2,37
 8001a94:	00820034 	movhi	r2,2048
 8001a98:	109ac704 	addi	r2,r2,27420
 8001a9c:	10c5883a 	add	r2,r2,r3
 8001aa0:	10000005 	stb	zero,0(r2)
        rel_ack_num = rel_ack_num>>8;
 8001aa4:	e0bffe0b 	ldhu	r2,-8(fp)
 8001aa8:	1005d23a 	srai	r2,r2,8
 8001aac:	e0bffe0d 	sth	r2,-8(fp)
        i--;
 8001ab0:	e0bffd03 	ldbu	r2,-12(fp)
 8001ab4:	10bfffc4 	addi	r2,r2,-1
 8001ab8:	e0bffd05 	stb	r2,-12(fp)

static void step_seq(uint16_t rel_ack_num,uint8_t cp_seq) {
    uint8_t i;
    uint8_t tseq;
    i = 4;
    while(i>0) {
 8001abc:	003fce06 	br	80019f8 <__alt_data_end+0xfc0019f8>
        else
            gPB[TCP_SEQ_H_P+i-1] = 0; // some preset value
        rel_ack_num = rel_ack_num>>8;
        i--;
    }
}
 8001ac0:	0001883a 	nop
 8001ac4:	e037883a 	mov	sp,fp
 8001ac8:	df000017 	ldw	fp,0(sp)
 8001acc:	dec00104 	addi	sp,sp,4
 8001ad0:	f800283a 	ret

08001ad4 <_ZL12make_tcpheadth>:

static void make_tcphead(uint16_t rel_ack_num,uint8_t cp_seq) {
 8001ad4:	defffb04 	addi	sp,sp,-20
 8001ad8:	dfc00415 	stw	ra,16(sp)
 8001adc:	df000315 	stw	fp,12(sp)
 8001ae0:	df000304 	addi	fp,sp,12
 8001ae4:	2007883a 	mov	r3,r4
 8001ae8:	2805883a 	mov	r2,r5
 8001aec:	e0fffe0d 	sth	r3,-8(fp)
 8001af0:	e0bfff05 	stb	r2,-4(fp)
    uint8_t i = gPB[TCP_DST_PORT_H_P];
 8001af4:	00820034 	movhi	r2,2048
 8001af8:	109ac704 	addi	r2,r2,27420
 8001afc:	10800903 	ldbu	r2,36(r2)
 8001b00:	e0bffd05 	stb	r2,-12(fp)
    gPB[TCP_DST_PORT_H_P] = gPB[TCP_SRC_PORT_H_P];
 8001b04:	00820034 	movhi	r2,2048
 8001b08:	109ac704 	addi	r2,r2,27420
 8001b0c:	10c00883 	ldbu	r3,34(r2)
 8001b10:	00820034 	movhi	r2,2048
 8001b14:	109ac704 	addi	r2,r2,27420
 8001b18:	10c00905 	stb	r3,36(r2)
    gPB[TCP_SRC_PORT_H_P] = i;
 8001b1c:	00820034 	movhi	r2,2048
 8001b20:	109ac704 	addi	r2,r2,27420
 8001b24:	e0fffd03 	ldbu	r3,-12(fp)
 8001b28:	10c00885 	stb	r3,34(r2)
    uint8_t j = gPB[TCP_DST_PORT_L_P];
 8001b2c:	00820034 	movhi	r2,2048
 8001b30:	109ac704 	addi	r2,r2,27420
 8001b34:	10800943 	ldbu	r2,37(r2)
 8001b38:	e0bffd45 	stb	r2,-11(fp)
    gPB[TCP_DST_PORT_L_P] = gPB[TCP_SRC_PORT_L_P];
 8001b3c:	00820034 	movhi	r2,2048
 8001b40:	109ac704 	addi	r2,r2,27420
 8001b44:	10c008c3 	ldbu	r3,35(r2)
 8001b48:	00820034 	movhi	r2,2048
 8001b4c:	109ac704 	addi	r2,r2,27420
 8001b50:	10c00945 	stb	r3,37(r2)
    gPB[TCP_SRC_PORT_L_P] = j;
 8001b54:	00820034 	movhi	r2,2048
 8001b58:	109ac704 	addi	r2,r2,27420
 8001b5c:	e0fffd43 	ldbu	r3,-11(fp)
 8001b60:	10c008c5 	stb	r3,35(r2)
    step_seq(rel_ack_num,cp_seq);
 8001b64:	e0bffe0b 	ldhu	r2,-8(fp)
 8001b68:	e0ffff03 	ldbu	r3,-4(fp)
 8001b6c:	180b883a 	mov	r5,r3
 8001b70:	1009883a 	mov	r4,r2
 8001b74:	80019d40 	call	80019d4 <_ZL8step_seqth>
    gPB[TCP_CHECKSUM_H_P] = 0;
 8001b78:	00820034 	movhi	r2,2048
 8001b7c:	109ac704 	addi	r2,r2,27420
 8001b80:	10000c85 	stb	zero,50(r2)
    gPB[TCP_CHECKSUM_L_P] = 0;
 8001b84:	00820034 	movhi	r2,2048
 8001b88:	109ac704 	addi	r2,r2,27420
 8001b8c:	10000cc5 	stb	zero,51(r2)
    gPB[TCP_HEADER_LEN_P] = 0x50;
 8001b90:	00820034 	movhi	r2,2048
 8001b94:	109ac704 	addi	r2,r2,27420
 8001b98:	00c01404 	movi	r3,80
 8001b9c:	10c00b85 	stb	r3,46(r2)
}
 8001ba0:	0001883a 	nop
 8001ba4:	e037883a 	mov	sp,fp
 8001ba8:	dfc00117 	ldw	ra,4(sp)
 8001bac:	df000017 	ldw	fp,0(sp)
 8001bb0:	dec00204 	addi	sp,sp,8
 8001bb4:	f800283a 	ret

08001bb8 <_ZL28make_arp_answer_from_requestv>:

static void make_arp_answer_from_request() {
 8001bb8:	defffe04 	addi	sp,sp,-8
 8001bbc:	dfc00115 	stw	ra,4(sp)
 8001bc0:	df000015 	stw	fp,0(sp)
 8001bc4:	d839883a 	mov	fp,sp
    setMACs(gPB + ETH_SRC_MAC);
 8001bc8:	00820034 	movhi	r2,2048
 8001bcc:	109ac884 	addi	r2,r2,27426
 8001bd0:	1009883a 	mov	r4,r2
 8001bd4:	80015cc0 	call	80015cc <_ZL7setMACsPKh>
    gPB[ETH_ARP_OPCODE_H_P] = ETH_ARP_OPCODE_REPLY_H_V;
 8001bd8:	00820034 	movhi	r2,2048
 8001bdc:	109ac704 	addi	r2,r2,27420
 8001be0:	10000505 	stb	zero,20(r2)
    gPB[ETH_ARP_OPCODE_L_P] = ETH_ARP_OPCODE_REPLY_L_V;
 8001be4:	00820034 	movhi	r2,2048
 8001be8:	109ac704 	addi	r2,r2,27420
 8001bec:	00c00084 	movi	r3,2
 8001bf0:	10c00545 	stb	r3,21(r2)
    EtherCard::copyMac(gPB + ETH_ARP_DST_MAC_P, gPB + ETH_ARP_SRC_MAC_P);
 8001bf4:	00820034 	movhi	r2,2048
 8001bf8:	109acf04 	addi	r2,r2,27452
 8001bfc:	00c20034 	movhi	r3,2048
 8001c00:	18dacc84 	addi	r3,r3,27442
 8001c04:	180b883a 	mov	r5,r3
 8001c08:	1009883a 	mov	r4,r2
 8001c0c:	8003f3c0 	call	8003f3c <_ZN9EtherCard7copyMacEPhPKh>
    EtherCard::copyMac(gPB + ETH_ARP_SRC_MAC_P, EtherCard::mymac);
 8001c10:	00820034 	movhi	r2,2048
 8001c14:	109acc84 	addi	r2,r2,27442
 8001c18:	d1605644 	addi	r5,gp,-32423
 8001c1c:	1009883a 	mov	r4,r2
 8001c20:	8003f3c0 	call	8003f3c <_ZN9EtherCard7copyMacEPhPKh>
    EtherCard::copyIp(gPB + ETH_ARP_DST_IP_P, gPB + ETH_ARP_SRC_IP_P);
 8001c24:	00820034 	movhi	r2,2048
 8001c28:	109ad084 	addi	r2,r2,27458
 8001c2c:	00c20034 	movhi	r3,2048
 8001c30:	18dace04 	addi	r3,r3,27448
 8001c34:	180b883a 	mov	r5,r3
 8001c38:	1009883a 	mov	r4,r2
 8001c3c:	8003f7c0 	call	8003f7c <_ZN9EtherCard6copyIpEPhPKh>
    EtherCard::copyIp(gPB + ETH_ARP_SRC_IP_P, EtherCard::myip);
 8001c40:	00820034 	movhi	r2,2048
 8001c44:	109ace04 	addi	r2,r2,27448
 8001c48:	d16057c4 	addi	r5,gp,-32417
 8001c4c:	1009883a 	mov	r4,r2
 8001c50:	8003f7c0 	call	8003f7c <_ZN9EtherCard6copyIpEPhPKh>
    EtherCard::packetSend(42);
 8001c54:	01000a84 	movi	r4,42
 8001c58:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 8001c5c:	0001883a 	nop
 8001c60:	e037883a 	mov	sp,fp
 8001c64:	dfc00117 	ldw	ra,4(sp)
 8001c68:	df000017 	ldw	fp,0(sp)
 8001c6c:	dec00204 	addi	sp,sp,8
 8001c70:	f800283a 	ret

08001c74 <_ZL28make_echo_reply_from_requestt>:

static void make_echo_reply_from_request(uint16_t len) {
 8001c74:	defffd04 	addi	sp,sp,-12
 8001c78:	dfc00215 	stw	ra,8(sp)
 8001c7c:	df000115 	stw	fp,4(sp)
 8001c80:	df000104 	addi	fp,sp,4
 8001c84:	2005883a 	mov	r2,r4
 8001c88:	e0bfff0d 	sth	r2,-4(fp)
    make_eth_ip();
 8001c8c:	80019680 	call	8001968 <_ZL11make_eth_ipv>
    gPB[ICMP_TYPE_P] = ICMP_TYPE_ECHOREPLY_V;
 8001c90:	00820034 	movhi	r2,2048
 8001c94:	109ac704 	addi	r2,r2,27420
 8001c98:	10000885 	stb	zero,34(r2)
    if (gPB[ICMP_CHECKSUM_P] > (0xFF-0x08))
 8001c9c:	00820034 	movhi	r2,2048
 8001ca0:	109ac704 	addi	r2,r2,27420
 8001ca4:	10800903 	ldbu	r2,36(r2)
 8001ca8:	10803fcc 	andi	r2,r2,255
 8001cac:	10803e30 	cmpltui	r2,r2,248
 8001cb0:	1000081e 	bne	r2,zero,8001cd4 <_ZL28make_echo_reply_from_requestt+0x60>
        gPB[ICMP_CHECKSUM_P+1]++;
 8001cb4:	00820034 	movhi	r2,2048
 8001cb8:	109ac704 	addi	r2,r2,27420
 8001cbc:	10800943 	ldbu	r2,37(r2)
 8001cc0:	10800044 	addi	r2,r2,1
 8001cc4:	1007883a 	mov	r3,r2
 8001cc8:	00820034 	movhi	r2,2048
 8001ccc:	109ac704 	addi	r2,r2,27420
 8001cd0:	10c00945 	stb	r3,37(r2)
    gPB[ICMP_CHECKSUM_P] += 0x08;
 8001cd4:	00820034 	movhi	r2,2048
 8001cd8:	109ac704 	addi	r2,r2,27420
 8001cdc:	10800903 	ldbu	r2,36(r2)
 8001ce0:	10800204 	addi	r2,r2,8
 8001ce4:	1007883a 	mov	r3,r2
 8001ce8:	00820034 	movhi	r2,2048
 8001cec:	109ac704 	addi	r2,r2,27420
 8001cf0:	10c00905 	stb	r3,36(r2)
    EtherCard::packetSend(len);
 8001cf4:	e0bfff0b 	ldhu	r2,-4(fp)
 8001cf8:	1009883a 	mov	r4,r2
 8001cfc:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 8001d00:	0001883a 	nop
 8001d04:	e037883a 	mov	sp,fp
 8001d08:	dfc00117 	ldw	ra,4(sp)
 8001d0c:	df000017 	ldw	fp,0(sp)
 8001d10:	dec00204 	addi	sp,sp,8
 8001d14:	f800283a 	ret

08001d18 <_ZN9EtherCard12makeUdpReplyEPKcht>:

void EtherCard::makeUdpReply (const char *data,uint8_t datalen,uint16_t port) {
 8001d18:	defffb04 	addi	sp,sp,-20
 8001d1c:	dfc00415 	stw	ra,16(sp)
 8001d20:	df000315 	stw	fp,12(sp)
 8001d24:	df000304 	addi	fp,sp,12
 8001d28:	e13ffd15 	stw	r4,-12(fp)
 8001d2c:	2807883a 	mov	r3,r5
 8001d30:	3005883a 	mov	r2,r6
 8001d34:	e0fffe05 	stb	r3,-8(fp)
 8001d38:	e0bfff0d 	sth	r2,-4(fp)
    if (datalen>220)
 8001d3c:	e0bffe03 	ldbu	r2,-8(fp)
 8001d40:	10803770 	cmpltui	r2,r2,221
 8001d44:	1000021e 	bne	r2,zero,8001d50 <_ZN9EtherCard12makeUdpReplyEPKcht+0x38>
        datalen = 220;
 8001d48:	00bff704 	movi	r2,-36
 8001d4c:	e0bffe05 	stb	r2,-8(fp)
    gPB[IP_TOTLEN_H_P] = (IP_HEADER_LEN+UDP_HEADER_LEN+datalen) >>8;
 8001d50:	e0bffe03 	ldbu	r2,-8(fp)
 8001d54:	10800704 	addi	r2,r2,28
 8001d58:	1005d23a 	srai	r2,r2,8
 8001d5c:	1007883a 	mov	r3,r2
 8001d60:	00820034 	movhi	r2,2048
 8001d64:	109ac704 	addi	r2,r2,27420
 8001d68:	10c00405 	stb	r3,16(r2)
    gPB[IP_TOTLEN_L_P] = IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
 8001d6c:	e0bffe03 	ldbu	r2,-8(fp)
 8001d70:	10800704 	addi	r2,r2,28
 8001d74:	1007883a 	mov	r3,r2
 8001d78:	00820034 	movhi	r2,2048
 8001d7c:	109ac704 	addi	r2,r2,27420
 8001d80:	10c00445 	stb	r3,17(r2)
    make_eth_ip();
 8001d84:	80019680 	call	8001968 <_ZL11make_eth_ipv>
    gPB[UDP_DST_PORT_H_P] = gPB[UDP_SRC_PORT_H_P];
 8001d88:	00820034 	movhi	r2,2048
 8001d8c:	109ac704 	addi	r2,r2,27420
 8001d90:	10c00883 	ldbu	r3,34(r2)
 8001d94:	00820034 	movhi	r2,2048
 8001d98:	109ac704 	addi	r2,r2,27420
 8001d9c:	10c00905 	stb	r3,36(r2)
    gPB[UDP_DST_PORT_L_P] = gPB[UDP_SRC_PORT_L_P];
 8001da0:	00820034 	movhi	r2,2048
 8001da4:	109ac704 	addi	r2,r2,27420
 8001da8:	10c008c3 	ldbu	r3,35(r2)
 8001dac:	00820034 	movhi	r2,2048
 8001db0:	109ac704 	addi	r2,r2,27420
 8001db4:	10c00945 	stb	r3,37(r2)
    gPB[UDP_SRC_PORT_H_P] = port>>8;
 8001db8:	e0bfff0b 	ldhu	r2,-4(fp)
 8001dbc:	1005d23a 	srai	r2,r2,8
 8001dc0:	1007883a 	mov	r3,r2
 8001dc4:	00820034 	movhi	r2,2048
 8001dc8:	109ac704 	addi	r2,r2,27420
 8001dcc:	10c00885 	stb	r3,34(r2)
    gPB[UDP_SRC_PORT_L_P] = port;
 8001dd0:	e0bfff0b 	ldhu	r2,-4(fp)
 8001dd4:	1007883a 	mov	r3,r2
 8001dd8:	00820034 	movhi	r2,2048
 8001ddc:	109ac704 	addi	r2,r2,27420
 8001de0:	10c008c5 	stb	r3,35(r2)
    gPB[UDP_LEN_H_P] = (UDP_HEADER_LEN+datalen) >> 8;
 8001de4:	e0bffe03 	ldbu	r2,-8(fp)
 8001de8:	10800204 	addi	r2,r2,8
 8001dec:	1005d23a 	srai	r2,r2,8
 8001df0:	1007883a 	mov	r3,r2
 8001df4:	00820034 	movhi	r2,2048
 8001df8:	109ac704 	addi	r2,r2,27420
 8001dfc:	10c00985 	stb	r3,38(r2)
    gPB[UDP_LEN_L_P] = UDP_HEADER_LEN+datalen;
 8001e00:	e0bffe03 	ldbu	r2,-8(fp)
 8001e04:	10800204 	addi	r2,r2,8
 8001e08:	1007883a 	mov	r3,r2
 8001e0c:	00820034 	movhi	r2,2048
 8001e10:	109ac704 	addi	r2,r2,27420
 8001e14:	10c009c5 	stb	r3,39(r2)
    gPB[UDP_CHECKSUM_H_P] = 0;
 8001e18:	00820034 	movhi	r2,2048
 8001e1c:	109ac704 	addi	r2,r2,27420
 8001e20:	10000a05 	stb	zero,40(r2)
    gPB[UDP_CHECKSUM_L_P] = 0;
 8001e24:	00820034 	movhi	r2,2048
 8001e28:	109ac704 	addi	r2,r2,27420
 8001e2c:	10000a45 	stb	zero,41(r2)
    memcpy(gPB + UDP_DATA_P, data, datalen);
 8001e30:	00820034 	movhi	r2,2048
 8001e34:	109ad184 	addi	r2,r2,27462
 8001e38:	e0fffe03 	ldbu	r3,-8(fp)
 8001e3c:	180d883a 	mov	r6,r3
 8001e40:	e17ffd17 	ldw	r5,-12(fp)
 8001e44:	1009883a 	mov	r4,r2
 8001e48:	8004c340 	call	8004c34 <memcpy>
    fill_checksum(UDP_CHECKSUM_H_P, IP_SRC_P, 16 + datalen,1);
 8001e4c:	e0bffe03 	ldbu	r2,-8(fp)
 8001e50:	10800404 	addi	r2,r2,16
 8001e54:	10bfffcc 	andi	r2,r2,65535
 8001e58:	01c00044 	movi	r7,1
 8001e5c:	100d883a 	mov	r6,r2
 8001e60:	01400684 	movi	r5,26
 8001e64:	01000a04 	movi	r4,40
 8001e68:	80014480 	call	8001448 <_ZL13fill_checksumhhth>
    packetSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen);
 8001e6c:	e0bffe03 	ldbu	r2,-8(fp)
 8001e70:	10800a84 	addi	r2,r2,42
 8001e74:	10bfffcc 	andi	r2,r2,65535
 8001e78:	1009883a 	mov	r4,r2
 8001e7c:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 8001e80:	0001883a 	nop
 8001e84:	e037883a 	mov	sp,fp
 8001e88:	dfc00117 	ldw	ra,4(sp)
 8001e8c:	df000017 	ldw	fp,0(sp)
 8001e90:	dec00204 	addi	sp,sp,8
 8001e94:	f800283a 	ret

08001e98 <_ZL24make_tcp_synack_from_synv>:

static void make_tcp_synack_from_syn() {
 8001e98:	defffe04 	addi	sp,sp,-8
 8001e9c:	dfc00115 	stw	ra,4(sp)
 8001ea0:	df000015 	stw	fp,0(sp)
 8001ea4:	d839883a 	mov	fp,sp
    gPB[IP_TOTLEN_H_P] = 0;
 8001ea8:	00820034 	movhi	r2,2048
 8001eac:	109ac704 	addi	r2,r2,27420
 8001eb0:	10000405 	stb	zero,16(r2)
    gPB[IP_TOTLEN_L_P] = IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4;
 8001eb4:	00820034 	movhi	r2,2048
 8001eb8:	109ac704 	addi	r2,r2,27420
 8001ebc:	00c00b04 	movi	r3,44
 8001ec0:	10c00445 	stb	r3,17(r2)
    make_eth_ip();
 8001ec4:	80019680 	call	8001968 <_ZL11make_eth_ipv>
    gPB[TCP_FLAGS_P] = TCP_FLAGS_SYNACK_V;
 8001ec8:	00820034 	movhi	r2,2048
 8001ecc:	109ac704 	addi	r2,r2,27420
 8001ed0:	00c00484 	movi	r3,18
 8001ed4:	10c00bc5 	stb	r3,47(r2)
    make_tcphead(1,0);
 8001ed8:	000b883a 	mov	r5,zero
 8001edc:	01000044 	movi	r4,1
 8001ee0:	8001ad40 	call	8001ad4 <_ZL12make_tcpheadth>
    gPB[TCP_SEQ_H_P+0] = 0;
 8001ee4:	00820034 	movhi	r2,2048
 8001ee8:	109ac704 	addi	r2,r2,27420
 8001eec:	10000985 	stb	zero,38(r2)
    gPB[TCP_SEQ_H_P+1] = 0;
 8001ef0:	00820034 	movhi	r2,2048
 8001ef4:	109ac704 	addi	r2,r2,27420
 8001ef8:	100009c5 	stb	zero,39(r2)
    gPB[TCP_SEQ_H_P+2] = seqnum;
 8001efc:	d0e00243 	ldbu	r3,-32759(gp)
 8001f00:	00820034 	movhi	r2,2048
 8001f04:	109ac704 	addi	r2,r2,27420
 8001f08:	10c00a05 	stb	r3,40(r2)
    gPB[TCP_SEQ_H_P+3] = 0;
 8001f0c:	00820034 	movhi	r2,2048
 8001f10:	109ac704 	addi	r2,r2,27420
 8001f14:	10000a45 	stb	zero,41(r2)
    seqnum += 3;
 8001f18:	d0a00243 	ldbu	r2,-32759(gp)
 8001f1c:	108000c4 	addi	r2,r2,3
 8001f20:	d0a00245 	stb	r2,-32759(gp)
    gPB[TCP_OPTIONS_P] = 2;
 8001f24:	00820034 	movhi	r2,2048
 8001f28:	109ac704 	addi	r2,r2,27420
 8001f2c:	00c00084 	movi	r3,2
 8001f30:	10c00d85 	stb	r3,54(r2)
    gPB[TCP_OPTIONS_P+1] = 4;
 8001f34:	00820034 	movhi	r2,2048
 8001f38:	109ac704 	addi	r2,r2,27420
 8001f3c:	00c00104 	movi	r3,4
 8001f40:	10c00dc5 	stb	r3,55(r2)
    gPB[TCP_OPTIONS_P+2] = 0x05;
 8001f44:	00820034 	movhi	r2,2048
 8001f48:	109ac704 	addi	r2,r2,27420
 8001f4c:	00c00144 	movi	r3,5
 8001f50:	10c00e05 	stb	r3,56(r2)
    gPB[TCP_OPTIONS_P+3] = 0x0;
 8001f54:	00820034 	movhi	r2,2048
 8001f58:	109ac704 	addi	r2,r2,27420
 8001f5c:	10000e45 	stb	zero,57(r2)
    gPB[TCP_HEADER_LEN_P] = 0x60;
 8001f60:	00820034 	movhi	r2,2048
 8001f64:	109ac704 	addi	r2,r2,27420
 8001f68:	00c01804 	movi	r3,96
 8001f6c:	10c00b85 	stb	r3,46(r2)
    gPB[TCP_WIN_SIZE] = 0x5; // 1400=0x578
 8001f70:	00820034 	movhi	r2,2048
 8001f74:	109ac704 	addi	r2,r2,27420
 8001f78:	00c00144 	movi	r3,5
 8001f7c:	10c00c05 	stb	r3,48(r2)
    gPB[TCP_WIN_SIZE+1] = 0x78;
 8001f80:	00820034 	movhi	r2,2048
 8001f84:	109ac704 	addi	r2,r2,27420
 8001f88:	00c01e04 	movi	r3,120
 8001f8c:	10c00c45 	stb	r3,49(r2)
    fill_checksum(TCP_CHECKSUM_H_P, IP_SRC_P, 8+TCP_HEADER_LEN_PLAIN+4,2);
 8001f90:	01c00084 	movi	r7,2
 8001f94:	01800804 	movi	r6,32
 8001f98:	01400684 	movi	r5,26
 8001f9c:	01000c84 	movi	r4,50
 8001fa0:	80014480 	call	8001448 <_ZL13fill_checksumhhth>
    EtherCard::packetSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4+ETH_HEADER_LEN);
 8001fa4:	01000e84 	movi	r4,58
 8001fa8:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 8001fac:	0001883a 	nop
 8001fb0:	e037883a 	mov	sp,fp
 8001fb4:	dfc00117 	ldw	ra,4(sp)
 8001fb8:	df000017 	ldw	fp,0(sp)
 8001fbc:	dec00204 	addi	sp,sp,8
 8001fc0:	f800283a 	ret

08001fc4 <_ZN9EtherCard19getTcpPayloadLengthEv>:

uint16_t EtherCard::getTcpPayloadLength() {
 8001fc4:	defffe04 	addi	sp,sp,-8
 8001fc8:	df000115 	stw	fp,4(sp)
 8001fcc:	df000104 	addi	fp,sp,4
    int16_t i = (((int16_t)gPB[IP_TOTLEN_H_P])<<8)|gPB[IP_TOTLEN_L_P];
 8001fd0:	00820034 	movhi	r2,2048
 8001fd4:	109ac704 	addi	r2,r2,27420
 8001fd8:	10800403 	ldbu	r2,16(r2)
 8001fdc:	10803fcc 	andi	r2,r2,255
 8001fe0:	1004923a 	slli	r2,r2,8
 8001fe4:	1007883a 	mov	r3,r2
 8001fe8:	00820034 	movhi	r2,2048
 8001fec:	109ac704 	addi	r2,r2,27420
 8001ff0:	10800443 	ldbu	r2,17(r2)
 8001ff4:	10803fcc 	andi	r2,r2,255
 8001ff8:	1884b03a 	or	r2,r3,r2
 8001ffc:	e0bfff0d 	sth	r2,-4(fp)
    i -= IP_HEADER_LEN;
 8002000:	e0bfff0b 	ldhu	r2,-4(fp)
 8002004:	10bffb04 	addi	r2,r2,-20
 8002008:	e0bfff0d 	sth	r2,-4(fp)
    i -= (gPB[TCP_HEADER_LEN_P]>>4)*4; // generate len in bytes;
 800200c:	e0ffff0b 	ldhu	r3,-4(fp)
 8002010:	00820034 	movhi	r2,2048
 8002014:	109ac704 	addi	r2,r2,27420
 8002018:	10800b83 	ldbu	r2,46(r2)
 800201c:	10803fcc 	andi	r2,r2,255
 8002020:	1005d13a 	srai	r2,r2,4
 8002024:	1085883a 	add	r2,r2,r2
 8002028:	1085883a 	add	r2,r2,r2
 800202c:	1885c83a 	sub	r2,r3,r2
 8002030:	e0bfff0d 	sth	r2,-4(fp)
    if (i<=0)
 8002034:	e0bfff0f 	ldh	r2,-4(fp)
 8002038:	00800116 	blt	zero,r2,8002040 <_ZN9EtherCard19getTcpPayloadLengthEv+0x7c>
        i = 0;
 800203c:	e03fff0d 	sth	zero,-4(fp)
    return (uint16_t)i;
 8002040:	e0bfff0b 	ldhu	r2,-4(fp)
}
 8002044:	e037883a 	mov	sp,fp
 8002048:	df000017 	ldw	fp,0(sp)
 800204c:	dec00104 	addi	sp,sp,4
 8002050:	f800283a 	ret

08002054 <_ZL21make_tcp_ack_from_anysh>:

static void make_tcp_ack_from_any(int16_t datlentoack,uint8_t addflags) {
 8002054:	defffb04 	addi	sp,sp,-20
 8002058:	dfc00415 	stw	ra,16(sp)
 800205c:	df000315 	stw	fp,12(sp)
 8002060:	df000304 	addi	fp,sp,12
 8002064:	2007883a 	mov	r3,r4
 8002068:	2805883a 	mov	r2,r5
 800206c:	e0fffe0d 	sth	r3,-8(fp)
 8002070:	e0bfff05 	stb	r2,-4(fp)
    gPB[TCP_FLAGS_P] = TCP_FLAGS_ACK_V|addflags;
 8002074:	e0bfff03 	ldbu	r2,-4(fp)
 8002078:	10800414 	ori	r2,r2,16
 800207c:	1007883a 	mov	r3,r2
 8002080:	00820034 	movhi	r2,2048
 8002084:	109ac704 	addi	r2,r2,27420
 8002088:	10c00bc5 	stb	r3,47(r2)
    if (addflags!=TCP_FLAGS_RST_V && datlentoack==0)
 800208c:	e0bfff03 	ldbu	r2,-4(fp)
 8002090:	10800120 	cmpeqi	r2,r2,4
 8002094:	1000041e 	bne	r2,zero,80020a8 <_ZL21make_tcp_ack_from_anysh+0x54>
 8002098:	e0bffe0f 	ldh	r2,-8(fp)
 800209c:	1000021e 	bne	r2,zero,80020a8 <_ZL21make_tcp_ack_from_anysh+0x54>
        datlentoack = 1;
 80020a0:	00800044 	movi	r2,1
 80020a4:	e0bffe0d 	sth	r2,-8(fp)
    make_tcphead(datlentoack,1); // no options
 80020a8:	e0bffe0b 	ldhu	r2,-8(fp)
 80020ac:	10bfffcc 	andi	r2,r2,65535
 80020b0:	01400044 	movi	r5,1
 80020b4:	1009883a 	mov	r4,r2
 80020b8:	8001ad40 	call	8001ad4 <_ZL12make_tcpheadth>
    uint16_t j = IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN;
 80020bc:	00800a04 	movi	r2,40
 80020c0:	e0bffd0d 	sth	r2,-12(fp)
    gPB[IP_TOTLEN_H_P] = j>>8;
 80020c4:	e0bffd0b 	ldhu	r2,-12(fp)
 80020c8:	1005d23a 	srai	r2,r2,8
 80020cc:	1007883a 	mov	r3,r2
 80020d0:	00820034 	movhi	r2,2048
 80020d4:	109ac704 	addi	r2,r2,27420
 80020d8:	10c00405 	stb	r3,16(r2)
    gPB[IP_TOTLEN_L_P] = j;
 80020dc:	e0bffd0b 	ldhu	r2,-12(fp)
 80020e0:	1007883a 	mov	r3,r2
 80020e4:	00820034 	movhi	r2,2048
 80020e8:	109ac704 	addi	r2,r2,27420
 80020ec:	10c00445 	stb	r3,17(r2)
    make_eth_ip();
 80020f0:	80019680 	call	8001968 <_ZL11make_eth_ipv>
    gPB[TCP_WIN_SIZE] = 0x4; // 1024=0x400, 1280=0x500 2048=0x800 768=0x300
 80020f4:	00820034 	movhi	r2,2048
 80020f8:	109ac704 	addi	r2,r2,27420
 80020fc:	00c00104 	movi	r3,4
 8002100:	10c00c05 	stb	r3,48(r2)
    gPB[TCP_WIN_SIZE+1] = 0;
 8002104:	00820034 	movhi	r2,2048
 8002108:	109ac704 	addi	r2,r2,27420
 800210c:	10000c45 	stb	zero,49(r2)
    fill_checksum(TCP_CHECKSUM_H_P, IP_SRC_P, 8+TCP_HEADER_LEN_PLAIN,2);
 8002110:	01c00084 	movi	r7,2
 8002114:	01800704 	movi	r6,28
 8002118:	01400684 	movi	r5,26
 800211c:	01000c84 	movi	r4,50
 8002120:	80014480 	call	8001448 <_ZL13fill_checksumhhth>
    EtherCard::packetSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN);
 8002124:	01000d84 	movi	r4,54
 8002128:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 800212c:	0001883a 	nop
 8002130:	e037883a 	mov	sp,fp
 8002134:	dfc00117 	ldw	ra,4(sp)
 8002138:	df000017 	ldw	fp,0(sp)
 800213c:	dec00204 	addi	sp,sp,8
 8002140:	f800283a 	ret

08002144 <_ZL30make_tcp_ack_with_data_noflagst>:

static void make_tcp_ack_with_data_noflags(uint16_t dlen) {
 8002144:	defffc04 	addi	sp,sp,-16
 8002148:	dfc00315 	stw	ra,12(sp)
 800214c:	df000215 	stw	fp,8(sp)
 8002150:	df000204 	addi	fp,sp,8
 8002154:	2005883a 	mov	r2,r4
 8002158:	e0bfff0d 	sth	r2,-4(fp)
    uint16_t j = IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen;
 800215c:	e0bfff0b 	ldhu	r2,-4(fp)
 8002160:	10800a04 	addi	r2,r2,40
 8002164:	e0bffe0d 	sth	r2,-8(fp)
    gPB[IP_TOTLEN_H_P] = j>>8;
 8002168:	e0bffe0b 	ldhu	r2,-8(fp)
 800216c:	1005d23a 	srai	r2,r2,8
 8002170:	1007883a 	mov	r3,r2
 8002174:	00820034 	movhi	r2,2048
 8002178:	109ac704 	addi	r2,r2,27420
 800217c:	10c00405 	stb	r3,16(r2)
    gPB[IP_TOTLEN_L_P] = j;
 8002180:	e0bffe0b 	ldhu	r2,-8(fp)
 8002184:	1007883a 	mov	r3,r2
 8002188:	00820034 	movhi	r2,2048
 800218c:	109ac704 	addi	r2,r2,27420
 8002190:	10c00445 	stb	r3,17(r2)
    fill_ip_hdr_checksum();
 8002194:	80018e80 	call	80018e8 <_ZL20fill_ip_hdr_checksumv>
    gPB[TCP_CHECKSUM_H_P] = 0;
 8002198:	00820034 	movhi	r2,2048
 800219c:	109ac704 	addi	r2,r2,27420
 80021a0:	10000c85 	stb	zero,50(r2)
    gPB[TCP_CHECKSUM_L_P] = 0;
 80021a4:	00820034 	movhi	r2,2048
 80021a8:	109ac704 	addi	r2,r2,27420
 80021ac:	10000cc5 	stb	zero,51(r2)
    fill_checksum(TCP_CHECKSUM_H_P, IP_SRC_P, 8+TCP_HEADER_LEN_PLAIN+dlen,2);
 80021b0:	e0bfff0b 	ldhu	r2,-4(fp)
 80021b4:	10800704 	addi	r2,r2,28
 80021b8:	10bfffcc 	andi	r2,r2,65535
 80021bc:	01c00084 	movi	r7,2
 80021c0:	100d883a 	mov	r6,r2
 80021c4:	01400684 	movi	r5,26
 80021c8:	01000c84 	movi	r4,50
 80021cc:	80014480 	call	8001448 <_ZL13fill_checksumhhth>
    EtherCard::packetSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN);
 80021d0:	e0bfff0b 	ldhu	r2,-4(fp)
 80021d4:	10800d84 	addi	r2,r2,54
 80021d8:	10bfffcc 	andi	r2,r2,65535
 80021dc:	1009883a 	mov	r4,r2
 80021e0:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 80021e4:	0001883a 	nop
 80021e8:	e037883a 	mov	sp,fp
 80021ec:	dfc00117 	ldw	ra,4(sp)
 80021f0:	df000017 	ldw	fp,0(sp)
 80021f4:	dec00204 	addi	sp,sp,8
 80021f8:	f800283a 	ret

080021fc <_ZN9EtherCard15httpServerReplyEt>:

void EtherCard::httpServerReply (uint16_t dlen) {
 80021fc:	defffd04 	addi	sp,sp,-12
 8002200:	dfc00215 	stw	ra,8(sp)
 8002204:	df000115 	stw	fp,4(sp)
 8002208:	df000104 	addi	fp,sp,4
 800220c:	2005883a 	mov	r2,r4
 8002210:	e0bfff0d 	sth	r2,-4(fp)
    make_tcp_ack_from_any(info_data_len,0); // send ack for http get
 8002214:	d0a0728b 	ldhu	r2,-32310(gp)
 8002218:	10bfffcc 	andi	r2,r2,65535
 800221c:	10a0001c 	xori	r2,r2,32768
 8002220:	10a00004 	addi	r2,r2,-32768
 8002224:	000b883a 	mov	r5,zero
 8002228:	1009883a 	mov	r4,r2
 800222c:	80020540 	call	8002054 <_ZL21make_tcp_ack_from_anysh>
    gPB[TCP_FLAGS_P] = TCP_FLAGS_ACK_V|TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V;
 8002230:	00820034 	movhi	r2,2048
 8002234:	109ac704 	addi	r2,r2,27420
 8002238:	00c00644 	movi	r3,25
 800223c:	10c00bc5 	stb	r3,47(r2)
    make_tcp_ack_with_data_noflags(dlen); // send data
 8002240:	e0bfff0b 	ldhu	r2,-4(fp)
 8002244:	1009883a 	mov	r4,r2
 8002248:	80021440 	call	8002144 <_ZL30make_tcp_ack_with_data_noflagst>
}
 800224c:	0001883a 	nop
 8002250:	e037883a 	mov	sp,fp
 8002254:	dfc00117 	ldw	ra,4(sp)
 8002258:	df000017 	ldw	fp,0(sp)
 800225c:	dec00204 	addi	sp,sp,8
 8002260:	f800283a 	ret

08002264 <_ZL16getBigEndianLongh>:

static uint32_t getBigEndianLong(byte offs) { //get the sequence number of packets after an ack from GET
 8002264:	defffe04 	addi	sp,sp,-8
 8002268:	df000115 	stw	fp,4(sp)
 800226c:	df000104 	addi	fp,sp,4
 8002270:	2005883a 	mov	r2,r4
 8002274:	e0bfff05 	stb	r2,-4(fp)
    return (((unsigned long)gPB[offs]*256+gPB[offs+1])*256+gPB[offs+2])*256+gPB[offs+3];
 8002278:	e0ffff03 	ldbu	r3,-4(fp)
 800227c:	00820034 	movhi	r2,2048
 8002280:	109ac704 	addi	r2,r2,27420
 8002284:	10c5883a 	add	r2,r2,r3
 8002288:	10800003 	ldbu	r2,0(r2)
 800228c:	10803fcc 	andi	r2,r2,255
 8002290:	1006923a 	slli	r3,r2,8
 8002294:	e0bfff03 	ldbu	r2,-4(fp)
 8002298:	11000044 	addi	r4,r2,1
 800229c:	00820034 	movhi	r2,2048
 80022a0:	109ac704 	addi	r2,r2,27420
 80022a4:	1105883a 	add	r2,r2,r4
 80022a8:	10800003 	ldbu	r2,0(r2)
 80022ac:	10803fcc 	andi	r2,r2,255
 80022b0:	1885883a 	add	r2,r3,r2
 80022b4:	1006923a 	slli	r3,r2,8
 80022b8:	e0bfff03 	ldbu	r2,-4(fp)
 80022bc:	11000084 	addi	r4,r2,2
 80022c0:	00820034 	movhi	r2,2048
 80022c4:	109ac704 	addi	r2,r2,27420
 80022c8:	1105883a 	add	r2,r2,r4
 80022cc:	10800003 	ldbu	r2,0(r2)
 80022d0:	10803fcc 	andi	r2,r2,255
 80022d4:	1885883a 	add	r2,r3,r2
 80022d8:	1006923a 	slli	r3,r2,8
 80022dc:	e0bfff03 	ldbu	r2,-4(fp)
 80022e0:	110000c4 	addi	r4,r2,3
 80022e4:	00820034 	movhi	r2,2048
 80022e8:	109ac704 	addi	r2,r2,27420
 80022ec:	1105883a 	add	r2,r2,r4
 80022f0:	10800003 	ldbu	r2,0(r2)
 80022f4:	10803fcc 	andi	r2,r2,255
 80022f8:	1885883a 	add	r2,r3,r2
} //thanks to mstuetz for the missing (unsigned long)
 80022fc:	e037883a 	mov	sp,fp
 8002300:	df000017 	ldw	fp,0(sp)
 8002304:	dec00104 	addi	sp,sp,4
 8002308:	f800283a 	ret

0800230c <_ZL17setSequenceNumberm>:

static void setSequenceNumber(uint32_t seq) {
 800230c:	defffe04 	addi	sp,sp,-8
 8002310:	df000115 	stw	fp,4(sp)
 8002314:	df000104 	addi	fp,sp,4
 8002318:	e13fff15 	stw	r4,-4(fp)
    gPB[TCP_SEQ_H_P]   = (seq & 0xff000000 ) >> 24;
 800231c:	e0bfff17 	ldw	r2,-4(fp)
 8002320:	1004d63a 	srli	r2,r2,24
 8002324:	1007883a 	mov	r3,r2
 8002328:	00820034 	movhi	r2,2048
 800232c:	109ac704 	addi	r2,r2,27420
 8002330:	10c00985 	stb	r3,38(r2)
    gPB[TCP_SEQ_H_P+1] = (seq & 0xff0000 ) >> 16;
 8002334:	e0bfff17 	ldw	r2,-4(fp)
 8002338:	10803fec 	andhi	r2,r2,255
 800233c:	1004d43a 	srli	r2,r2,16
 8002340:	1007883a 	mov	r3,r2
 8002344:	00820034 	movhi	r2,2048
 8002348:	109ac704 	addi	r2,r2,27420
 800234c:	10c009c5 	stb	r3,39(r2)
    gPB[TCP_SEQ_H_P+2] = (seq & 0xff00 ) >> 8;
 8002350:	e0bfff17 	ldw	r2,-4(fp)
 8002354:	10bfc00c 	andi	r2,r2,65280
 8002358:	1004d23a 	srli	r2,r2,8
 800235c:	1007883a 	mov	r3,r2
 8002360:	00820034 	movhi	r2,2048
 8002364:	109ac704 	addi	r2,r2,27420
 8002368:	10c00a05 	stb	r3,40(r2)
    gPB[TCP_SEQ_H_P+3] = (seq & 0xff );
 800236c:	e0bfff17 	ldw	r2,-4(fp)
 8002370:	1007883a 	mov	r3,r2
 8002374:	00820034 	movhi	r2,2048
 8002378:	109ac704 	addi	r2,r2,27420
 800237c:	10c00a45 	stb	r3,41(r2)
}
 8002380:	0001883a 	nop
 8002384:	e037883a 	mov	sp,fp
 8002388:	df000017 	ldw	fp,0(sp)
 800238c:	dec00104 	addi	sp,sp,4
 8002390:	f800283a 	ret

08002394 <_ZN9EtherCard17getSequenceNumberEv>:

uint32_t EtherCard::getSequenceNumber() {
 8002394:	defffe04 	addi	sp,sp,-8
 8002398:	dfc00115 	stw	ra,4(sp)
 800239c:	df000015 	stw	fp,0(sp)
 80023a0:	d839883a 	mov	fp,sp
    return getBigEndianLong(TCP_SEQ_H_P);
 80023a4:	01000984 	movi	r4,38
 80023a8:	80022640 	call	8002264 <_ZL16getBigEndianLongh>
}
 80023ac:	e037883a 	mov	sp,fp
 80023b0:	dfc00117 	ldw	ra,4(sp)
 80023b4:	df000017 	ldw	fp,0(sp)
 80023b8:	dec00204 	addi	sp,sp,8
 80023bc:	f800283a 	ret

080023c0 <_ZN9EtherCard18httpServerReplyAckEv>:

void EtherCard::httpServerReplyAck () {
 80023c0:	defffe04 	addi	sp,sp,-8
 80023c4:	dfc00115 	stw	ra,4(sp)
 80023c8:	df000015 	stw	fp,0(sp)
 80023cc:	d839883a 	mov	fp,sp
    make_tcp_ack_from_any(getTcpPayloadLength(),0); // send ack for http request
 80023d0:	8001fc40 	call	8001fc4 <_ZN9EtherCard19getTcpPayloadLengthEv>
 80023d4:	10bfffcc 	andi	r2,r2,65535
 80023d8:	10a0001c 	xori	r2,r2,32768
 80023dc:	10a00004 	addi	r2,r2,-32768
 80023e0:	000b883a 	mov	r5,zero
 80023e4:	1009883a 	mov	r4,r2
 80023e8:	80020540 	call	8002054 <_ZL21make_tcp_ack_from_anysh>
    SEQ = getSequenceNumber(); //get the sequence number of packets after an ack from GET
 80023ec:	80023940 	call	8002394 <_ZN9EtherCard17getSequenceNumberEv>
 80023f0:	d0a07415 	stw	r2,-32304(gp)
}
 80023f4:	0001883a 	nop
 80023f8:	e037883a 	mov	sp,fp
 80023fc:	dfc00117 	ldw	ra,4(sp)
 8002400:	df000017 	ldw	fp,0(sp)
 8002404:	dec00204 	addi	sp,sp,8
 8002408:	f800283a 	ret

0800240c <_ZN9EtherCard26httpServerReply_with_flagsEth>:

void EtherCard::httpServerReply_with_flags (uint16_t dlen , uint8_t flags) {
 800240c:	defffc04 	addi	sp,sp,-16
 8002410:	dfc00315 	stw	ra,12(sp)
 8002414:	df000215 	stw	fp,8(sp)
 8002418:	df000204 	addi	fp,sp,8
 800241c:	2007883a 	mov	r3,r4
 8002420:	2805883a 	mov	r2,r5
 8002424:	e0fffe0d 	sth	r3,-8(fp)
 8002428:	e0bfff05 	stb	r2,-4(fp)
    setSequenceNumber(SEQ);
 800242c:	d0a07417 	ldw	r2,-32304(gp)
 8002430:	1009883a 	mov	r4,r2
 8002434:	800230c0 	call	800230c <_ZL17setSequenceNumberm>
    gPB[TCP_FLAGS_P] = flags; // final packet
 8002438:	00820034 	movhi	r2,2048
 800243c:	109ac704 	addi	r2,r2,27420
 8002440:	e0ffff03 	ldbu	r3,-4(fp)
 8002444:	10c00bc5 	stb	r3,47(r2)
    make_tcp_ack_with_data_noflags(dlen); // send data
 8002448:	e0bffe0b 	ldhu	r2,-8(fp)
 800244c:	1009883a 	mov	r4,r2
 8002450:	80021440 	call	8002144 <_ZL30make_tcp_ack_with_data_noflagst>
    SEQ=SEQ+dlen;
 8002454:	e0fffe0b 	ldhu	r3,-8(fp)
 8002458:	d0a07417 	ldw	r2,-32304(gp)
 800245c:	1885883a 	add	r2,r3,r2
 8002460:	d0a07415 	stw	r2,-32304(gp)
}
 8002464:	0001883a 	nop
 8002468:	e037883a 	mov	sp,fp
 800246c:	dfc00117 	ldw	ra,4(sp)
 8002470:	df000017 	ldw	fp,0(sp)
 8002474:	dec00204 	addi	sp,sp,8
 8002478:	f800283a 	ret

0800247c <_ZN9EtherCard17clientIcmpRequestEPKh>:

void EtherCard::clientIcmpRequest(const uint8_t *destip) {
 800247c:	defffd04 	addi	sp,sp,-12
 8002480:	dfc00215 	stw	ra,8(sp)
 8002484:	df000115 	stw	fp,4(sp)
 8002488:	df000104 	addi	fp,sp,4
 800248c:	e13fff15 	stw	r4,-4(fp)
    if(is_lan(EtherCard::myip, destip)) {
 8002490:	e17fff17 	ldw	r5,-4(fp)
 8002494:	d12057c4 	addi	r4,gp,-32417
 8002498:	80016c00 	call	80016c0 <_ZL6is_lanPKhS0_>
 800249c:	10803fcc 	andi	r2,r2,255
 80024a0:	10000426 	beq	r2,zero,80024b4 <_ZN9EtherCard17clientIcmpRequestEPKh+0x38>
        setMACandIPs(destmacaddr, destip);
 80024a4:	e17fff17 	ldw	r5,-4(fp)
 80024a8:	d1206e04 	addi	r4,gp,-32328
 80024ac:	800161c0 	call	800161c <_ZL12setMACandIPsPKhS0_>
 80024b0:	00000306 	br	80024c0 <_ZN9EtherCard17clientIcmpRequestEPKh+0x44>
    } else {
        setMACandIPs(gwmacaddr, destip);
 80024b4:	e17fff17 	ldw	r5,-4(fp)
 80024b8:	d1207084 	addi	r4,gp,-32318
 80024bc:	800161c0 	call	800161c <_ZL12setMACandIPsPKhS0_>
    }
    gPB[ETH_TYPE_H_P] = ETHTYPE_IP_H_V;
 80024c0:	00820034 	movhi	r2,2048
 80024c4:	109ac704 	addi	r2,r2,27420
 80024c8:	00c00204 	movi	r3,8
 80024cc:	10c00305 	stb	r3,12(r2)
    gPB[ETH_TYPE_L_P] = ETHTYPE_IP_L_V;
 80024d0:	00820034 	movhi	r2,2048
 80024d4:	109ac704 	addi	r2,r2,27420
 80024d8:	10000345 	stb	zero,13(r2)
    memcpy_P(gPB + IP_P,iphdr,sizeof iphdr);
 80024dc:	00820034 	movhi	r2,2048
 80024e0:	109aca84 	addi	r2,r2,27434
 80024e4:	01800244 	movi	r6,9
 80024e8:	01420034 	movhi	r5,2048
 80024ec:	29599d04 	addi	r5,r5,26228
 80024f0:	1009883a 	mov	r4,r2
 80024f4:	80014040 	call	8001404 <_Z8memcpy_PPvPKvj>
    gPB[IP_TOTLEN_L_P] = 0x54;
 80024f8:	00820034 	movhi	r2,2048
 80024fc:	109ac704 	addi	r2,r2,27420
 8002500:	00c01504 	movi	r3,84
 8002504:	10c00445 	stb	r3,17(r2)
    gPB[IP_PROTO_P] = IP_PROTO_ICMP_V;
 8002508:	00820034 	movhi	r2,2048
 800250c:	109ac704 	addi	r2,r2,27420
 8002510:	00c00044 	movi	r3,1
 8002514:	10c005c5 	stb	r3,23(r2)
    fill_ip_hdr_checksum();
 8002518:	80018e80 	call	80018e8 <_ZL20fill_ip_hdr_checksumv>
    gPB[ICMP_TYPE_P] = ICMP_TYPE_ECHOREQUEST_V;
 800251c:	00820034 	movhi	r2,2048
 8002520:	109ac704 	addi	r2,r2,27420
 8002524:	00c00204 	movi	r3,8
 8002528:	10c00885 	stb	r3,34(r2)
    gPB[ICMP_TYPE_P+1] = 0; // code
 800252c:	00820034 	movhi	r2,2048
 8002530:	109ac704 	addi	r2,r2,27420
 8002534:	100008c5 	stb	zero,35(r2)
    gPB[ICMP_CHECKSUM_H_P] = 0;
 8002538:	00820034 	movhi	r2,2048
 800253c:	109ac704 	addi	r2,r2,27420
 8002540:	10000905 	stb	zero,36(r2)
    gPB[ICMP_CHECKSUM_L_P] = 0;
 8002544:	00820034 	movhi	r2,2048
 8002548:	109ac704 	addi	r2,r2,27420
 800254c:	10000945 	stb	zero,37(r2)
    gPB[ICMP_IDENT_H_P] = 5; // some number
 8002550:	00820034 	movhi	r2,2048
 8002554:	109ac704 	addi	r2,r2,27420
 8002558:	00c00144 	movi	r3,5
 800255c:	10c00985 	stb	r3,38(r2)
    gPB[ICMP_IDENT_L_P] = EtherCard::myip[3]; // last byte of my IP
 8002560:	d0e05883 	ldbu	r3,-32414(gp)
 8002564:	00820034 	movhi	r2,2048
 8002568:	109ac704 	addi	r2,r2,27420
 800256c:	10c009c5 	stb	r3,39(r2)
    gPB[ICMP_IDENT_L_P+1] = 0; // seq number, high byte
 8002570:	00820034 	movhi	r2,2048
 8002574:	109ac704 	addi	r2,r2,27420
 8002578:	10000a05 	stb	zero,40(r2)
    gPB[ICMP_IDENT_L_P+2] = 1; // seq number, low byte, we send only 1 ping at a time
 800257c:	00820034 	movhi	r2,2048
 8002580:	109ac704 	addi	r2,r2,27420
 8002584:	00c00044 	movi	r3,1
 8002588:	10c00a45 	stb	r3,41(r2)
    memset(gPB + ICMP_DATA_P, PINGPATTERN, 56);
 800258c:	00820034 	movhi	r2,2048
 8002590:	109ad184 	addi	r2,r2,27462
 8002594:	01800e04 	movi	r6,56
 8002598:	01401084 	movi	r5,66
 800259c:	1009883a 	mov	r4,r2
 80025a0:	8004c5c0 	call	8004c5c <memset>
    fill_checksum(ICMP_CHECKSUM_H_P, ICMP_TYPE_P, 56+8,0);
 80025a4:	000f883a 	mov	r7,zero
 80025a8:	01801004 	movi	r6,64
 80025ac:	01400884 	movi	r5,34
 80025b0:	01000904 	movi	r4,36
 80025b4:	80014480 	call	8001448 <_ZL13fill_checksumhhth>
    packetSend(98);
 80025b8:	01001884 	movi	r4,98
 80025bc:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 80025c0:	0001883a 	nop
 80025c4:	e037883a 	mov	sp,fp
 80025c8:	dfc00117 	ldw	ra,4(sp)
 80025cc:	df000017 	ldw	fp,0(sp)
 80025d0:	dec00204 	addi	sp,sp,8
 80025d4:	f800283a 	ret

080025d8 <_ZN9EtherCard10ntpRequestEPhh>:

void EtherCard::ntpRequest (uint8_t *ntpip,uint8_t srcport) {
 80025d8:	defffc04 	addi	sp,sp,-16
 80025dc:	dfc00315 	stw	ra,12(sp)
 80025e0:	df000215 	stw	fp,8(sp)
 80025e4:	df000204 	addi	fp,sp,8
 80025e8:	e13ffe15 	stw	r4,-8(fp)
 80025ec:	2805883a 	mov	r2,r5
 80025f0:	e0bfff05 	stb	r2,-4(fp)
    if(is_lan(myip, ntpip)) {
 80025f4:	e17ffe17 	ldw	r5,-8(fp)
 80025f8:	d12057c4 	addi	r4,gp,-32417
 80025fc:	80016c00 	call	80016c0 <_ZL6is_lanPKhS0_>
 8002600:	10803fcc 	andi	r2,r2,255
 8002604:	10000426 	beq	r2,zero,8002618 <_ZN9EtherCard10ntpRequestEPhh+0x40>
        setMACandIPs(destmacaddr, ntpip);
 8002608:	e17ffe17 	ldw	r5,-8(fp)
 800260c:	d1206e04 	addi	r4,gp,-32328
 8002610:	800161c0 	call	800161c <_ZL12setMACandIPsPKhS0_>
 8002614:	00000306 	br	8002624 <_ZN9EtherCard10ntpRequestEPhh+0x4c>
    } else {
        setMACandIPs(gwmacaddr, ntpip);
 8002618:	e17ffe17 	ldw	r5,-8(fp)
 800261c:	d1207084 	addi	r4,gp,-32318
 8002620:	800161c0 	call	800161c <_ZL12setMACandIPsPKhS0_>
    }
    gPB[ETH_TYPE_H_P] = ETHTYPE_IP_H_V;
 8002624:	00820034 	movhi	r2,2048
 8002628:	109ac704 	addi	r2,r2,27420
 800262c:	00c00204 	movi	r3,8
 8002630:	10c00305 	stb	r3,12(r2)
    gPB[ETH_TYPE_L_P] = ETHTYPE_IP_L_V;
 8002634:	00820034 	movhi	r2,2048
 8002638:	109ac704 	addi	r2,r2,27420
 800263c:	10000345 	stb	zero,13(r2)
    memcpy_P(gPB + IP_P,iphdr,sizeof iphdr);
 8002640:	00820034 	movhi	r2,2048
 8002644:	109aca84 	addi	r2,r2,27434
 8002648:	01800244 	movi	r6,9
 800264c:	01420034 	movhi	r5,2048
 8002650:	29599d04 	addi	r5,r5,26228
 8002654:	1009883a 	mov	r4,r2
 8002658:	80014040 	call	8001404 <_Z8memcpy_PPvPKvj>
    gPB[IP_TOTLEN_L_P] = 0x4c;
 800265c:	00820034 	movhi	r2,2048
 8002660:	109ac704 	addi	r2,r2,27420
 8002664:	00c01304 	movi	r3,76
 8002668:	10c00445 	stb	r3,17(r2)
    gPB[IP_PROTO_P] = IP_PROTO_UDP_V;
 800266c:	00820034 	movhi	r2,2048
 8002670:	109ac704 	addi	r2,r2,27420
 8002674:	00c00444 	movi	r3,17
 8002678:	10c005c5 	stb	r3,23(r2)
    fill_ip_hdr_checksum();
 800267c:	80018e80 	call	80018e8 <_ZL20fill_ip_hdr_checksumv>
    gPB[UDP_DST_PORT_H_P] = 0;
 8002680:	00820034 	movhi	r2,2048
 8002684:	109ac704 	addi	r2,r2,27420
 8002688:	10000905 	stb	zero,36(r2)
    gPB[UDP_DST_PORT_L_P] = NTP_PORT; // ntp = 123
 800268c:	00820034 	movhi	r2,2048
 8002690:	109ac704 	addi	r2,r2,27420
 8002694:	00c01ec4 	movi	r3,123
 8002698:	10c00945 	stb	r3,37(r2)
    gPB[UDP_SRC_PORT_H_P] = 10;
 800269c:	00820034 	movhi	r2,2048
 80026a0:	109ac704 	addi	r2,r2,27420
 80026a4:	00c00284 	movi	r3,10
 80026a8:	10c00885 	stb	r3,34(r2)
    gPB[UDP_SRC_PORT_L_P] = srcport; // lower 8 bit of src port
 80026ac:	00820034 	movhi	r2,2048
 80026b0:	109ac704 	addi	r2,r2,27420
 80026b4:	e0ffff03 	ldbu	r3,-4(fp)
 80026b8:	10c008c5 	stb	r3,35(r2)
    gPB[UDP_LEN_H_P] = 0;
 80026bc:	00820034 	movhi	r2,2048
 80026c0:	109ac704 	addi	r2,r2,27420
 80026c4:	10000985 	stb	zero,38(r2)
    gPB[UDP_LEN_L_P] = 56; // fixed len
 80026c8:	00820034 	movhi	r2,2048
 80026cc:	109ac704 	addi	r2,r2,27420
 80026d0:	00c00e04 	movi	r3,56
 80026d4:	10c009c5 	stb	r3,39(r2)
    gPB[UDP_CHECKSUM_H_P] = 0;
 80026d8:	00820034 	movhi	r2,2048
 80026dc:	109ac704 	addi	r2,r2,27420
 80026e0:	10000a05 	stb	zero,40(r2)
    gPB[UDP_CHECKSUM_L_P] = 0;
 80026e4:	00820034 	movhi	r2,2048
 80026e8:	109ac704 	addi	r2,r2,27420
 80026ec:	10000a45 	stb	zero,41(r2)
    memset(gPB + UDP_DATA_P, 0, 48);
 80026f0:	00820034 	movhi	r2,2048
 80026f4:	109ad184 	addi	r2,r2,27462
 80026f8:	01800c04 	movi	r6,48
 80026fc:	000b883a 	mov	r5,zero
 8002700:	1009883a 	mov	r4,r2
 8002704:	8004c5c0 	call	8004c5c <memset>
    memcpy_P(gPB + UDP_DATA_P,ntpreqhdr,10);
 8002708:	00820034 	movhi	r2,2048
 800270c:	109ad184 	addi	r2,r2,27462
 8002710:	01800284 	movi	r6,10
 8002714:	01420034 	movhi	r5,2048
 8002718:	29599f44 	addi	r5,r5,26237
 800271c:	1009883a 	mov	r4,r2
 8002720:	80014040 	call	8001404 <_Z8memcpy_PPvPKvj>

    fill_checksum(UDP_CHECKSUM_H_P, IP_SRC_P, 16 + 48,1);
 8002724:	01c00044 	movi	r7,1
 8002728:	01801004 	movi	r6,64
 800272c:	01400684 	movi	r5,26
 8002730:	01000a04 	movi	r4,40
 8002734:	80014480 	call	8001448 <_ZL13fill_checksumhhth>
    packetSend(90);
 8002738:	01001684 	movi	r4,90
 800273c:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 8002740:	0001883a 	nop
 8002744:	e037883a 	mov	sp,fp
 8002748:	dfc00117 	ldw	ra,4(sp)
 800274c:	df000017 	ldw	fp,0(sp)
 8002750:	dec00204 	addi	sp,sp,8
 8002754:	f800283a 	ret

08002758 <_ZN9EtherCard16ntpProcessAnswerEPmh>:

uint8_t EtherCard::ntpProcessAnswer (uint32_t *time,uint8_t dstport_l) {
 8002758:	defffd04 	addi	sp,sp,-12
 800275c:	df000215 	stw	fp,8(sp)
 8002760:	df000204 	addi	fp,sp,8
 8002764:	e13ffe15 	stw	r4,-8(fp)
 8002768:	2805883a 	mov	r2,r5
 800276c:	e0bfff05 	stb	r2,-4(fp)
    if ((dstport_l && gPB[UDP_DST_PORT_L_P]!=dstport_l) || gPB[UDP_LEN_H_P]!=0 ||
 8002770:	e0bfff03 	ldbu	r2,-4(fp)
 8002774:	10000626 	beq	r2,zero,8002790 <_ZN9EtherCard16ntpProcessAnswerEPmh+0x38>
 8002778:	00820034 	movhi	r2,2048
 800277c:	109ac704 	addi	r2,r2,27420
 8002780:	10800943 	ldbu	r2,37(r2)
 8002784:	10c03fcc 	andi	r3,r2,255
 8002788:	e0bfff03 	ldbu	r2,-4(fp)
 800278c:	1880111e 	bne	r3,r2,80027d4 <_ZN9EtherCard16ntpProcessAnswerEPmh+0x7c>
 8002790:	00820034 	movhi	r2,2048
 8002794:	109ac704 	addi	r2,r2,27420
 8002798:	10800983 	ldbu	r2,38(r2)
 800279c:	10803fcc 	andi	r2,r2,255
 80027a0:	10000c1e 	bne	r2,zero,80027d4 <_ZN9EtherCard16ntpProcessAnswerEPmh+0x7c>
            gPB[UDP_LEN_L_P]!=56 || gPB[UDP_SRC_PORT_L_P]!=0x7b)
 80027a4:	00820034 	movhi	r2,2048
 80027a8:	109ac704 	addi	r2,r2,27420
 80027ac:	108009c3 	ldbu	r2,39(r2)
    fill_checksum(UDP_CHECKSUM_H_P, IP_SRC_P, 16 + 48,1);
    packetSend(90);
}

uint8_t EtherCard::ntpProcessAnswer (uint32_t *time,uint8_t dstport_l) {
    if ((dstport_l && gPB[UDP_DST_PORT_L_P]!=dstport_l) || gPB[UDP_LEN_H_P]!=0 ||
 80027b0:	10803fcc 	andi	r2,r2,255
 80027b4:	10800e18 	cmpnei	r2,r2,56
 80027b8:	1000061e 	bne	r2,zero,80027d4 <_ZN9EtherCard16ntpProcessAnswerEPmh+0x7c>
            gPB[UDP_LEN_L_P]!=56 || gPB[UDP_SRC_PORT_L_P]!=0x7b)
 80027bc:	00820034 	movhi	r2,2048
 80027c0:	109ac704 	addi	r2,r2,27420
 80027c4:	108008c3 	ldbu	r2,35(r2)
 80027c8:	10803fcc 	andi	r2,r2,255
 80027cc:	10801ee0 	cmpeqi	r2,r2,123
 80027d0:	1000021e 	bne	r2,zero,80027dc <_ZN9EtherCard16ntpProcessAnswerEPmh+0x84>
        return 0;
 80027d4:	0005883a 	mov	r2,zero
 80027d8:	00001806 	br	800283c <_ZN9EtherCard16ntpProcessAnswerEPmh+0xe4>
    ((uint8_t*) time)[3] = gPB[0x52];
 80027dc:	e0bffe17 	ldw	r2,-8(fp)
 80027e0:	10c000c4 	addi	r3,r2,3
 80027e4:	00820034 	movhi	r2,2048
 80027e8:	109ac704 	addi	r2,r2,27420
 80027ec:	10801483 	ldbu	r2,82(r2)
 80027f0:	18800005 	stb	r2,0(r3)
    ((uint8_t*) time)[2] = gPB[0x53];
 80027f4:	e0bffe17 	ldw	r2,-8(fp)
 80027f8:	10c00084 	addi	r3,r2,2
 80027fc:	00820034 	movhi	r2,2048
 8002800:	109ac704 	addi	r2,r2,27420
 8002804:	108014c3 	ldbu	r2,83(r2)
 8002808:	18800005 	stb	r2,0(r3)
    ((uint8_t*) time)[1] = gPB[0x54];
 800280c:	e0bffe17 	ldw	r2,-8(fp)
 8002810:	10c00044 	addi	r3,r2,1
 8002814:	00820034 	movhi	r2,2048
 8002818:	109ac704 	addi	r2,r2,27420
 800281c:	10801503 	ldbu	r2,84(r2)
 8002820:	18800005 	stb	r2,0(r3)
    ((uint8_t*) time)[0] = gPB[0x55];
 8002824:	00820034 	movhi	r2,2048
 8002828:	109ac704 	addi	r2,r2,27420
 800282c:	10c01543 	ldbu	r3,85(r2)
 8002830:	e0bffe17 	ldw	r2,-8(fp)
 8002834:	10c00005 	stb	r3,0(r2)
    return 1;
 8002838:	00800044 	movi	r2,1
}
 800283c:	e037883a 	mov	sp,fp
 8002840:	df000017 	ldw	fp,0(sp)
 8002844:	dec00104 	addi	sp,sp,4
 8002848:	f800283a 	ret

0800284c <_ZN9EtherCard10udpPrepareEtPKht>:

void EtherCard::udpPrepare (uint16_t sport, const uint8_t *dip, uint16_t dport) {
 800284c:	defffb04 	addi	sp,sp,-20
 8002850:	dfc00415 	stw	ra,16(sp)
 8002854:	df000315 	stw	fp,12(sp)
 8002858:	df000304 	addi	fp,sp,12
 800285c:	2007883a 	mov	r3,r4
 8002860:	e17ffe15 	stw	r5,-8(fp)
 8002864:	3005883a 	mov	r2,r6
 8002868:	e0fffd0d 	sth	r3,-12(fp)
 800286c:	e0bfff0d 	sth	r2,-4(fp)
    if(is_lan(myip, dip)) {                    // this works because both dns mac and destinations mac are stored in same variable - destmacaddr
 8002870:	e17ffe17 	ldw	r5,-8(fp)
 8002874:	d12057c4 	addi	r4,gp,-32417
 8002878:	80016c00 	call	80016c0 <_ZL6is_lanPKhS0_>
 800287c:	10803fcc 	andi	r2,r2,255
 8002880:	10000426 	beq	r2,zero,8002894 <_ZN9EtherCard10udpPrepareEtPKht+0x48>
        setMACandIPs(destmacaddr, dip);        // at different times. The program could have separate variable for dns mac, then here should be
 8002884:	e17ffe17 	ldw	r5,-8(fp)
 8002888:	d1206e04 	addi	r4,gp,-32328
 800288c:	800161c0 	call	800161c <_ZL12setMACandIPsPKhS0_>
 8002890:	00000306 	br	80028a0 <_ZN9EtherCard10udpPrepareEtPKht+0x54>
    } else {                                   // checked if dip is dns ip and separately if dip is hisip and then use correct mac.
        setMACandIPs(gwmacaddr, dip);
 8002894:	e17ffe17 	ldw	r5,-8(fp)
 8002898:	d1207084 	addi	r4,gp,-32318
 800289c:	800161c0 	call	800161c <_ZL12setMACandIPsPKhS0_>
    }
    // see http://tldp.org/HOWTO/Multicast-HOWTO-2.html
    // multicast or broadcast address, https://github.com/njh/EtherCard/issues/59
    if ((dip[0] & 0xF0) == 0xE0 || *((unsigned long*) dip) == 0xFFFFFFFF || !memcmp(broadcastip,dip,IP_LEN))
 80028a0:	e0bffe17 	ldw	r2,-8(fp)
 80028a4:	10800003 	ldbu	r2,0(r2)
 80028a8:	10803fcc 	andi	r2,r2,255
 80028ac:	10803c0c 	andi	r2,r2,240
 80028b0:	10803820 	cmpeqi	r2,r2,224
 80028b4:	1000091e 	bne	r2,zero,80028dc <_ZN9EtherCard10udpPrepareEtPKht+0x90>
 80028b8:	e0bffe17 	ldw	r2,-8(fp)
 80028bc:	10800017 	ldw	r2,0(r2)
 80028c0:	10bfffe0 	cmpeqi	r2,r2,-1
 80028c4:	1000051e 	bne	r2,zero,80028dc <_ZN9EtherCard10udpPrepareEtPKht+0x90>
 80028c8:	01800104 	movi	r6,4
 80028cc:	e17ffe17 	ldw	r5,-8(fp)
 80028d0:	d12059c4 	addi	r4,gp,-32409
 80028d4:	8004c040 	call	8004c04 <memcmp>
 80028d8:	1000041e 	bne	r2,zero,80028ec <_ZN9EtherCard10udpPrepareEtPKht+0xa0>
        EtherCard::copyMac(gPB + ETH_DST_MAC, allOnes);
 80028dc:	d16002c4 	addi	r5,gp,-32757
 80028e0:	01020034 	movhi	r4,2048
 80028e4:	211ac704 	addi	r4,r4,27420
 80028e8:	8003f3c0 	call	8003f3c <_ZN9EtherCard7copyMacEPhPKh>
    gPB[ETH_TYPE_H_P] = ETHTYPE_IP_H_V;
 80028ec:	00820034 	movhi	r2,2048
 80028f0:	109ac704 	addi	r2,r2,27420
 80028f4:	00c00204 	movi	r3,8
 80028f8:	10c00305 	stb	r3,12(r2)
    gPB[ETH_TYPE_L_P] = ETHTYPE_IP_L_V;
 80028fc:	00820034 	movhi	r2,2048
 8002900:	109ac704 	addi	r2,r2,27420
 8002904:	10000345 	stb	zero,13(r2)
    memcpy_P(gPB + IP_P,iphdr,sizeof iphdr);
 8002908:	00820034 	movhi	r2,2048
 800290c:	109aca84 	addi	r2,r2,27434
 8002910:	01800244 	movi	r6,9
 8002914:	01420034 	movhi	r5,2048
 8002918:	29599d04 	addi	r5,r5,26228
 800291c:	1009883a 	mov	r4,r2
 8002920:	80014040 	call	8001404 <_Z8memcpy_PPvPKvj>
    gPB[IP_TOTLEN_H_P] = 0;
 8002924:	00820034 	movhi	r2,2048
 8002928:	109ac704 	addi	r2,r2,27420
 800292c:	10000405 	stb	zero,16(r2)
    gPB[IP_PROTO_P] = IP_PROTO_UDP_V;
 8002930:	00820034 	movhi	r2,2048
 8002934:	109ac704 	addi	r2,r2,27420
 8002938:	00c00444 	movi	r3,17
 800293c:	10c005c5 	stb	r3,23(r2)
    gPB[UDP_DST_PORT_H_P] = (dport>>8);
 8002940:	e0bfff0b 	ldhu	r2,-4(fp)
 8002944:	1005d23a 	srai	r2,r2,8
 8002948:	1007883a 	mov	r3,r2
 800294c:	00820034 	movhi	r2,2048
 8002950:	109ac704 	addi	r2,r2,27420
 8002954:	10c00905 	stb	r3,36(r2)
    gPB[UDP_DST_PORT_L_P] = dport;
 8002958:	e0bfff0b 	ldhu	r2,-4(fp)
 800295c:	1007883a 	mov	r3,r2
 8002960:	00820034 	movhi	r2,2048
 8002964:	109ac704 	addi	r2,r2,27420
 8002968:	10c00945 	stb	r3,37(r2)
    gPB[UDP_SRC_PORT_H_P] = (sport>>8);
 800296c:	e0bffd0b 	ldhu	r2,-12(fp)
 8002970:	1005d23a 	srai	r2,r2,8
 8002974:	1007883a 	mov	r3,r2
 8002978:	00820034 	movhi	r2,2048
 800297c:	109ac704 	addi	r2,r2,27420
 8002980:	10c00885 	stb	r3,34(r2)
    gPB[UDP_SRC_PORT_L_P] = sport;
 8002984:	e0bffd0b 	ldhu	r2,-12(fp)
 8002988:	1007883a 	mov	r3,r2
 800298c:	00820034 	movhi	r2,2048
 8002990:	109ac704 	addi	r2,r2,27420
 8002994:	10c008c5 	stb	r3,35(r2)
    gPB[UDP_LEN_H_P] = 0;
 8002998:	00820034 	movhi	r2,2048
 800299c:	109ac704 	addi	r2,r2,27420
 80029a0:	10000985 	stb	zero,38(r2)
    gPB[UDP_CHECKSUM_H_P] = 0;
 80029a4:	00820034 	movhi	r2,2048
 80029a8:	109ac704 	addi	r2,r2,27420
 80029ac:	10000a05 	stb	zero,40(r2)
    gPB[UDP_CHECKSUM_L_P] = 0;
 80029b0:	00820034 	movhi	r2,2048
 80029b4:	109ac704 	addi	r2,r2,27420
 80029b8:	10000a45 	stb	zero,41(r2)
}
 80029bc:	0001883a 	nop
 80029c0:	e037883a 	mov	sp,fp
 80029c4:	dfc00117 	ldw	ra,4(sp)
 80029c8:	df000017 	ldw	fp,0(sp)
 80029cc:	dec00204 	addi	sp,sp,8
 80029d0:	f800283a 	ret

080029d4 <_ZN9EtherCard11udpTransmitEt>:

void EtherCard::udpTransmit (uint16_t datalen) {
 80029d4:	defffd04 	addi	sp,sp,-12
 80029d8:	dfc00215 	stw	ra,8(sp)
 80029dc:	df000115 	stw	fp,4(sp)
 80029e0:	df000104 	addi	fp,sp,4
 80029e4:	2005883a 	mov	r2,r4
 80029e8:	e0bfff0d 	sth	r2,-4(fp)
    gPB[IP_TOTLEN_H_P] = (IP_HEADER_LEN+UDP_HEADER_LEN+datalen) >> 8;
 80029ec:	e0bfff0b 	ldhu	r2,-4(fp)
 80029f0:	10800704 	addi	r2,r2,28
 80029f4:	1005d23a 	srai	r2,r2,8
 80029f8:	1007883a 	mov	r3,r2
 80029fc:	00820034 	movhi	r2,2048
 8002a00:	109ac704 	addi	r2,r2,27420
 8002a04:	10c00405 	stb	r3,16(r2)
    gPB[IP_TOTLEN_L_P] = IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
 8002a08:	e0bfff0b 	ldhu	r2,-4(fp)
 8002a0c:	10800704 	addi	r2,r2,28
 8002a10:	1007883a 	mov	r3,r2
 8002a14:	00820034 	movhi	r2,2048
 8002a18:	109ac704 	addi	r2,r2,27420
 8002a1c:	10c00445 	stb	r3,17(r2)
    fill_ip_hdr_checksum();
 8002a20:	80018e80 	call	80018e8 <_ZL20fill_ip_hdr_checksumv>
    gPB[UDP_LEN_H_P] = (UDP_HEADER_LEN+datalen) >>8;
 8002a24:	e0bfff0b 	ldhu	r2,-4(fp)
 8002a28:	10800204 	addi	r2,r2,8
 8002a2c:	1005d23a 	srai	r2,r2,8
 8002a30:	1007883a 	mov	r3,r2
 8002a34:	00820034 	movhi	r2,2048
 8002a38:	109ac704 	addi	r2,r2,27420
 8002a3c:	10c00985 	stb	r3,38(r2)
    gPB[UDP_LEN_L_P] = UDP_HEADER_LEN+datalen;
 8002a40:	e0bfff0b 	ldhu	r2,-4(fp)
 8002a44:	10800204 	addi	r2,r2,8
 8002a48:	1007883a 	mov	r3,r2
 8002a4c:	00820034 	movhi	r2,2048
 8002a50:	109ac704 	addi	r2,r2,27420
 8002a54:	10c009c5 	stb	r3,39(r2)
    fill_checksum(UDP_CHECKSUM_H_P, IP_SRC_P, 16 + datalen,1);
 8002a58:	e0bfff0b 	ldhu	r2,-4(fp)
 8002a5c:	10800404 	addi	r2,r2,16
 8002a60:	10bfffcc 	andi	r2,r2,65535
 8002a64:	01c00044 	movi	r7,1
 8002a68:	100d883a 	mov	r6,r2
 8002a6c:	01400684 	movi	r5,26
 8002a70:	01000a04 	movi	r4,40
 8002a74:	80014480 	call	8001448 <_ZL13fill_checksumhhth>
    packetSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen);
 8002a78:	e0bfff0b 	ldhu	r2,-4(fp)
 8002a7c:	10800a84 	addi	r2,r2,42
 8002a80:	10bfffcc 	andi	r2,r2,65535
 8002a84:	1009883a 	mov	r4,r2
 8002a88:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 8002a8c:	0001883a 	nop
 8002a90:	e037883a 	mov	sp,fp
 8002a94:	dfc00117 	ldw	ra,4(sp)
 8002a98:	df000017 	ldw	fp,0(sp)
 8002a9c:	dec00204 	addi	sp,sp,8
 8002aa0:	f800283a 	ret

08002aa4 <_ZN9EtherCard7sendUdpEPKchtPKht>:

void EtherCard::sendUdp (const char *data, uint8_t datalen, uint16_t sport,
                         const uint8_t *dip, uint16_t dport) {
 8002aa4:	defff904 	addi	sp,sp,-28
 8002aa8:	dfc00615 	stw	ra,24(sp)
 8002aac:	df000515 	stw	fp,20(sp)
 8002ab0:	df000504 	addi	fp,sp,20
 8002ab4:	e13ffb15 	stw	r4,-20(fp)
 8002ab8:	2809883a 	mov	r4,r5
 8002abc:	3007883a 	mov	r3,r6
 8002ac0:	e1fffe15 	stw	r7,-8(fp)
 8002ac4:	e0800217 	ldw	r2,8(fp)
 8002ac8:	e13ffc05 	stb	r4,-16(fp)
 8002acc:	e0fffd0d 	sth	r3,-12(fp)
 8002ad0:	e0bfff0d 	sth	r2,-4(fp)
    udpPrepare(sport, dip, dport);
 8002ad4:	e0bffd0b 	ldhu	r2,-12(fp)
 8002ad8:	e0ffff0b 	ldhu	r3,-4(fp)
 8002adc:	180d883a 	mov	r6,r3
 8002ae0:	e17ffe17 	ldw	r5,-8(fp)
 8002ae4:	1009883a 	mov	r4,r2
 8002ae8:	800284c0 	call	800284c <_ZN9EtherCard10udpPrepareEtPKht>
    if (datalen>220)
 8002aec:	e0bffc03 	ldbu	r2,-16(fp)
 8002af0:	10803770 	cmpltui	r2,r2,221
 8002af4:	1000021e 	bne	r2,zero,8002b00 <_ZN9EtherCard7sendUdpEPKchtPKht+0x5c>
        datalen = 220;
 8002af8:	00bff704 	movi	r2,-36
 8002afc:	e0bffc05 	stb	r2,-16(fp)
    memcpy(gPB + UDP_DATA_P, data, datalen);
 8002b00:	00820034 	movhi	r2,2048
 8002b04:	109ad184 	addi	r2,r2,27462
 8002b08:	e0fffc03 	ldbu	r3,-16(fp)
 8002b0c:	180d883a 	mov	r6,r3
 8002b10:	e17ffb17 	ldw	r5,-20(fp)
 8002b14:	1009883a 	mov	r4,r2
 8002b18:	8004c340 	call	8004c34 <memcpy>
    udpTransmit(datalen);
 8002b1c:	e0bffc03 	ldbu	r2,-16(fp)
 8002b20:	1009883a 	mov	r4,r2
 8002b24:	80029d40 	call	80029d4 <_ZN9EtherCard11udpTransmitEt>
}
 8002b28:	0001883a 	nop
 8002b2c:	e037883a 	mov	sp,fp
 8002b30:	dfc00117 	ldw	ra,4(sp)
 8002b34:	df000017 	ldw	fp,0(sp)
 8002b38:	dec00204 	addi	sp,sp,8
 8002b3c:	f800283a 	ret

08002b40 <_ZN9EtherCard7sendWolEPh>:

void EtherCard::sendWol (uint8_t *wolmac) {
 8002b40:	defffc04 	addi	sp,sp,-16
 8002b44:	dfc00315 	stw	ra,12(sp)
 8002b48:	df000215 	stw	fp,8(sp)
 8002b4c:	df000204 	addi	fp,sp,8
 8002b50:	e13fff15 	stw	r4,-4(fp)
    setMACandIPs(allOnes, allOnes);
 8002b54:	d16002c4 	addi	r5,gp,-32757
 8002b58:	d12002c4 	addi	r4,gp,-32757
 8002b5c:	800161c0 	call	800161c <_ZL12setMACandIPsPKhS0_>
    gPB[ETH_TYPE_H_P] = ETHTYPE_IP_H_V;
 8002b60:	00820034 	movhi	r2,2048
 8002b64:	109ac704 	addi	r2,r2,27420
 8002b68:	00c00204 	movi	r3,8
 8002b6c:	10c00305 	stb	r3,12(r2)
    gPB[ETH_TYPE_L_P] = ETHTYPE_IP_L_V;
 8002b70:	00820034 	movhi	r2,2048
 8002b74:	109ac704 	addi	r2,r2,27420
 8002b78:	10000345 	stb	zero,13(r2)
    memcpy_P(gPB + IP_P,iphdr,9);
 8002b7c:	00820034 	movhi	r2,2048
 8002b80:	109aca84 	addi	r2,r2,27434
 8002b84:	01800244 	movi	r6,9
 8002b88:	01420034 	movhi	r5,2048
 8002b8c:	29599d04 	addi	r5,r5,26228
 8002b90:	1009883a 	mov	r4,r2
 8002b94:	80014040 	call	8001404 <_Z8memcpy_PPvPKvj>
    gPB[IP_TOTLEN_L_P] = 0x82;
 8002b98:	00820034 	movhi	r2,2048
 8002b9c:	109ac704 	addi	r2,r2,27420
 8002ba0:	00ffe084 	movi	r3,-126
 8002ba4:	10c00445 	stb	r3,17(r2)
    gPB[IP_PROTO_P] = IP_PROTO_UDP_V;
 8002ba8:	00820034 	movhi	r2,2048
 8002bac:	109ac704 	addi	r2,r2,27420
 8002bb0:	00c00444 	movi	r3,17
 8002bb4:	10c005c5 	stb	r3,23(r2)
    fill_ip_hdr_checksum();
 8002bb8:	80018e80 	call	80018e8 <_ZL20fill_ip_hdr_checksumv>
    gPB[UDP_DST_PORT_H_P] = 0;
 8002bbc:	00820034 	movhi	r2,2048
 8002bc0:	109ac704 	addi	r2,r2,27420
 8002bc4:	10000905 	stb	zero,36(r2)
    gPB[UDP_DST_PORT_L_P] = 0x9; // wol = normally 9
 8002bc8:	00820034 	movhi	r2,2048
 8002bcc:	109ac704 	addi	r2,r2,27420
 8002bd0:	00c00244 	movi	r3,9
 8002bd4:	10c00945 	stb	r3,37(r2)
    gPB[UDP_SRC_PORT_H_P] = 10;
 8002bd8:	00820034 	movhi	r2,2048
 8002bdc:	109ac704 	addi	r2,r2,27420
 8002be0:	00c00284 	movi	r3,10
 8002be4:	10c00885 	stb	r3,34(r2)
    gPB[UDP_SRC_PORT_L_P] = 0x42; // source port does not matter
 8002be8:	00820034 	movhi	r2,2048
 8002bec:	109ac704 	addi	r2,r2,27420
 8002bf0:	00c01084 	movi	r3,66
 8002bf4:	10c008c5 	stb	r3,35(r2)
    gPB[UDP_LEN_H_P] = 0;
 8002bf8:	00820034 	movhi	r2,2048
 8002bfc:	109ac704 	addi	r2,r2,27420
 8002c00:	10000985 	stb	zero,38(r2)
    gPB[UDP_LEN_L_P] = 110; // fixed len
 8002c04:	00820034 	movhi	r2,2048
 8002c08:	109ac704 	addi	r2,r2,27420
 8002c0c:	00c01b84 	movi	r3,110
 8002c10:	10c009c5 	stb	r3,39(r2)
    gPB[UDP_CHECKSUM_H_P] = 0;
 8002c14:	00820034 	movhi	r2,2048
 8002c18:	109ac704 	addi	r2,r2,27420
 8002c1c:	10000a05 	stb	zero,40(r2)
    gPB[UDP_CHECKSUM_L_P] = 0;
 8002c20:	00820034 	movhi	r2,2048
 8002c24:	109ac704 	addi	r2,r2,27420
 8002c28:	10000a45 	stb	zero,41(r2)
    copyMac(gPB + UDP_DATA_P, allOnes);
 8002c2c:	00820034 	movhi	r2,2048
 8002c30:	109ad184 	addi	r2,r2,27462
 8002c34:	d16002c4 	addi	r5,gp,-32757
 8002c38:	1009883a 	mov	r4,r2
 8002c3c:	8003f3c0 	call	8003f3c <_ZN9EtherCard7copyMacEPhPKh>
    uint8_t pos = UDP_DATA_P;
 8002c40:	00800a84 	movi	r2,42
 8002c44:	e0bffe05 	stb	r2,-8(fp)
    for (uint8_t m = 0; m < 16; ++m) {
 8002c48:	e03ffe45 	stb	zero,-7(fp)
 8002c4c:	e0bffe43 	ldbu	r2,-7(fp)
 8002c50:	10800428 	cmpgeui	r2,r2,16
 8002c54:	10000e1e 	bne	r2,zero,8002c90 <_ZN9EtherCard7sendWolEPh+0x150>
        pos += 6;
 8002c58:	e0bffe03 	ldbu	r2,-8(fp)
 8002c5c:	10800184 	addi	r2,r2,6
 8002c60:	e0bffe05 	stb	r2,-8(fp)
        copyMac(gPB + pos, wolmac);
 8002c64:	e0fffe03 	ldbu	r3,-8(fp)
 8002c68:	00820034 	movhi	r2,2048
 8002c6c:	109ac704 	addi	r2,r2,27420
 8002c70:	1885883a 	add	r2,r3,r2
 8002c74:	e17fff17 	ldw	r5,-4(fp)
 8002c78:	1009883a 	mov	r4,r2
 8002c7c:	8003f3c0 	call	8003f3c <_ZN9EtherCard7copyMacEPhPKh>
    gPB[UDP_LEN_L_P] = 110; // fixed len
    gPB[UDP_CHECKSUM_H_P] = 0;
    gPB[UDP_CHECKSUM_L_P] = 0;
    copyMac(gPB + UDP_DATA_P, allOnes);
    uint8_t pos = UDP_DATA_P;
    for (uint8_t m = 0; m < 16; ++m) {
 8002c80:	e0bffe43 	ldbu	r2,-7(fp)
 8002c84:	10800044 	addi	r2,r2,1
 8002c88:	e0bffe45 	stb	r2,-7(fp)
 8002c8c:	003fef06 	br	8002c4c <__alt_data_end+0xfc002c4c>
        pos += 6;
        copyMac(gPB + pos, wolmac);
    }
    fill_checksum(UDP_CHECKSUM_H_P, IP_SRC_P, 16 + 102,1);
 8002c90:	01c00044 	movi	r7,1
 8002c94:	01801d84 	movi	r6,118
 8002c98:	01400684 	movi	r5,26
 8002c9c:	01000a04 	movi	r4,40
 8002ca0:	80014480 	call	8001448 <_ZL13fill_checksumhhth>
    packetSend(pos + 6);
 8002ca4:	e0bffe03 	ldbu	r2,-8(fp)
 8002ca8:	10800184 	addi	r2,r2,6
 8002cac:	10bfffcc 	andi	r2,r2,65535
 8002cb0:	1009883a 	mov	r4,r2
 8002cb4:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 8002cb8:	0001883a 	nop
 8002cbc:	e037883a 	mov	sp,fp
 8002cc0:	dfc00117 	ldw	ra,4(sp)
 8002cc4:	df000017 	ldw	fp,0(sp)
 8002cc8:	dec00204 	addi	sp,sp,8
 8002ccc:	f800283a 	ret

08002cd0 <_ZL17client_arp_whohasPh>:

// make a arp request
static void client_arp_whohas(uint8_t *ip_we_search) {
 8002cd0:	defffd04 	addi	sp,sp,-12
 8002cd4:	dfc00215 	stw	ra,8(sp)
 8002cd8:	df000115 	stw	fp,4(sp)
 8002cdc:	df000104 	addi	fp,sp,4
 8002ce0:	e13fff15 	stw	r4,-4(fp)
    setMACs(allOnes);
 8002ce4:	d12002c4 	addi	r4,gp,-32757
 8002ce8:	80015cc0 	call	80015cc <_ZL7setMACsPKh>
    gPB[ETH_TYPE_H_P] = ETHTYPE_ARP_H_V;
 8002cec:	00820034 	movhi	r2,2048
 8002cf0:	109ac704 	addi	r2,r2,27420
 8002cf4:	00c00204 	movi	r3,8
 8002cf8:	10c00305 	stb	r3,12(r2)
    gPB[ETH_TYPE_L_P] = ETHTYPE_ARP_L_V;
 8002cfc:	00820034 	movhi	r2,2048
 8002d00:	109ac704 	addi	r2,r2,27420
 8002d04:	00c00184 	movi	r3,6
 8002d08:	10c00345 	stb	r3,13(r2)
    memcpy_P(gPB + ETH_ARP_P, arpreqhdr, sizeof arpreqhdr);
 8002d0c:	00820034 	movhi	r2,2048
 8002d10:	109aca84 	addi	r2,r2,27434
 8002d14:	01800204 	movi	r6,8
 8002d18:	d1600444 	addi	r5,gp,-32751
 8002d1c:	1009883a 	mov	r4,r2
 8002d20:	80014040 	call	8001404 <_Z8memcpy_PPvPKvj>
    memset(gPB + ETH_ARP_DST_MAC_P, 0, ETH_LEN);
 8002d24:	00820034 	movhi	r2,2048
 8002d28:	109acf04 	addi	r2,r2,27452
 8002d2c:	01800184 	movi	r6,6
 8002d30:	000b883a 	mov	r5,zero
 8002d34:	1009883a 	mov	r4,r2
 8002d38:	8004c5c0 	call	8004c5c <memset>
    EtherCard::copyMac(gPB + ETH_ARP_SRC_MAC_P, EtherCard::mymac);
 8002d3c:	00820034 	movhi	r2,2048
 8002d40:	109acc84 	addi	r2,r2,27442
 8002d44:	d1605644 	addi	r5,gp,-32423
 8002d48:	1009883a 	mov	r4,r2
 8002d4c:	8003f3c0 	call	8003f3c <_ZN9EtherCard7copyMacEPhPKh>
    EtherCard::copyIp(gPB + ETH_ARP_DST_IP_P, ip_we_search);
 8002d50:	00820034 	movhi	r2,2048
 8002d54:	109ad084 	addi	r2,r2,27458
 8002d58:	e17fff17 	ldw	r5,-4(fp)
 8002d5c:	1009883a 	mov	r4,r2
 8002d60:	8003f7c0 	call	8003f7c <_ZN9EtherCard6copyIpEPhPKh>
    EtherCard::copyIp(gPB + ETH_ARP_SRC_IP_P, EtherCard::myip);
 8002d64:	00820034 	movhi	r2,2048
 8002d68:	109ace04 	addi	r2,r2,27448
 8002d6c:	d16057c4 	addi	r5,gp,-32417
 8002d70:	1009883a 	mov	r4,r2
 8002d74:	8003f7c0 	call	8003f7c <_ZN9EtherCard6copyIpEPhPKh>
    EtherCard::packetSend(42);
 8002d78:	01000a84 	movi	r4,42
 8002d7c:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 8002d80:	0001883a 	nop
 8002d84:	e037883a 	mov	sp,fp
 8002d88:	dfc00117 	ldw	ra,4(sp)
 8002d8c:	df000017 	ldw	fp,0(sp)
 8002d90:	dec00204 	addi	sp,sp,8
 8002d94:	f800283a 	ret

08002d98 <_ZN9EtherCard15clientWaitingGwEv>:

uint8_t EtherCard::clientWaitingGw () {
 8002d98:	deffff04 	addi	sp,sp,-4
 8002d9c:	df000015 	stw	fp,0(sp)
 8002da0:	d839883a 	mov	fp,sp
    return !(waitgwmac & WGW_HAVE_GW_MAC);
 8002da4:	d0a07203 	ldbu	r2,-32312(gp)
 8002da8:	10803fcc 	andi	r2,r2,255
 8002dac:	1080008c 	andi	r2,r2,2
 8002db0:	1005003a 	cmpeq	r2,r2,zero
}
 8002db4:	e037883a 	mov	sp,fp
 8002db8:	df000017 	ldw	fp,0(sp)
 8002dbc:	dec00104 	addi	sp,sp,4
 8002dc0:	f800283a 	ret

08002dc4 <_ZN9EtherCard16clientWaitingDnsEv>:

uint8_t EtherCard::clientWaitingDns () {
 8002dc4:	defffe04 	addi	sp,sp,-8
 8002dc8:	dfc00115 	stw	ra,4(sp)
 8002dcc:	df000015 	stw	fp,0(sp)
 8002dd0:	d839883a 	mov	fp,sp
    if(is_lan(myip, dnsip))
 8002dd4:	d1605cc4 	addi	r5,gp,-32397
 8002dd8:	d12057c4 	addi	r4,gp,-32417
 8002ddc:	80016c00 	call	80016c0 <_ZL6is_lanPKhS0_>
 8002de0:	10803fcc 	andi	r2,r2,255
 8002de4:	10000326 	beq	r2,zero,8002df4 <_ZN9EtherCard16clientWaitingDnsEv+0x30>
        return !has_dns_mac;
 8002de8:	d0a06fc3 	ldbu	r2,-32321(gp)
 8002dec:	1080005c 	xori	r2,r2,1
 8002df0:	00000406 	br	8002e04 <_ZN9EtherCard16clientWaitingDnsEv+0x40>
    return !(waitgwmac & WGW_HAVE_GW_MAC);
 8002df4:	d0a07203 	ldbu	r2,-32312(gp)
 8002df8:	10803fcc 	andi	r2,r2,255
 8002dfc:	1080008c 	andi	r2,r2,2
 8002e00:	1005003a 	cmpeq	r2,r2,zero
}
 8002e04:	e037883a 	mov	sp,fp
 8002e08:	dfc00117 	ldw	ra,4(sp)
 8002e0c:	df000017 	ldw	fp,0(sp)
 8002e10:	dec00204 	addi	sp,sp,8
 8002e14:	f800283a 	ret

08002e18 <_ZL16client_store_macPhS_>:

static uint8_t client_store_mac(uint8_t *source_ip, uint8_t *mac) {
 8002e18:	defffc04 	addi	sp,sp,-16
 8002e1c:	dfc00315 	stw	ra,12(sp)
 8002e20:	df000215 	stw	fp,8(sp)
 8002e24:	df000204 	addi	fp,sp,8
 8002e28:	e13ffe15 	stw	r4,-8(fp)
 8002e2c:	e17fff15 	stw	r5,-4(fp)
    if (memcmp(gPB + ETH_ARP_SRC_IP_P, source_ip, IP_LEN) != 0)
 8002e30:	00820034 	movhi	r2,2048
 8002e34:	109ace04 	addi	r2,r2,27448
 8002e38:	01800104 	movi	r6,4
 8002e3c:	e17ffe17 	ldw	r5,-8(fp)
 8002e40:	1009883a 	mov	r4,r2
 8002e44:	8004c040 	call	8004c04 <memcmp>
 8002e48:	10000226 	beq	r2,zero,8002e54 <_ZL16client_store_macPhS_+0x3c>
        return 0;
 8002e4c:	0005883a 	mov	r2,zero
 8002e50:	00000606 	br	8002e6c <_ZL16client_store_macPhS_+0x54>
    EtherCard::copyMac(mac, gPB + ETH_ARP_SRC_MAC_P);
 8002e54:	00820034 	movhi	r2,2048
 8002e58:	109acc84 	addi	r2,r2,27442
 8002e5c:	100b883a 	mov	r5,r2
 8002e60:	e13fff17 	ldw	r4,-4(fp)
 8002e64:	8003f3c0 	call	8003f3c <_ZN9EtherCard7copyMacEPhPKh>
    return 1;
 8002e68:	00800044 	movi	r2,1
}
 8002e6c:	e037883a 	mov	sp,fp
 8002e70:	dfc00117 	ldw	ra,4(sp)
 8002e74:	df000017 	ldw	fp,0(sp)
 8002e78:	dec00204 	addi	sp,sp,8
 8002e7c:	f800283a 	ret

08002e80 <_ZN9EtherCard7setGwIpEPKh>:
// static void client_gw_arp_refresh() {
//   if (waitgwmac & WGW_HAVE_GW_MAC)
//     waitgwmac |= WGW_REFRESHING;
// }

void EtherCard::setGwIp (const uint8_t *gwipaddr) {
 8002e80:	defffd04 	addi	sp,sp,-12
 8002e84:	dfc00215 	stw	ra,8(sp)
 8002e88:	df000115 	stw	fp,4(sp)
 8002e8c:	df000104 	addi	fp,sp,4
 8002e90:	e13fff15 	stw	r4,-4(fp)
    delaycnt = 0; //request gateway ARP lookup
 8002e94:	d0205f8d 	sth	zero,-32386(gp)
    waitgwmac = WGW_INITIAL_ARP; // causes an arp request in the packet loop
 8002e98:	00800044 	movi	r2,1
 8002e9c:	d0a07205 	stb	r2,-32312(gp)
    copyIp(gwip, gwipaddr);
 8002ea0:	e17fff17 	ldw	r5,-4(fp)
 8002ea4:	d1205ac4 	addi	r4,gp,-32405
 8002ea8:	8003f7c0 	call	8003f7c <_ZN9EtherCard6copyIpEPhPKh>
}
 8002eac:	0001883a 	nop
 8002eb0:	e037883a 	mov	sp,fp
 8002eb4:	dfc00117 	ldw	ra,4(sp)
 8002eb8:	df000017 	ldw	fp,0(sp)
 8002ebc:	dec00204 	addi	sp,sp,8
 8002ec0:	f800283a 	ret

08002ec4 <_ZN9EtherCard22updateBroadcastAddressEv>:

void EtherCard::updateBroadcastAddress()
{
 8002ec4:	defffe04 	addi	sp,sp,-8
 8002ec8:	df000115 	stw	fp,4(sp)
 8002ecc:	df000104 	addi	fp,sp,4
    for(uint8_t i=0; i<IP_LEN; i++)
 8002ed0:	e03fff05 	stb	zero,-4(fp)
 8002ed4:	e0bfff03 	ldbu	r2,-4(fp)
 8002ed8:	10800128 	cmpgeui	r2,r2,4
 8002edc:	1000141e 	bne	r2,zero,8002f30 <_ZN9EtherCard22updateBroadcastAddressEv+0x6c>
        broadcastip[i] = myip[i] | ~netmask[i];
 8002ee0:	e0ffff03 	ldbu	r3,-4(fp)
 8002ee4:	e13fff03 	ldbu	r4,-4(fp)
 8002ee8:	d0a057c4 	addi	r2,gp,-32417
 8002eec:	2085883a 	add	r2,r4,r2
 8002ef0:	10800003 	ldbu	r2,0(r2)
 8002ef4:	100b883a 	mov	r5,r2
 8002ef8:	e13fff03 	ldbu	r4,-4(fp)
 8002efc:	d0a058c4 	addi	r2,gp,-32413
 8002f00:	2085883a 	add	r2,r4,r2
 8002f04:	10800003 	ldbu	r2,0(r2)
 8002f08:	0084303a 	nor	r2,zero,r2
 8002f0c:	2884b03a 	or	r2,r5,r2
 8002f10:	1009883a 	mov	r4,r2
 8002f14:	d0a059c4 	addi	r2,gp,-32409
 8002f18:	1885883a 	add	r2,r3,r2
 8002f1c:	11000005 	stb	r4,0(r2)
    copyIp(gwip, gwipaddr);
}

void EtherCard::updateBroadcastAddress()
{
    for(uint8_t i=0; i<IP_LEN; i++)
 8002f20:	e0bfff03 	ldbu	r2,-4(fp)
 8002f24:	10800044 	addi	r2,r2,1
 8002f28:	e0bfff05 	stb	r2,-4(fp)
 8002f2c:	003fe906 	br	8002ed4 <__alt_data_end+0xfc002ed4>
        broadcastip[i] = myip[i] | ~netmask[i];
}
 8002f30:	0001883a 	nop
 8002f34:	e037883a 	mov	sp,fp
 8002f38:	df000017 	ldw	fp,0(sp)
 8002f3c:	dec00104 	addi	sp,sp,4
 8002f40:	f800283a 	ret

08002f44 <_ZL10client_synhhh>:

static void client_syn(uint8_t srcport,uint8_t dstport_h,uint8_t dstport_l) {
 8002f44:	defffb04 	addi	sp,sp,-20
 8002f48:	dfc00415 	stw	ra,16(sp)
 8002f4c:	df000315 	stw	fp,12(sp)
 8002f50:	df000304 	addi	fp,sp,12
 8002f54:	2807883a 	mov	r3,r5
 8002f58:	3005883a 	mov	r2,r6
 8002f5c:	e13ffd05 	stb	r4,-12(fp)
 8002f60:	e0fffe05 	stb	r3,-8(fp)
 8002f64:	e0bfff05 	stb	r2,-4(fp)
    if(is_lan(EtherCard::myip, EtherCard::hisip)) {
 8002f68:	d1605dc4 	addi	r5,gp,-32393
 8002f6c:	d12057c4 	addi	r4,gp,-32417
 8002f70:	80016c00 	call	80016c0 <_ZL6is_lanPKhS0_>
 8002f74:	10803fcc 	andi	r2,r2,255
 8002f78:	10000426 	beq	r2,zero,8002f8c <_ZL10client_synhhh+0x48>
        setMACandIPs(destmacaddr, EtherCard::hisip);
 8002f7c:	d1605dc4 	addi	r5,gp,-32393
 8002f80:	d1206e04 	addi	r4,gp,-32328
 8002f84:	800161c0 	call	800161c <_ZL12setMACandIPsPKhS0_>
 8002f88:	00000306 	br	8002f98 <_ZL10client_synhhh+0x54>
    } else {
        setMACandIPs(gwmacaddr, EtherCard::hisip);
 8002f8c:	d1605dc4 	addi	r5,gp,-32393
 8002f90:	d1207084 	addi	r4,gp,-32318
 8002f94:	800161c0 	call	800161c <_ZL12setMACandIPsPKhS0_>
    }
    gPB[ETH_TYPE_H_P] = ETHTYPE_IP_H_V;
 8002f98:	00820034 	movhi	r2,2048
 8002f9c:	109ac704 	addi	r2,r2,27420
 8002fa0:	00c00204 	movi	r3,8
 8002fa4:	10c00305 	stb	r3,12(r2)
    gPB[ETH_TYPE_L_P] = ETHTYPE_IP_L_V;
 8002fa8:	00820034 	movhi	r2,2048
 8002fac:	109ac704 	addi	r2,r2,27420
 8002fb0:	10000345 	stb	zero,13(r2)
    memcpy_P(gPB + IP_P,iphdr,sizeof iphdr);
 8002fb4:	00820034 	movhi	r2,2048
 8002fb8:	109aca84 	addi	r2,r2,27434
 8002fbc:	01800244 	movi	r6,9
 8002fc0:	01420034 	movhi	r5,2048
 8002fc4:	29599d04 	addi	r5,r5,26228
 8002fc8:	1009883a 	mov	r4,r2
 8002fcc:	80014040 	call	8001404 <_Z8memcpy_PPvPKvj>
    gPB[IP_TOTLEN_L_P] = 44; // good for syn
 8002fd0:	00820034 	movhi	r2,2048
 8002fd4:	109ac704 	addi	r2,r2,27420
 8002fd8:	00c00b04 	movi	r3,44
 8002fdc:	10c00445 	stb	r3,17(r2)
    gPB[IP_PROTO_P] = IP_PROTO_TCP_V;
 8002fe0:	00820034 	movhi	r2,2048
 8002fe4:	109ac704 	addi	r2,r2,27420
 8002fe8:	00c00184 	movi	r3,6
 8002fec:	10c005c5 	stb	r3,23(r2)
    fill_ip_hdr_checksum();
 8002ff0:	80018e80 	call	80018e8 <_ZL20fill_ip_hdr_checksumv>
    gPB[TCP_DST_PORT_H_P] = dstport_h;
 8002ff4:	00820034 	movhi	r2,2048
 8002ff8:	109ac704 	addi	r2,r2,27420
 8002ffc:	e0fffe03 	ldbu	r3,-8(fp)
 8003000:	10c00905 	stb	r3,36(r2)
    gPB[TCP_DST_PORT_L_P] = dstport_l;
 8003004:	00820034 	movhi	r2,2048
 8003008:	109ac704 	addi	r2,r2,27420
 800300c:	e0ffff03 	ldbu	r3,-4(fp)
 8003010:	10c00945 	stb	r3,37(r2)
    gPB[TCP_SRC_PORT_H_P] = TCPCLIENT_SRC_PORT_H;
 8003014:	00820034 	movhi	r2,2048
 8003018:	109ac704 	addi	r2,r2,27420
 800301c:	00c002c4 	movi	r3,11
 8003020:	10c00885 	stb	r3,34(r2)
    gPB[TCP_SRC_PORT_L_P] = srcport; // lower 8 bit of src port
 8003024:	00820034 	movhi	r2,2048
 8003028:	109ac704 	addi	r2,r2,27420
 800302c:	e0fffd03 	ldbu	r3,-12(fp)
 8003030:	10c008c5 	stb	r3,35(r2)
    memset(gPB + TCP_SEQ_H_P, 0, 8);
 8003034:	00820034 	movhi	r2,2048
 8003038:	109ad084 	addi	r2,r2,27458
 800303c:	01800204 	movi	r6,8
 8003040:	000b883a 	mov	r5,zero
 8003044:	1009883a 	mov	r4,r2
 8003048:	8004c5c0 	call	8004c5c <memset>
    gPB[TCP_SEQ_H_P+2] = seqnum;
 800304c:	d0e00243 	ldbu	r3,-32759(gp)
 8003050:	00820034 	movhi	r2,2048
 8003054:	109ac704 	addi	r2,r2,27420
 8003058:	10c00a05 	stb	r3,40(r2)
    seqnum += 3;
 800305c:	d0a00243 	ldbu	r2,-32759(gp)
 8003060:	108000c4 	addi	r2,r2,3
 8003064:	d0a00245 	stb	r2,-32759(gp)
    gPB[TCP_HEADER_LEN_P] = 0x60; // 0x60=24 len: (0x60>>4) * 4
 8003068:	00820034 	movhi	r2,2048
 800306c:	109ac704 	addi	r2,r2,27420
 8003070:	00c01804 	movi	r3,96
 8003074:	10c00b85 	stb	r3,46(r2)
    gPB[TCP_FLAGS_P] = TCP_FLAGS_SYN_V;
 8003078:	00820034 	movhi	r2,2048
 800307c:	109ac704 	addi	r2,r2,27420
 8003080:	00c00084 	movi	r3,2
 8003084:	10c00bc5 	stb	r3,47(r2)
    gPB[TCP_WIN_SIZE] = 0x3; // 1024 = 0x400 768 = 0x300, initial window
 8003088:	00820034 	movhi	r2,2048
 800308c:	109ac704 	addi	r2,r2,27420
 8003090:	00c000c4 	movi	r3,3
 8003094:	10c00c05 	stb	r3,48(r2)
    gPB[TCP_WIN_SIZE+1] = 0x0;
 8003098:	00820034 	movhi	r2,2048
 800309c:	109ac704 	addi	r2,r2,27420
 80030a0:	10000c45 	stb	zero,49(r2)
    gPB[TCP_CHECKSUM_H_P] = 0;
 80030a4:	00820034 	movhi	r2,2048
 80030a8:	109ac704 	addi	r2,r2,27420
 80030ac:	10000c85 	stb	zero,50(r2)
    gPB[TCP_CHECKSUM_L_P] = 0;
 80030b0:	00820034 	movhi	r2,2048
 80030b4:	109ac704 	addi	r2,r2,27420
 80030b8:	10000cc5 	stb	zero,51(r2)
    gPB[TCP_CHECKSUM_L_P+1] = 0;
 80030bc:	00820034 	movhi	r2,2048
 80030c0:	109ac704 	addi	r2,r2,27420
 80030c4:	10000d05 	stb	zero,52(r2)
    gPB[TCP_CHECKSUM_L_P+2] = 0;
 80030c8:	00820034 	movhi	r2,2048
 80030cc:	109ac704 	addi	r2,r2,27420
 80030d0:	10000d45 	stb	zero,53(r2)
    gPB[TCP_OPTIONS_P] = 2;
 80030d4:	00820034 	movhi	r2,2048
 80030d8:	109ac704 	addi	r2,r2,27420
 80030dc:	00c00084 	movi	r3,2
 80030e0:	10c00d85 	stb	r3,54(r2)
    gPB[TCP_OPTIONS_P+1] = 4;
 80030e4:	00820034 	movhi	r2,2048
 80030e8:	109ac704 	addi	r2,r2,27420
 80030ec:	00c00104 	movi	r3,4
 80030f0:	10c00dc5 	stb	r3,55(r2)
    gPB[TCP_OPTIONS_P+2] = (CLIENTMSS>>8);
 80030f4:	00820034 	movhi	r2,2048
 80030f8:	109ac704 	addi	r2,r2,27420
 80030fc:	00c00084 	movi	r3,2
 8003100:	10c00e05 	stb	r3,56(r2)
    gPB[TCP_OPTIONS_P+3] = (uint8_t) CLIENTMSS;
 8003104:	00820034 	movhi	r2,2048
 8003108:	109ac704 	addi	r2,r2,27420
 800310c:	00c00984 	movi	r3,38
 8003110:	10c00e45 	stb	r3,57(r2)
    fill_checksum(TCP_CHECKSUM_H_P, IP_SRC_P, 8 +TCP_HEADER_LEN_PLAIN+4,2);
 8003114:	01c00084 	movi	r7,2
 8003118:	01800804 	movi	r6,32
 800311c:	01400684 	movi	r5,26
 8003120:	01000c84 	movi	r4,50
 8003124:	80014480 	call	8001448 <_ZL13fill_checksumhhth>
    // 4 is the tcp mss option:
    EtherCard::packetSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN+4);
 8003128:	01000e84 	movi	r4,58
 800312c:	80012880 	call	8001288 <_ZN8ENC28J6010packetSendEt>
}
 8003130:	0001883a 	nop
 8003134:	e037883a 	mov	sp,fp
 8003138:	dfc00117 	ldw	ra,4(sp)
 800313c:	df000017 	ldw	fp,0(sp)
 8003140:	dec00204 	addi	sp,sp,8
 8003144:	f800283a 	ret

08003148 <_ZN9EtherCard12clientTcpReqEPFhhhttEPFthEt>:

uint8_t EtherCard::clientTcpReq (uint8_t (*result_cb)(uint8_t,uint8_t,uint16_t,uint16_t),
                                 uint16_t (*datafill_cb)(uint8_t),uint16_t port) {
 8003148:	defffc04 	addi	sp,sp,-16
 800314c:	df000315 	stw	fp,12(sp)
 8003150:	df000304 	addi	fp,sp,12
 8003154:	e13ffd15 	stw	r4,-12(fp)
 8003158:	e17ffe15 	stw	r5,-8(fp)
 800315c:	3005883a 	mov	r2,r6
 8003160:	e0bfff0d 	sth	r2,-4(fp)
    client_tcp_result_cb = result_cb;
 8003164:	e0bffd17 	ldw	r2,-12(fp)
 8003168:	d0a06415 	stw	r2,-32368(gp)
    client_tcp_datafill_cb = datafill_cb;
 800316c:	e0bffe17 	ldw	r2,-8(fp)
 8003170:	d0a06515 	stw	r2,-32364(gp)
    tcp_client_port_h = port>>8;
 8003174:	e0bfff0b 	ldhu	r2,-4(fp)
 8003178:	1005d23a 	srai	r2,r2,8
 800317c:	d0a06385 	stb	r2,-32370(gp)
    tcp_client_port_l = port;
 8003180:	e0bfff0b 	ldhu	r2,-4(fp)
 8003184:	d0a063c5 	stb	r2,-32369(gp)
    tcp_client_state = TCP_STATE_SENDSYN; // Flag to packetloop to initiate a TCP/IP session by send a syn
 8003188:	00800044 	movi	r2,1
 800318c:	d0a06345 	stb	r2,-32371(gp)
    tcp_fd = (tcp_fd + 1) & 7;
 8003190:	d0a06303 	ldbu	r2,-32372(gp)
 8003194:	10800044 	addi	r2,r2,1
 8003198:	108001cc 	andi	r2,r2,7
 800319c:	d0a06305 	stb	r2,-32372(gp)
    return tcp_fd;
 80031a0:	d0a06303 	ldbu	r2,-32372(gp)
}
 80031a4:	e037883a 	mov	sp,fp
 80031a8:	df000017 	ldw	fp,0(sp)
 80031ac:	dec00104 	addi	sp,sp,4
 80031b0:	f800283a 	ret

080031b4 <_ZL31www_client_internal_datafill_cbh>:

static uint16_t www_client_internal_datafill_cb(uint8_t fd) {
 80031b4:	defffe04 	addi	sp,sp,-8
 80031b8:	df000115 	stw	fp,4(sp)
 80031bc:	df000104 	addi	fp,sp,4
 80031c0:	2005883a 	mov	r2,r4
 80031c4:	e0bfff05 	stb	r2,-4(fp)
    //                      strlen(client_postval),
    //                      client_postval);
    //     }
    // }
    // return bfill.position();
}
 80031c8:	0001883a 	nop
 80031cc:	e037883a 	mov	sp,fp
 80031d0:	df000017 	ldw	fp,0(sp)
 80031d4:	dec00104 	addi	sp,sp,4
 80031d8:	f800283a 	ret

080031dc <_ZL29www_client_internal_result_cbhhtt>:

static uint8_t www_client_internal_result_cb(uint8_t fd, uint8_t statuscode, uint16_t datapos, uint16_t len_of_data) {
 80031dc:	defff904 	addi	sp,sp,-28
 80031e0:	dfc00615 	stw	ra,24(sp)
 80031e4:	df000515 	stw	fp,20(sp)
 80031e8:	df000504 	addi	fp,sp,20
 80031ec:	2011883a 	mov	r8,r4
 80031f0:	2809883a 	mov	r4,r5
 80031f4:	3007883a 	mov	r3,r6
 80031f8:	3805883a 	mov	r2,r7
 80031fc:	e23ffc05 	stb	r8,-16(fp)
 8003200:	e13ffd05 	stb	r4,-12(fp)
 8003204:	e0fffe0d 	sth	r3,-8(fp)
 8003208:	e0bfff0d 	sth	r2,-4(fp)
    if (fd!=www_fd)
 800320c:	d0a06603 	ldbu	r2,-32360(gp)
 8003210:	e0fffc03 	ldbu	r3,-16(fp)
 8003214:	10803fcc 	andi	r2,r2,255
 8003218:	18800626 	beq	r3,r2,8003234 <_ZL29www_client_internal_result_cbhhtt+0x58>
        (*client_browser_cb)(4,0,0);
 800321c:	d0a06717 	ldw	r2,-32356(gp)
 8003220:	000d883a 	mov	r6,zero
 8003224:	000b883a 	mov	r5,zero
 8003228:	01000104 	movi	r4,4
 800322c:	103ee83a 	callr	r2
 8003230:	00002206 	br	80032bc <_ZL29www_client_internal_result_cbhhtt+0xe0>
    else if (statuscode==0 && len_of_data>12 && client_browser_cb) {
 8003234:	e0bffd03 	ldbu	r2,-12(fp)
 8003238:	1000201e 	bne	r2,zero,80032bc <_ZL29www_client_internal_result_cbhhtt+0xe0>
 800323c:	e0bfff0b 	ldhu	r2,-4(fp)
 8003240:	10800370 	cmpltui	r2,r2,13
 8003244:	10001d1e 	bne	r2,zero,80032bc <_ZL29www_client_internal_result_cbhhtt+0xe0>
 8003248:	d0a06717 	ldw	r2,-32356(gp)
 800324c:	10001b26 	beq	r2,zero,80032bc <_ZL29www_client_internal_result_cbhhtt+0xe0>
        uint8_t f = strncmp("200",(char *)&(gPB[datapos+9]),3) != 0;
 8003250:	e0bffe0b 	ldhu	r2,-8(fp)
 8003254:	10c00244 	addi	r3,r2,9
 8003258:	00820034 	movhi	r2,2048
 800325c:	109ac704 	addi	r2,r2,27420
 8003260:	1885883a 	add	r2,r3,r2
 8003264:	018000c4 	movi	r6,3
 8003268:	100b883a 	mov	r5,r2
 800326c:	01020034 	movhi	r4,2048
 8003270:	2119a204 	addi	r4,r4,26248
 8003274:	8004d280 	call	8004d28 <strncmp>
 8003278:	1004c03a 	cmpne	r2,r2,zero
 800327c:	e0bffb05 	stb	r2,-20(fp)
        (*client_browser_cb)(f, ((uint16_t)TCP_SRC_PORT_H_P+(gPB[TCP_HEADER_LEN_P]>>4)*4),len_of_data);
 8003280:	d0e06717 	ldw	r3,-32356(gp)
 8003284:	e13ffb03 	ldbu	r4,-20(fp)
 8003288:	00820034 	movhi	r2,2048
 800328c:	109ac704 	addi	r2,r2,27420
 8003290:	10800b83 	ldbu	r2,46(r2)
 8003294:	10803fcc 	andi	r2,r2,255
 8003298:	1005d13a 	srai	r2,r2,4
 800329c:	1085883a 	add	r2,r2,r2
 80032a0:	1085883a 	add	r2,r2,r2
 80032a4:	10800884 	addi	r2,r2,34
 80032a8:	10bfffcc 	andi	r2,r2,65535
 80032ac:	e17fff0b 	ldhu	r5,-4(fp)
 80032b0:	280d883a 	mov	r6,r5
 80032b4:	100b883a 	mov	r5,r2
 80032b8:	183ee83a 	callr	r3
    }
    return 0;
 80032bc:	0005883a 	mov	r2,zero
}
 80032c0:	e037883a 	mov	sp,fp
 80032c4:	dfc00117 	ldw	ra,4(sp)
 80032c8:	df000017 	ldw	fp,0(sp)
 80032cc:	dec00204 	addi	sp,sp,8
 80032d0:	f800283a 	ret

080032d4 <_ZN9EtherCard9browseUrlEPKcS1_S1_PFvhttE>:

void EtherCard::browseUrl (const char *urlbuf, const char *urlbuf_varpart, const char *hoststr, void (*callback)(uint8_t,uint16_t,uint16_t)) {
 80032d4:	defff904 	addi	sp,sp,-28
 80032d8:	dfc00615 	stw	ra,24(sp)
 80032dc:	df000515 	stw	fp,20(sp)
 80032e0:	df000504 	addi	fp,sp,20
 80032e4:	e13ffc15 	stw	r4,-16(fp)
 80032e8:	e17ffd15 	stw	r5,-12(fp)
 80032ec:	e1bffe15 	stw	r6,-8(fp)
 80032f0:	e1ffff15 	stw	r7,-4(fp)
    browseUrl(urlbuf, urlbuf_varpart, hoststr, PSTR("Accept: text/html"), callback);
 80032f4:	01020034 	movhi	r4,2048
 80032f8:	2119a304 	addi	r4,r4,26252
 80032fc:	80013e00 	call	80013e0 <_Z4PSTRPc>
 8003300:	1007883a 	mov	r3,r2
 8003304:	e0bfff17 	ldw	r2,-4(fp)
 8003308:	d8800015 	stw	r2,0(sp)
 800330c:	180f883a 	mov	r7,r3
 8003310:	e1bffe17 	ldw	r6,-8(fp)
 8003314:	e17ffd17 	ldw	r5,-12(fp)
 8003318:	e13ffc17 	ldw	r4,-16(fp)
 800331c:	80033380 	call	8003338 <_ZN9EtherCard9browseUrlEPKcS1_S1_S1_PFvhttE>
}
 8003320:	0001883a 	nop
 8003324:	e037883a 	mov	sp,fp
 8003328:	dfc00117 	ldw	ra,4(sp)
 800332c:	df000017 	ldw	fp,0(sp)
 8003330:	dec00204 	addi	sp,sp,8
 8003334:	f800283a 	ret

08003338 <_ZN9EtherCard9browseUrlEPKcS1_S1_S1_PFvhttE>:

void EtherCard::browseUrl (const char *urlbuf, const char *urlbuf_varpart, const char *hoststr, const char *additionalheaderline, void (*callback)(uint8_t,uint16_t,uint16_t)) {
 8003338:	defffa04 	addi	sp,sp,-24
 800333c:	dfc00515 	stw	ra,20(sp)
 8003340:	df000415 	stw	fp,16(sp)
 8003344:	df000404 	addi	fp,sp,16
 8003348:	e13ffc15 	stw	r4,-16(fp)
 800334c:	e17ffd15 	stw	r5,-12(fp)
 8003350:	e1bffe15 	stw	r6,-8(fp)
 8003354:	e1ffff15 	stw	r7,-4(fp)
    client_urlbuf = urlbuf;
 8003358:	e0bffc17 	ldw	r2,-16(fp)
 800335c:	d0a06a15 	stw	r2,-32344(gp)
    client_urlbuf_var = urlbuf_varpart;
 8003360:	e0bffd17 	ldw	r2,-12(fp)
 8003364:	d0a06b15 	stw	r2,-32340(gp)
    client_hoststr = hoststr;
 8003368:	e0bffe17 	ldw	r2,-8(fp)
 800336c:	d0a06c15 	stw	r2,-32336(gp)
    client_additionalheaderline = additionalheaderline;
 8003370:	e0bfff17 	ldw	r2,-4(fp)
 8003374:	d0a06815 	stw	r2,-32352(gp)
    client_postval = 0;
 8003378:	d0206915 	stw	zero,-32348(gp)
    client_browser_cb = callback;
 800337c:	e0800217 	ldw	r2,8(fp)
 8003380:	d0a06715 	stw	r2,-32356(gp)
    www_fd = clientTcpReq(&www_client_internal_result_cb,&www_client_internal_datafill_cb,hisport);
 8003384:	d0a0000b 	ldhu	r2,-32768(gp)
 8003388:	10bfffcc 	andi	r2,r2,65535
 800338c:	100d883a 	mov	r6,r2
 8003390:	01420034 	movhi	r5,2048
 8003394:	294c6d04 	addi	r5,r5,12724
 8003398:	01020034 	movhi	r4,2048
 800339c:	210c7704 	addi	r4,r4,12764
 80033a0:	80031480 	call	8003148 <_ZN9EtherCard12clientTcpReqEPFhhhttEPFthEt>
 80033a4:	d0a06605 	stb	r2,-32360(gp)
}
 80033a8:	0001883a 	nop
 80033ac:	e037883a 	mov	sp,fp
 80033b0:	dfc00117 	ldw	ra,4(sp)
 80033b4:	df000017 	ldw	fp,0(sp)
 80033b8:	dec00204 	addi	sp,sp,8
 80033bc:	f800283a 	ret

080033c0 <_ZN9EtherCard8httpPostEPKcS1_S1_S1_PFvhttE>:

void EtherCard::httpPost (const char *urlbuf, const char *hoststr, const char *additionalheaderline, const char *postval, void (*callback)(uint8_t,uint16_t,uint16_t)) {
 80033c0:	defffa04 	addi	sp,sp,-24
 80033c4:	dfc00515 	stw	ra,20(sp)
 80033c8:	df000415 	stw	fp,16(sp)
 80033cc:	df000404 	addi	fp,sp,16
 80033d0:	e13ffc15 	stw	r4,-16(fp)
 80033d4:	e17ffd15 	stw	r5,-12(fp)
 80033d8:	e1bffe15 	stw	r6,-8(fp)
 80033dc:	e1ffff15 	stw	r7,-4(fp)
    client_urlbuf = urlbuf;
 80033e0:	e0bffc17 	ldw	r2,-16(fp)
 80033e4:	d0a06a15 	stw	r2,-32344(gp)
    client_hoststr = hoststr;
 80033e8:	e0bffd17 	ldw	r2,-12(fp)
 80033ec:	d0a06c15 	stw	r2,-32336(gp)
    client_additionalheaderline = additionalheaderline;
 80033f0:	e0bffe17 	ldw	r2,-8(fp)
 80033f4:	d0a06815 	stw	r2,-32352(gp)
    client_postval = postval;
 80033f8:	e0bfff17 	ldw	r2,-4(fp)
 80033fc:	d0a06915 	stw	r2,-32348(gp)
    client_browser_cb = callback;
 8003400:	e0800217 	ldw	r2,8(fp)
 8003404:	d0a06715 	stw	r2,-32356(gp)
    www_fd = clientTcpReq(&www_client_internal_result_cb,&www_client_internal_datafill_cb,hisport);
 8003408:	d0a0000b 	ldhu	r2,-32768(gp)
 800340c:	10bfffcc 	andi	r2,r2,65535
 8003410:	100d883a 	mov	r6,r2
 8003414:	01420034 	movhi	r5,2048
 8003418:	294c6d04 	addi	r5,r5,12724
 800341c:	01020034 	movhi	r4,2048
 8003420:	210c7704 	addi	r4,r4,12764
 8003424:	80031480 	call	8003148 <_ZN9EtherCard12clientTcpReqEPFhhhttEPFthEt>
 8003428:	d0a06605 	stb	r2,-32360(gp)
}
 800342c:	0001883a 	nop
 8003430:	e037883a 	mov	sp,fp
 8003434:	dfc00117 	ldw	ra,4(sp)
 8003438:	df000017 	ldw	fp,0(sp)
 800343c:	dec00204 	addi	sp,sp,8
 8003440:	f800283a 	ret

08003444 <_ZL15tcp_datafill_cbh>:

static uint16_t tcp_datafill_cb(uint8_t fd) {
 8003444:	defffe04 	addi	sp,sp,-8
 8003448:	df000115 	stw	fp,4(sp)
 800344c:	df000104 	addi	fp,sp,4
 8003450:	2005883a 	mov	r2,r4
 8003454:	e0bfff05 	stb	r2,-4(fp)
//     Serial.println(len);
//     Serial.println((char*) EtherCard::tcpOffset());
// #endif
//     result_fd = 123; // bogus value
//     return len;
}
 8003458:	0001883a 	nop
 800345c:	e037883a 	mov	sp,fp
 8003460:	df000017 	ldw	fp,0(sp)
 8003464:	dec00104 	addi	sp,sp,4
 8003468:	f800283a 	ret

0800346c <_ZL13tcp_result_cbhhtt>:

static uint8_t tcp_result_cb(uint8_t fd, uint8_t status, uint16_t datapos, uint16_t datalen) {
 800346c:	defffb04 	addi	sp,sp,-20
 8003470:	df000415 	stw	fp,16(sp)
 8003474:	df000404 	addi	fp,sp,16
 8003478:	2011883a 	mov	r8,r4
 800347c:	2809883a 	mov	r4,r5
 8003480:	3007883a 	mov	r3,r6
 8003484:	3805883a 	mov	r2,r7
 8003488:	e23ffc05 	stb	r8,-16(fp)
 800348c:	e13ffd05 	stb	r4,-12(fp)
 8003490:	e0fffe0d 	sth	r3,-8(fp)
 8003494:	e0bfff0d 	sth	r2,-4(fp)
    if (status == 0) {
 8003498:	e0bffd03 	ldbu	r2,-12(fp)
 800349c:	1000071e 	bne	r2,zero,80034bc <_ZL13tcp_result_cbhhtt+0x50>
        result_fd = fd; // a valid result has been received, remember its session id
 80034a0:	e0bffc03 	ldbu	r2,-16(fp)
 80034a4:	d0a00285 	stb	r2,-32758(gp)
        result_ptr = (char*) ether.buffer + datapos;
 80034a8:	e0fffe0b 	ldhu	r3,-8(fp)
 80034ac:	00820034 	movhi	r2,2048
 80034b0:	109ac704 	addi	r2,r2,27420
 80034b4:	1885883a 	add	r2,r3,r2
 80034b8:	d0a07315 	stw	r2,-32308(gp)
        // result_ptr[datalen] = 0;
    }
    return 1;
 80034bc:	00800044 	movi	r2,1
}
 80034c0:	e037883a 	mov	sp,fp
 80034c4:	df000017 	ldw	fp,0(sp)
 80034c8:	dec00104 	addi	sp,sp,4
 80034cc:	f800283a 	ret

080034d0 <_ZN9EtherCard7tcpSendEv>:

uint8_t EtherCard::tcpSend () {
 80034d0:	defffe04 	addi	sp,sp,-8
 80034d4:	dfc00115 	stw	ra,4(sp)
 80034d8:	df000015 	stw	fp,0(sp)
 80034dc:	d839883a 	mov	fp,sp
    www_fd = clientTcpReq(&tcp_result_cb, &tcp_datafill_cb, hisport);
 80034e0:	d0a0000b 	ldhu	r2,-32768(gp)
 80034e4:	10bfffcc 	andi	r2,r2,65535
 80034e8:	100d883a 	mov	r6,r2
 80034ec:	01420034 	movhi	r5,2048
 80034f0:	294d1104 	addi	r5,r5,13380
 80034f4:	01020034 	movhi	r4,2048
 80034f8:	210d1b04 	addi	r4,r4,13420
 80034fc:	80031480 	call	8003148 <_ZN9EtherCard12clientTcpReqEPFhhhttEPFthEt>
 8003500:	d0a06605 	stb	r2,-32360(gp)
    return www_fd;
 8003504:	d0a06603 	ldbu	r2,-32360(gp)
}
 8003508:	e037883a 	mov	sp,fp
 800350c:	dfc00117 	ldw	ra,4(sp)
 8003510:	df000017 	ldw	fp,0(sp)
 8003514:	dec00204 	addi	sp,sp,8
 8003518:	f800283a 	ret

0800351c <_ZN9EtherCard8tcpReplyEh>:

const char* EtherCard::tcpReply (uint8_t fd) {
 800351c:	defffe04 	addi	sp,sp,-8
 8003520:	df000115 	stw	fp,4(sp)
 8003524:	df000104 	addi	fp,sp,4
 8003528:	2005883a 	mov	r2,r4
 800352c:	e0bfff05 	stb	r2,-4(fp)
    if (result_fd != fd)
 8003530:	d0a00283 	ldbu	r2,-32758(gp)
 8003534:	10c03fcc 	andi	r3,r2,255
 8003538:	e0bfff03 	ldbu	r2,-4(fp)
 800353c:	18800226 	beq	r3,r2,8003548 <_ZN9EtherCard8tcpReplyEh+0x2c>
        return 0;
 8003540:	0005883a 	mov	r2,zero
 8003544:	00000306 	br	8003554 <_ZN9EtherCard8tcpReplyEh+0x38>
    result_fd = 123; // set to a bogus value to prevent future match
 8003548:	00801ec4 	movi	r2,123
 800354c:	d0a00285 	stb	r2,-32758(gp)
    return result_ptr;
 8003550:	d0a07317 	ldw	r2,-32308(gp)
}
 8003554:	e037883a 	mov	sp,fp
 8003558:	df000017 	ldw	fp,0(sp)
 800355c:	dec00104 	addi	sp,sp,4
 8003560:	f800283a 	ret

08003564 <_ZN9EtherCard20registerPingCallbackEPFvPhE>:

void EtherCard::registerPingCallback (void (*callback)(uint8_t *srcip)) {
 8003564:	defffe04 	addi	sp,sp,-8
 8003568:	df000115 	stw	fp,4(sp)
 800356c:	df000104 	addi	fp,sp,4
 8003570:	e13fff15 	stw	r4,-4(fp)
    icmp_cb = callback;
 8003574:	e0bfff17 	ldw	r2,-4(fp)
 8003578:	d0a06d15 	stw	r2,-32332(gp)
}
 800357c:	0001883a 	nop
 8003580:	e037883a 	mov	sp,fp
 8003584:	df000017 	ldw	fp,0(sp)
 8003588:	dec00104 	addi	sp,sp,4
 800358c:	f800283a 	ret

08003590 <_ZN9EtherCard24packetLoopIcmpCheckReplyEPKh>:

uint8_t EtherCard::packetLoopIcmpCheckReply (const uint8_t *ip_monitoredhost) {
 8003590:	defffd04 	addi	sp,sp,-12
 8003594:	dfc00215 	stw	ra,8(sp)
 8003598:	df000115 	stw	fp,4(sp)
 800359c:	df000104 	addi	fp,sp,4
 80035a0:	e13fff15 	stw	r4,-4(fp)
    return gPB[IP_PROTO_P]==IP_PROTO_ICMP_V &&
 80035a4:	00820034 	movhi	r2,2048
 80035a8:	109ac704 	addi	r2,r2,27420
 80035ac:	108005c3 	ldbu	r2,23(r2)
           gPB[ICMP_TYPE_P]==ICMP_TYPE_ECHOREPLY_V &&
           gPB[ICMP_DATA_P]== PINGPATTERN &&
 80035b0:	10803fcc 	andi	r2,r2,255
 80035b4:	10800058 	cmpnei	r2,r2,1
 80035b8:	1000111e 	bne	r2,zero,8003600 <_ZN9EtherCard24packetLoopIcmpCheckReplyEPKh+0x70>
    icmp_cb = callback;
}

uint8_t EtherCard::packetLoopIcmpCheckReply (const uint8_t *ip_monitoredhost) {
    return gPB[IP_PROTO_P]==IP_PROTO_ICMP_V &&
           gPB[ICMP_TYPE_P]==ICMP_TYPE_ECHOREPLY_V &&
 80035bc:	00820034 	movhi	r2,2048
 80035c0:	109ac704 	addi	r2,r2,27420
 80035c4:	10800883 	ldbu	r2,34(r2)
void EtherCard::registerPingCallback (void (*callback)(uint8_t *srcip)) {
    icmp_cb = callback;
}

uint8_t EtherCard::packetLoopIcmpCheckReply (const uint8_t *ip_monitoredhost) {
    return gPB[IP_PROTO_P]==IP_PROTO_ICMP_V &&
 80035c8:	10803fcc 	andi	r2,r2,255
 80035cc:	10000c1e 	bne	r2,zero,8003600 <_ZN9EtherCard24packetLoopIcmpCheckReplyEPKh+0x70>
           gPB[ICMP_TYPE_P]==ICMP_TYPE_ECHOREPLY_V &&
           gPB[ICMP_DATA_P]== PINGPATTERN &&
 80035d0:	00820034 	movhi	r2,2048
 80035d4:	109ac704 	addi	r2,r2,27420
 80035d8:	10800a83 	ldbu	r2,42(r2)
    icmp_cb = callback;
}

uint8_t EtherCard::packetLoopIcmpCheckReply (const uint8_t *ip_monitoredhost) {
    return gPB[IP_PROTO_P]==IP_PROTO_ICMP_V &&
           gPB[ICMP_TYPE_P]==ICMP_TYPE_ECHOREPLY_V &&
 80035dc:	10803fcc 	andi	r2,r2,255
 80035e0:	10801098 	cmpnei	r2,r2,66
 80035e4:	1000061e 	bne	r2,zero,8003600 <_ZN9EtherCard24packetLoopIcmpCheckReplyEPKh+0x70>
           gPB[ICMP_DATA_P]== PINGPATTERN &&
           check_ip_message_is_from(ip_monitoredhost);
 80035e8:	e13fff17 	ldw	r4,-4(fp)
 80035ec:	800167c0 	call	800167c <_ZL24check_ip_message_is_fromPKh>
}

uint8_t EtherCard::packetLoopIcmpCheckReply (const uint8_t *ip_monitoredhost) {
    return gPB[IP_PROTO_P]==IP_PROTO_ICMP_V &&
           gPB[ICMP_TYPE_P]==ICMP_TYPE_ECHOREPLY_V &&
           gPB[ICMP_DATA_P]== PINGPATTERN &&
 80035f0:	10803fcc 	andi	r2,r2,255
 80035f4:	10000226 	beq	r2,zero,8003600 <_ZN9EtherCard24packetLoopIcmpCheckReplyEPKh+0x70>
 80035f8:	00800044 	movi	r2,1
 80035fc:	00000106 	br	8003604 <_ZN9EtherCard24packetLoopIcmpCheckReplyEPKh+0x74>
 8003600:	0005883a 	mov	r2,zero
           check_ip_message_is_from(ip_monitoredhost);
}
 8003604:	e037883a 	mov	sp,fp
 8003608:	dfc00117 	ldw	ra,4(sp)
 800360c:	df000017 	ldw	fp,0(sp)
 8003610:	dec00204 	addi	sp,sp,8
 8003614:	f800283a 	ret

08003618 <_ZN9EtherCard6acceptEtt>:

uint16_t EtherCard::accept(const uint16_t port, uint16_t plen) {
 8003618:	defffb04 	addi	sp,sp,-20
 800361c:	dfc00415 	stw	ra,16(sp)
 8003620:	df000315 	stw	fp,12(sp)
 8003624:	df000304 	addi	fp,sp,12
 8003628:	2007883a 	mov	r3,r4
 800362c:	2805883a 	mov	r2,r5
 8003630:	e0fffe0d 	sth	r3,-8(fp)
 8003634:	e0bfff0d 	sth	r2,-4(fp)
    uint16_t pos;

    if (gPB[TCP_DST_PORT_H_P] == (port >> 8) &&
 8003638:	00820034 	movhi	r2,2048
 800363c:	109ac704 	addi	r2,r2,27420
 8003640:	10800903 	ldbu	r2,36(r2)
 8003644:	10c03fcc 	andi	r3,r2,255
 8003648:	e0bffe0b 	ldhu	r2,-8(fp)
 800364c:	1005d23a 	srai	r2,r2,8
 8003650:	1880321e 	bne	r3,r2,800371c <_ZN9EtherCard6acceptEtt+0x104>
            gPB[TCP_DST_PORT_L_P] == ((uint8_t) port))
 8003654:	00820034 	movhi	r2,2048
 8003658:	109ac704 	addi	r2,r2,27420
 800365c:	10800943 	ldbu	r2,37(r2)
 8003660:	e0fffe0b 	ldhu	r3,-8(fp)
 8003664:	1809883a 	mov	r4,r3
}

uint16_t EtherCard::accept(const uint16_t port, uint16_t plen) {
    uint16_t pos;

    if (gPB[TCP_DST_PORT_H_P] == (port >> 8) &&
 8003668:	10c03fcc 	andi	r3,r2,255
 800366c:	20803fcc 	andi	r2,r4,255
 8003670:	18802a1e 	bne	r3,r2,800371c <_ZN9EtherCard6acceptEtt+0x104>
            gPB[TCP_DST_PORT_L_P] == ((uint8_t) port))
    {   //Packet targeted at specified port
        if (gPB[TCP_FLAGS_P] & TCP_FLAGS_SYN_V)
 8003674:	00820034 	movhi	r2,2048
 8003678:	109ac704 	addi	r2,r2,27420
 800367c:	10800bc3 	ldbu	r2,47(r2)
 8003680:	10803fcc 	andi	r2,r2,255
 8003684:	1080008c 	andi	r2,r2,2
 8003688:	10000226 	beq	r2,zero,8003694 <_ZN9EtherCard6acceptEtt+0x7c>
            make_tcp_synack_from_syn(); //send SYN+ACK
 800368c:	8001e980 	call	8001e98 <_ZL24make_tcp_synack_from_synv>
 8003690:	00002206 	br	800371c <_ZN9EtherCard6acceptEtt+0x104>
        else if (gPB[TCP_FLAGS_P] & TCP_FLAGS_ACK_V)
 8003694:	00820034 	movhi	r2,2048
 8003698:	109ac704 	addi	r2,r2,27420
 800369c:	10800bc3 	ldbu	r2,47(r2)
 80036a0:	10803fcc 	andi	r2,r2,255
 80036a4:	1080040c 	andi	r2,r2,16
 80036a8:	10001c26 	beq	r2,zero,800371c <_ZN9EtherCard6acceptEtt+0x104>
        {   //This is an acknowledgement to our SYN+ACK so let's start processing that payload
            info_data_len = getTcpPayloadLength();
 80036ac:	8001fc40 	call	8001fc4 <_ZN9EtherCard19getTcpPayloadLengthEv>
 80036b0:	d0a0728d 	sth	r2,-32310(gp)
            if (info_data_len > 0)
 80036b4:	d0a0728b 	ldhu	r2,-32310(gp)
 80036b8:	10bfffcc 	andi	r2,r2,65535
 80036bc:	10000e26 	beq	r2,zero,80036f8 <_ZN9EtherCard6acceptEtt+0xe0>
            {   //Got some data
                pos = TCP_DATA_START; // TCP_DATA_START is a formula
 80036c0:	00820034 	movhi	r2,2048
 80036c4:	109ac704 	addi	r2,r2,27420
 80036c8:	10800b83 	ldbu	r2,46(r2)
 80036cc:	10803fcc 	andi	r2,r2,255
 80036d0:	1005d13a 	srai	r2,r2,4
 80036d4:	1085883a 	add	r2,r2,r2
 80036d8:	1085883a 	add	r2,r2,r2
 80036dc:	10800884 	addi	r2,r2,34
 80036e0:	e0bffd0d 	sth	r2,-12(fp)
                //!@todo no idea what this check pos<=plen-8 does; changed this to pos<=plen as otw. perfectly valid tcp packets are ignored; still if anybody has any idea please leave a comment
                if (pos <= plen)
 80036e4:	e0bffd0b 	ldhu	r2,-12(fp)
 80036e8:	e0ffff0b 	ldhu	r3,-4(fp)
 80036ec:	18800b36 	bltu	r3,r2,800371c <_ZN9EtherCard6acceptEtt+0x104>
                    return pos;
 80036f0:	e0bffd0b 	ldhu	r2,-12(fp)
 80036f4:	00000a06 	br	8003720 <_ZN9EtherCard6acceptEtt+0x108>
            }
            else if (gPB[TCP_FLAGS_P] & TCP_FLAGS_FIN_V)
 80036f8:	00820034 	movhi	r2,2048
 80036fc:	109ac704 	addi	r2,r2,27420
 8003700:	10800bc3 	ldbu	r2,47(r2)
 8003704:	10803fcc 	andi	r2,r2,255
 8003708:	1080004c 	andi	r2,r2,1
 800370c:	10000326 	beq	r2,zero,800371c <_ZN9EtherCard6acceptEtt+0x104>
                make_tcp_ack_from_any(0,0); //No data so close connection
 8003710:	000b883a 	mov	r5,zero
 8003714:	0009883a 	mov	r4,zero
 8003718:	80020540 	call	8002054 <_ZL21make_tcp_ack_from_anysh>
        }
    }
    return 0;
 800371c:	0005883a 	mov	r2,zero
}
 8003720:	e037883a 	mov	sp,fp
 8003724:	dfc00117 	ldw	ra,4(sp)
 8003728:	df000017 	ldw	fp,0(sp)
 800372c:	dec00204 	addi	sp,sp,8
 8003730:	f800283a 	ret

08003734 <_ZN9EtherCard10packetLoopEt>:

uint16_t EtherCard::packetLoop (uint16_t plen) {
 8003734:	defffb04 	addi	sp,sp,-20
 8003738:	dfc00415 	stw	ra,16(sp)
 800373c:	df000315 	stw	fp,12(sp)
 8003740:	df000304 	addi	fp,sp,12
 8003744:	2005883a 	mov	r2,r4
 8003748:	e0bfff0d 	sth	r2,-4(fp)
    if(using_dhcp) {
        ether.DhcpStateMachine(plen);
    }
#endif

    if (plen==0) {
 800374c:	e0bfff0b 	ldhu	r2,-4(fp)
 8003750:	1000661e 	bne	r2,zero,80038ec <_ZN9EtherCard10packetLoopEt+0x1b8>
        //Check every 65536 (no-packet) cycles whether we need to retry ARP request for gateway
        if ((waitgwmac & WGW_INITIAL_ARP || waitgwmac & WGW_REFRESHING) &&
 8003754:	d0a07203 	ldbu	r2,-32312(gp)
 8003758:	10803fcc 	andi	r2,r2,255
 800375c:	1080004c 	andi	r2,r2,1
                delaycnt==0 && isLinkUp()) {
 8003760:	1000041e 	bne	r2,zero,8003774 <_ZN9EtherCard10packetLoopEt+0x40>
    }
#endif

    if (plen==0) {
        //Check every 65536 (no-packet) cycles whether we need to retry ARP request for gateway
        if ((waitgwmac & WGW_INITIAL_ARP || waitgwmac & WGW_REFRESHING) &&
 8003764:	d0a07203 	ldbu	r2,-32312(gp)
 8003768:	10803fcc 	andi	r2,r2,255
 800376c:	1080010c 	andi	r2,r2,4
 8003770:	10000826 	beq	r2,zero,8003794 <_ZN9EtherCard10packetLoopEt+0x60>
                delaycnt==0 && isLinkUp()) {
 8003774:	d0a05f8b 	ldhu	r2,-32386(gp)
    }
#endif

    if (plen==0) {
        //Check every 65536 (no-packet) cycles whether we need to retry ARP request for gateway
        if ((waitgwmac & WGW_INITIAL_ARP || waitgwmac & WGW_REFRESHING) &&
 8003778:	10bfffcc 	andi	r2,r2,65535
 800377c:	1000051e 	bne	r2,zero,8003794 <_ZN9EtherCard10packetLoopEt+0x60>
                delaycnt==0 && isLinkUp()) {
 8003780:	80010240 	call	8001024 <_ZN8ENC28J608isLinkUpEv>
 8003784:	10803fcc 	andi	r2,r2,255
 8003788:	10000226 	beq	r2,zero,8003794 <_ZN9EtherCard10packetLoopEt+0x60>
 800378c:	00800044 	movi	r2,1
 8003790:	00000106 	br	8003798 <_ZN9EtherCard10packetLoopEt+0x64>
 8003794:	0005883a 	mov	r2,zero
    }
#endif

    if (plen==0) {
        //Check every 65536 (no-packet) cycles whether we need to retry ARP request for gateway
        if ((waitgwmac & WGW_INITIAL_ARP || waitgwmac & WGW_REFRESHING) &&
 8003798:	10803fcc 	andi	r2,r2,255
 800379c:	10000526 	beq	r2,zero,80037b4 <_ZN9EtherCard10packetLoopEt+0x80>
                delaycnt==0 && isLinkUp()) {
            client_arp_whohas(gwip);
 80037a0:	d1205ac4 	addi	r4,gp,-32405
 80037a4:	8002cd00 	call	8002cd0 <_ZL17client_arp_whohasPh>
            waitgwmac |= WGW_ACCEPT_ARP_REPLY;
 80037a8:	d0a07203 	ldbu	r2,-32312(gp)
 80037ac:	10800214 	ori	r2,r2,8
 80037b0:	d0a07205 	stb	r2,-32312(gp)
        }
        delaycnt++;
 80037b4:	d0a05f8b 	ldhu	r2,-32386(gp)
 80037b8:	10800044 	addi	r2,r2,1
 80037bc:	d0a05f8d 	sth	r2,-32386(gp)

#if ETHERCARD_TCPCLIENT
        //Initiate TCP/IP session if pending
        if (tcp_client_state==TCP_STATE_SENDSYN && (waitgwmac & WGW_HAVE_GW_MAC)) { // send a syn
 80037c0:	d0a06343 	ldbu	r2,-32371(gp)
 80037c4:	10803fcc 	andi	r2,r2,255
 80037c8:	10800058 	cmpnei	r2,r2,1
 80037cc:	1000191e 	bne	r2,zero,8003834 <_ZN9EtherCard10packetLoopEt+0x100>
 80037d0:	d0a07203 	ldbu	r2,-32312(gp)
 80037d4:	10803fcc 	andi	r2,r2,255
 80037d8:	1080008c 	andi	r2,r2,2
 80037dc:	10001526 	beq	r2,zero,8003834 <_ZN9EtherCard10packetLoopEt+0x100>
            tcp_client_state = TCP_STATE_SYNSENT;
 80037e0:	00800084 	movi	r2,2
 80037e4:	d0a06345 	stb	r2,-32371(gp)
            tcpclient_src_port_l++; // allocate a new port
 80037e8:	d0a00203 	ldbu	r2,-32760(gp)
 80037ec:	10800044 	addi	r2,r2,1
 80037f0:	d0a00205 	stb	r2,-32760(gp)
            client_syn(((tcp_fd<<5) | (0x1f & tcpclient_src_port_l)),tcp_client_port_h,tcp_client_port_l);
 80037f4:	d0a06303 	ldbu	r2,-32372(gp)
 80037f8:	10803fcc 	andi	r2,r2,255
 80037fc:	1004917a 	slli	r2,r2,5
 8003800:	1007883a 	mov	r3,r2
 8003804:	d0a00203 	ldbu	r2,-32760(gp)
 8003808:	108007cc 	andi	r2,r2,31
 800380c:	1884b03a 	or	r2,r3,r2
 8003810:	10803fcc 	andi	r2,r2,255
 8003814:	d0e06383 	ldbu	r3,-32370(gp)
 8003818:	18c03fcc 	andi	r3,r3,255
 800381c:	d12063c3 	ldbu	r4,-32369(gp)
 8003820:	21003fcc 	andi	r4,r4,255
 8003824:	200d883a 	mov	r6,r4
 8003828:	180b883a 	mov	r5,r3
 800382c:	1009883a 	mov	r4,r2
 8003830:	8002f440 	call	8002f44 <_ZL10client_synhhh>
        }
#endif

        //!@todo this is trying to find mac only once. Need some timeout to make another call if first one doesn't succeed.
        if(is_lan(myip, dnsip) && !has_dns_mac && !waiting_for_dns_mac) {
 8003834:	d1605cc4 	addi	r5,gp,-32397
 8003838:	d12057c4 	addi	r4,gp,-32417
 800383c:	80016c00 	call	80016c0 <_ZL6is_lanPKhS0_>
 8003840:	10803fcc 	andi	r2,r2,255
 8003844:	10000a26 	beq	r2,zero,8003870 <_ZN9EtherCard10packetLoopEt+0x13c>
 8003848:	d0a06fc3 	ldbu	r2,-32321(gp)
 800384c:	1080005c 	xori	r2,r2,1
 8003850:	10803fcc 	andi	r2,r2,255
 8003854:	10000626 	beq	r2,zero,8003870 <_ZN9EtherCard10packetLoopEt+0x13c>
 8003858:	d0a06f83 	ldbu	r2,-32322(gp)
 800385c:	1080005c 	xori	r2,r2,1
 8003860:	10803fcc 	andi	r2,r2,255
 8003864:	10000226 	beq	r2,zero,8003870 <_ZN9EtherCard10packetLoopEt+0x13c>
 8003868:	00800044 	movi	r2,1
 800386c:	00000106 	br	8003874 <_ZN9EtherCard10packetLoopEt+0x140>
 8003870:	0005883a 	mov	r2,zero
 8003874:	10803fcc 	andi	r2,r2,255
 8003878:	10000426 	beq	r2,zero,800388c <_ZN9EtherCard10packetLoopEt+0x158>
            client_arp_whohas(dnsip);
 800387c:	d1205cc4 	addi	r4,gp,-32397
 8003880:	8002cd00 	call	8002cd0 <_ZL17client_arp_whohasPh>
            waiting_for_dns_mac = true;
 8003884:	00800044 	movi	r2,1
 8003888:	d0a06f85 	stb	r2,-32322(gp)
        }

        //!@todo this is trying to find mac only once. Need some timeout to make another call if first one doesn't succeed.
        if(is_lan(myip, hisip) && !has_dest_mac && !waiting_for_dest_mac) {
 800388c:	d1605dc4 	addi	r5,gp,-32393
 8003890:	d12057c4 	addi	r4,gp,-32417
 8003894:	80016c00 	call	80016c0 <_ZL6is_lanPKhS0_>
 8003898:	10803fcc 	andi	r2,r2,255
 800389c:	10000a26 	beq	r2,zero,80038c8 <_ZN9EtherCard10packetLoopEt+0x194>
 80038a0:	d0a07043 	ldbu	r2,-32319(gp)
 80038a4:	1080005c 	xori	r2,r2,1
 80038a8:	10803fcc 	andi	r2,r2,255
 80038ac:	10000626 	beq	r2,zero,80038c8 <_ZN9EtherCard10packetLoopEt+0x194>
 80038b0:	d0a07003 	ldbu	r2,-32320(gp)
 80038b4:	1080005c 	xori	r2,r2,1
 80038b8:	10803fcc 	andi	r2,r2,255
 80038bc:	10000226 	beq	r2,zero,80038c8 <_ZN9EtherCard10packetLoopEt+0x194>
 80038c0:	00800044 	movi	r2,1
 80038c4:	00000106 	br	80038cc <_ZN9EtherCard10packetLoopEt+0x198>
 80038c8:	0005883a 	mov	r2,zero
 80038cc:	10803fcc 	andi	r2,r2,255
 80038d0:	10000426 	beq	r2,zero,80038e4 <_ZN9EtherCard10packetLoopEt+0x1b0>
            client_arp_whohas(hisip);
 80038d4:	d1205dc4 	addi	r4,gp,-32393
 80038d8:	8002cd00 	call	8002cd0 <_ZL17client_arp_whohasPh>
            waiting_for_dest_mac = true;
 80038dc:	00800044 	movi	r2,1
 80038e0:	d0a07005 	stb	r2,-32320(gp)
        }

        return 0;
 80038e4:	0005883a 	mov	r2,zero
 80038e8:	00014e06 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>
    }

    if (eth_type_is_arp_and_my_ip(plen))
 80038ec:	e0bfff0b 	ldhu	r2,-4(fp)
 80038f0:	1009883a 	mov	r4,r2
 80038f4:	800177c0 	call	800177c <_ZL25eth_type_is_arp_and_my_ipt>
 80038f8:	10803fcc 	andi	r2,r2,255
 80038fc:	1004c03a 	cmpne	r2,r2,zero
 8003900:	10803fcc 	andi	r2,r2,255
 8003904:	10004726 	beq	r2,zero,8003a24 <_ZN9EtherCard10packetLoopEt+0x2f0>
    {   //Service ARP request
        if (gPB[ETH_ARP_OPCODE_L_P]==ETH_ARP_OPCODE_REQ_L_V)
 8003908:	00820034 	movhi	r2,2048
 800390c:	109ac704 	addi	r2,r2,27420
 8003910:	10800543 	ldbu	r2,21(r2)
 8003914:	10803fcc 	andi	r2,r2,255
 8003918:	10800058 	cmpnei	r2,r2,1
 800391c:	1000011e 	bne	r2,zero,8003924 <_ZN9EtherCard10packetLoopEt+0x1f0>
            make_arp_answer_from_request();
 8003920:	8001bb80 	call	8001bb8 <_ZL28make_arp_answer_from_requestv>
        if (waitgwmac & WGW_ACCEPT_ARP_REPLY && (gPB[ETH_ARP_OPCODE_L_P]==ETH_ARP_OPCODE_REPLY_L_V) && client_store_mac(gwip, gwmacaddr))
 8003924:	d0a07203 	ldbu	r2,-32312(gp)
 8003928:	10803fcc 	andi	r2,r2,255
 800392c:	1080020c 	andi	r2,r2,8
 8003930:	10000d26 	beq	r2,zero,8003968 <_ZN9EtherCard10packetLoopEt+0x234>
 8003934:	00820034 	movhi	r2,2048
 8003938:	109ac704 	addi	r2,r2,27420
 800393c:	10800543 	ldbu	r2,21(r2)
 8003940:	10803fcc 	andi	r2,r2,255
 8003944:	10800098 	cmpnei	r2,r2,2
 8003948:	1000071e 	bne	r2,zero,8003968 <_ZN9EtherCard10packetLoopEt+0x234>
 800394c:	d1607084 	addi	r5,gp,-32318
 8003950:	d1205ac4 	addi	r4,gp,-32405
 8003954:	8002e180 	call	8002e18 <_ZL16client_store_macPhS_>
 8003958:	10803fcc 	andi	r2,r2,255
 800395c:	10000226 	beq	r2,zero,8003968 <_ZN9EtherCard10packetLoopEt+0x234>
 8003960:	00800044 	movi	r2,1
 8003964:	00000106 	br	800396c <_ZN9EtherCard10packetLoopEt+0x238>
 8003968:	0005883a 	mov	r2,zero
 800396c:	10803fcc 	andi	r2,r2,255
 8003970:	10000226 	beq	r2,zero,800397c <_ZN9EtherCard10packetLoopEt+0x248>
            waitgwmac = WGW_HAVE_GW_MAC;
 8003974:	00800084 	movi	r2,2
 8003978:	d0a07205 	stb	r2,-32312(gp)
        if (!has_dns_mac && waiting_for_dns_mac && client_store_mac(dnsip, destmacaddr)) {
 800397c:	d0a06fc3 	ldbu	r2,-32321(gp)
 8003980:	1080005c 	xori	r2,r2,1
 8003984:	10803fcc 	andi	r2,r2,255
 8003988:	10000a26 	beq	r2,zero,80039b4 <_ZN9EtherCard10packetLoopEt+0x280>
 800398c:	d0a06f83 	ldbu	r2,-32322(gp)
 8003990:	10803fcc 	andi	r2,r2,255
 8003994:	10000726 	beq	r2,zero,80039b4 <_ZN9EtherCard10packetLoopEt+0x280>
 8003998:	d1606e04 	addi	r5,gp,-32328
 800399c:	d1205cc4 	addi	r4,gp,-32397
 80039a0:	8002e180 	call	8002e18 <_ZL16client_store_macPhS_>
 80039a4:	10803fcc 	andi	r2,r2,255
 80039a8:	10000226 	beq	r2,zero,80039b4 <_ZN9EtherCard10packetLoopEt+0x280>
 80039ac:	00800044 	movi	r2,1
 80039b0:	00000106 	br	80039b8 <_ZN9EtherCard10packetLoopEt+0x284>
 80039b4:	0005883a 	mov	r2,zero
 80039b8:	10803fcc 	andi	r2,r2,255
 80039bc:	10000326 	beq	r2,zero,80039cc <_ZN9EtherCard10packetLoopEt+0x298>
            has_dns_mac = true;
 80039c0:	00800044 	movi	r2,1
 80039c4:	d0a06fc5 	stb	r2,-32321(gp)
            waiting_for_dns_mac = false;
 80039c8:	d0206f85 	stb	zero,-32322(gp)
        }
        if (!has_dest_mac && waiting_for_dest_mac && client_store_mac(hisip, destmacaddr)) {
 80039cc:	d0a07043 	ldbu	r2,-32319(gp)
 80039d0:	1080005c 	xori	r2,r2,1
 80039d4:	10803fcc 	andi	r2,r2,255
 80039d8:	10000a26 	beq	r2,zero,8003a04 <_ZN9EtherCard10packetLoopEt+0x2d0>
 80039dc:	d0a07003 	ldbu	r2,-32320(gp)
 80039e0:	10803fcc 	andi	r2,r2,255
 80039e4:	10000726 	beq	r2,zero,8003a04 <_ZN9EtherCard10packetLoopEt+0x2d0>
 80039e8:	d1606e04 	addi	r5,gp,-32328
 80039ec:	d1205dc4 	addi	r4,gp,-32393
 80039f0:	8002e180 	call	8002e18 <_ZL16client_store_macPhS_>
 80039f4:	10803fcc 	andi	r2,r2,255
 80039f8:	10000226 	beq	r2,zero,8003a04 <_ZN9EtherCard10packetLoopEt+0x2d0>
 80039fc:	00800044 	movi	r2,1
 8003a00:	00000106 	br	8003a08 <_ZN9EtherCard10packetLoopEt+0x2d4>
 8003a04:	0005883a 	mov	r2,zero
 8003a08:	10803fcc 	andi	r2,r2,255
 8003a0c:	10000326 	beq	r2,zero,8003a1c <_ZN9EtherCard10packetLoopEt+0x2e8>
            has_dest_mac = true;
 8003a10:	00800044 	movi	r2,1
 8003a14:	d0a07045 	stb	r2,-32319(gp)
            waiting_for_dest_mac = false;
 8003a18:	d0207005 	stb	zero,-32320(gp)
        }
        return 0;
 8003a1c:	0005883a 	mov	r2,zero
 8003a20:	00010006 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>
    }

    if (eth_type_is_ip_and_my_ip(plen)==0)
 8003a24:	e0bfff0b 	ldhu	r2,-4(fp)
 8003a28:	1009883a 	mov	r4,r2
 8003a2c:	800180c0 	call	800180c <_ZL24eth_type_is_ip_and_my_ipt>
 8003a30:	10803fcc 	andi	r2,r2,255
 8003a34:	1005003a 	cmpeq	r2,r2,zero
 8003a38:	10803fcc 	andi	r2,r2,255
 8003a3c:	10000226 	beq	r2,zero,8003a48 <_ZN9EtherCard10packetLoopEt+0x314>
    {   //Not IP so ignoring
        //!@todo Add other protocols (and make each optional at compile time)
        return 0;
 8003a40:	0005883a 	mov	r2,zero
 8003a44:	0000f706 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>
    }

#if ETHERCARD_ICMP
    if (gPB[IP_PROTO_P]==IP_PROTO_ICMP_V && gPB[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
 8003a48:	00820034 	movhi	r2,2048
 8003a4c:	109ac704 	addi	r2,r2,27420
 8003a50:	108005c3 	ldbu	r2,23(r2)
 8003a54:	10803fcc 	andi	r2,r2,255
 8003a58:	10800058 	cmpnei	r2,r2,1
 8003a5c:	1000111e 	bne	r2,zero,8003aa4 <_ZN9EtherCard10packetLoopEt+0x370>
 8003a60:	00820034 	movhi	r2,2048
 8003a64:	109ac704 	addi	r2,r2,27420
 8003a68:	10800883 	ldbu	r2,34(r2)
 8003a6c:	10803fcc 	andi	r2,r2,255
 8003a70:	10800218 	cmpnei	r2,r2,8
 8003a74:	10000b1e 	bne	r2,zero,8003aa4 <_ZN9EtherCard10packetLoopEt+0x370>
    {   //Service ICMP echo request (ping)
        if (icmp_cb)
 8003a78:	d0a06d17 	ldw	r2,-32332(gp)
 8003a7c:	10000426 	beq	r2,zero,8003a90 <_ZN9EtherCard10packetLoopEt+0x35c>
            (*icmp_cb)(&(gPB[IP_SRC_P]));
 8003a80:	d0a06d17 	ldw	r2,-32332(gp)
 8003a84:	01020034 	movhi	r4,2048
 8003a88:	211acd84 	addi	r4,r4,27446
 8003a8c:	103ee83a 	callr	r2
        make_echo_reply_from_request(plen);
 8003a90:	e0bfff0b 	ldhu	r2,-4(fp)
 8003a94:	1009883a 	mov	r4,r2
 8003a98:	8001c740 	call	8001c74 <_ZL28make_echo_reply_from_requestt>
        return 0;
 8003a9c:	0005883a 	mov	r2,zero
 8003aa0:	0000e006 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>
        if(ether.udpServerHasProcessedPacket(plen))
            return 0; //An UDP server handler (callback) has processed this packet
    }
#endif

    if (plen<54 || gPB[IP_PROTO_P]!=IP_PROTO_TCP_V )
 8003aa4:	e0bfff0b 	ldhu	r2,-4(fp)
 8003aa8:	10800db0 	cmpltui	r2,r2,54
 8003aac:	1000061e 	bne	r2,zero,8003ac8 <_ZN9EtherCard10packetLoopEt+0x394>
 8003ab0:	00820034 	movhi	r2,2048
 8003ab4:	109ac704 	addi	r2,r2,27420
 8003ab8:	108005c3 	ldbu	r2,23(r2)
 8003abc:	10803fcc 	andi	r2,r2,255
 8003ac0:	108001a0 	cmpeqi	r2,r2,6
 8003ac4:	1000021e 	bne	r2,zero,8003ad0 <_ZN9EtherCard10packetLoopEt+0x39c>
        return 0; //from here on we are only interested in TCP-packets; these are longer than 54 bytes
 8003ac8:	0005883a 	mov	r2,zero
 8003acc:	0000d506 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>

#if ETHERCARD_TCPCLIENT
    if (gPB[TCP_DST_PORT_H_P]==TCPCLIENT_SRC_PORT_H)
 8003ad0:	00820034 	movhi	r2,2048
 8003ad4:	109ac704 	addi	r2,r2,27420
 8003ad8:	10800903 	ldbu	r2,36(r2)
 8003adc:	10803fcc 	andi	r2,r2,255
 8003ae0:	108002d8 	cmpnei	r2,r2,11
 8003ae4:	1000cf1e 	bne	r2,zero,8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>
    {   //Source port is in range reserved (by EtherCard) for client TCP/IP connections
        if (check_ip_message_is_from(hisip)==0)
 8003ae8:	d1205dc4 	addi	r4,gp,-32393
 8003aec:	800167c0 	call	800167c <_ZL24check_ip_message_is_fromPKh>
 8003af0:	10803fcc 	andi	r2,r2,255
 8003af4:	1005003a 	cmpeq	r2,r2,zero
 8003af8:	10803fcc 	andi	r2,r2,255
 8003afc:	10000226 	beq	r2,zero,8003b08 <_ZN9EtherCard10packetLoopEt+0x3d4>
            return 0; //Not current TCP/IP connection (only handle one at a time)
 8003b00:	0005883a 	mov	r2,zero
 8003b04:	0000c706 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>
        if (gPB[TCP_FLAGS_P] & TCP_FLAGS_RST_V)
 8003b08:	00820034 	movhi	r2,2048
 8003b0c:	109ac704 	addi	r2,r2,27420
 8003b10:	10800bc3 	ldbu	r2,47(r2)
 8003b14:	10803fcc 	andi	r2,r2,255
 8003b18:	1080010c 	andi	r2,r2,4
 8003b1c:	10001226 	beq	r2,zero,8003b68 <_ZN9EtherCard10packetLoopEt+0x434>
        {   //TCP reset flagged
            if (client_tcp_result_cb)
 8003b20:	d0a06417 	ldw	r2,-32368(gp)
 8003b24:	10000c26 	beq	r2,zero,8003b58 <_ZN9EtherCard10packetLoopEt+0x424>
                (*client_tcp_result_cb)((gPB[TCP_DST_PORT_L_P]>>5)&0x7,3,0,0);
 8003b28:	d0e06417 	ldw	r3,-32368(gp)
 8003b2c:	00820034 	movhi	r2,2048
 8003b30:	109ac704 	addi	r2,r2,27420
 8003b34:	10800943 	ldbu	r2,37(r2)
 8003b38:	10803fcc 	andi	r2,r2,255
 8003b3c:	1004d17a 	srli	r2,r2,5
 8003b40:	10803fcc 	andi	r2,r2,255
 8003b44:	000f883a 	mov	r7,zero
 8003b48:	000d883a 	mov	r6,zero
 8003b4c:	014000c4 	movi	r5,3
 8003b50:	1009883a 	mov	r4,r2
 8003b54:	183ee83a 	callr	r3
            tcp_client_state = TCP_STATE_CLOSING;
 8003b58:	00800144 	movi	r2,5
 8003b5c:	d0a06345 	stb	r2,-32371(gp)
            return 0;
 8003b60:	0005883a 	mov	r2,zero
 8003b64:	0000af06 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>
        }
        len = getTcpPayloadLength();
 8003b68:	8001fc40 	call	8001fc4 <_ZN9EtherCard19getTcpPayloadLengthEv>
 8003b6c:	e0bffd0d 	sth	r2,-12(fp)
        if (tcp_client_state==TCP_STATE_SYNSENT)
 8003b70:	d0a06343 	ldbu	r2,-32371(gp)
 8003b74:	10803fcc 	andi	r2,r2,255
 8003b78:	10800098 	cmpnei	r2,r2,2
 8003b7c:	10003c1e 	bne	r2,zero,8003c70 <_ZN9EtherCard10packetLoopEt+0x53c>
        {   //Waiting for SYN-ACK
            if ((gPB[TCP_FLAGS_P] & TCP_FLAGS_SYN_V) && (gPB[TCP_FLAGS_P] &TCP_FLAGS_ACK_V))
 8003b80:	00820034 	movhi	r2,2048
 8003b84:	109ac704 	addi	r2,r2,27420
 8003b88:	10800bc3 	ldbu	r2,47(r2)
 8003b8c:	10803fcc 	andi	r2,r2,255
 8003b90:	1080008c 	andi	r2,r2,2
 8003b94:	10002126 	beq	r2,zero,8003c1c <_ZN9EtherCard10packetLoopEt+0x4e8>
 8003b98:	00820034 	movhi	r2,2048
 8003b9c:	109ac704 	addi	r2,r2,27420
 8003ba0:	10800bc3 	ldbu	r2,47(r2)
 8003ba4:	10803fcc 	andi	r2,r2,255
 8003ba8:	1080040c 	andi	r2,r2,16
 8003bac:	10001b26 	beq	r2,zero,8003c1c <_ZN9EtherCard10packetLoopEt+0x4e8>
            {   //SYN and ACK flags set so this is an acknowledgement to our SYN
                make_tcp_ack_from_any(0,0);
 8003bb0:	000b883a 	mov	r5,zero
 8003bb4:	0009883a 	mov	r4,zero
 8003bb8:	80020540 	call	8002054 <_ZL21make_tcp_ack_from_anysh>
                gPB[TCP_FLAGS_P] = TCP_FLAGS_ACK_V|TCP_FLAGS_PUSH_V;
 8003bbc:	00820034 	movhi	r2,2048
 8003bc0:	109ac704 	addi	r2,r2,27420
 8003bc4:	00c00604 	movi	r3,24
 8003bc8:	10c00bc5 	stb	r3,47(r2)
                if (client_tcp_datafill_cb)
 8003bcc:	d0a06517 	ldw	r2,-32364(gp)
 8003bd0:	10000b26 	beq	r2,zero,8003c00 <_ZN9EtherCard10packetLoopEt+0x4cc>
                    len = (*client_tcp_datafill_cb)((gPB[TCP_SRC_PORT_L_P]>>5)&0x7);
 8003bd4:	d0e06517 	ldw	r3,-32364(gp)
 8003bd8:	00820034 	movhi	r2,2048
 8003bdc:	109ac704 	addi	r2,r2,27420
 8003be0:	108008c3 	ldbu	r2,35(r2)
 8003be4:	10803fcc 	andi	r2,r2,255
 8003be8:	1004d17a 	srli	r2,r2,5
 8003bec:	10803fcc 	andi	r2,r2,255
 8003bf0:	1009883a 	mov	r4,r2
 8003bf4:	183ee83a 	callr	r3
 8003bf8:	e0bffd0d 	sth	r2,-12(fp)
 8003bfc:	00000106 	br	8003c04 <_ZN9EtherCard10packetLoopEt+0x4d0>
                else
                    len = 0;
 8003c00:	e03ffd0d 	sth	zero,-12(fp)
                tcp_client_state = TCP_STATE_ESTABLISHED;
 8003c04:	008000c4 	movi	r2,3
 8003c08:	d0a06345 	stb	r2,-32371(gp)
                make_tcp_ack_with_data_noflags(len);
 8003c0c:	e0bffd0b 	ldhu	r2,-12(fp)
 8003c10:	1009883a 	mov	r4,r2
 8003c14:	80021440 	call	8002144 <_ZL30make_tcp_ack_with_data_noflagst>
 8003c18:	00001306 	br	8003c68 <_ZN9EtherCard10packetLoopEt+0x534>
            }
            else
            {   //Expecting SYN+ACK so reset and resend SYN
                tcp_client_state = TCP_STATE_SENDSYN; // retry
 8003c1c:	00800044 	movi	r2,1
 8003c20:	d0a06345 	stb	r2,-32371(gp)
                len++;
 8003c24:	e0bffd0b 	ldhu	r2,-12(fp)
 8003c28:	10800044 	addi	r2,r2,1
 8003c2c:	e0bffd0d 	sth	r2,-12(fp)
                if (gPB[TCP_FLAGS_P] & TCP_FLAGS_ACK_V)
 8003c30:	00820034 	movhi	r2,2048
 8003c34:	109ac704 	addi	r2,r2,27420
 8003c38:	10800bc3 	ldbu	r2,47(r2)
 8003c3c:	10803fcc 	andi	r2,r2,255
 8003c40:	1080040c 	andi	r2,r2,16
 8003c44:	10000126 	beq	r2,zero,8003c4c <_ZN9EtherCard10packetLoopEt+0x518>
                    len = 0;
 8003c48:	e03ffd0d 	sth	zero,-12(fp)
                make_tcp_ack_from_any(len,TCP_FLAGS_RST_V);
 8003c4c:	e0bffd0b 	ldhu	r2,-12(fp)
 8003c50:	10bfffcc 	andi	r2,r2,65535
 8003c54:	10a0001c 	xori	r2,r2,32768
 8003c58:	10a00004 	addi	r2,r2,-32768
 8003c5c:	01400104 	movi	r5,4
 8003c60:	1009883a 	mov	r4,r2
 8003c64:	80020540 	call	8002054 <_ZL21make_tcp_ack_from_anysh>
            }
            return 0;
 8003c68:	0005883a 	mov	r2,zero
 8003c6c:	00006d06 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>
        }
        if (tcp_client_state==TCP_STATE_ESTABLISHED && len>0)
 8003c70:	d0a06343 	ldbu	r2,-32371(gp)
 8003c74:	10803fcc 	andi	r2,r2,255
 8003c78:	108000d8 	cmpnei	r2,r2,3
 8003c7c:	1000431e 	bne	r2,zero,8003d8c <_ZN9EtherCard10packetLoopEt+0x658>
 8003c80:	e0bffd0b 	ldhu	r2,-12(fp)
 8003c84:	10004126 	beq	r2,zero,8003d8c <_ZN9EtherCard10packetLoopEt+0x658>
        {   //TCP connection established so read data
            if (client_tcp_result_cb) {
 8003c88:	d0a06417 	ldw	r2,-32368(gp)
 8003c8c:	10003f26 	beq	r2,zero,8003d8c <_ZN9EtherCard10packetLoopEt+0x658>
                uint16_t tcpstart = TCP_DATA_START; // TCP_DATA_START is a formula
 8003c90:	00820034 	movhi	r2,2048
 8003c94:	109ac704 	addi	r2,r2,27420
 8003c98:	10800b83 	ldbu	r2,46(r2)
 8003c9c:	10803fcc 	andi	r2,r2,255
 8003ca0:	1005d13a 	srai	r2,r2,4
 8003ca4:	1085883a 	add	r2,r2,r2
 8003ca8:	1085883a 	add	r2,r2,r2
 8003cac:	10800884 	addi	r2,r2,34
 8003cb0:	e0bffd8d 	sth	r2,-10(fp)
                if (tcpstart>plen-8)
 8003cb4:	e0bffd8b 	ldhu	r2,-10(fp)
 8003cb8:	e0ffff0b 	ldhu	r3,-4(fp)
 8003cbc:	18fffe04 	addi	r3,r3,-8
 8003cc0:	1880030e 	bge	r3,r2,8003cd0 <_ZN9EtherCard10packetLoopEt+0x59c>
                    tcpstart = plen-8; // dummy but save
 8003cc4:	e0bfff0b 	ldhu	r2,-4(fp)
 8003cc8:	10bffe04 	addi	r2,r2,-8
 8003ccc:	e0bffd8d 	sth	r2,-10(fp)
                uint16_t save_len = len;
 8003cd0:	e0bffd0b 	ldhu	r2,-12(fp)
 8003cd4:	e0bffe0d 	sth	r2,-8(fp)
                if (tcpstart+len>plen)
 8003cd8:	e0fffd8b 	ldhu	r3,-10(fp)
 8003cdc:	e0bffd0b 	ldhu	r2,-12(fp)
 8003ce0:	1885883a 	add	r2,r3,r2
 8003ce4:	e0ffff0b 	ldhu	r3,-4(fp)
 8003ce8:	1880040e 	bge	r3,r2,8003cfc <_ZN9EtherCard10packetLoopEt+0x5c8>
                    save_len = plen-tcpstart;
 8003cec:	e0ffff0b 	ldhu	r3,-4(fp)
 8003cf0:	e0bffd8b 	ldhu	r2,-10(fp)
 8003cf4:	1885c83a 	sub	r2,r3,r2
 8003cf8:	e0bffe0d 	sth	r2,-8(fp)
                (*client_tcp_result_cb)((gPB[TCP_DST_PORT_L_P]>>5)&0x7,0,tcpstart,save_len); //Call TCP handler (callback) function
 8003cfc:	d0e06417 	ldw	r3,-32368(gp)
 8003d00:	00820034 	movhi	r2,2048
 8003d04:	109ac704 	addi	r2,r2,27420
 8003d08:	10800943 	ldbu	r2,37(r2)
 8003d0c:	10803fcc 	andi	r2,r2,255
 8003d10:	1004d17a 	srli	r2,r2,5
 8003d14:	10803fcc 	andi	r2,r2,255
 8003d18:	e13ffd8b 	ldhu	r4,-10(fp)
 8003d1c:	e17ffe0b 	ldhu	r5,-8(fp)
 8003d20:	280f883a 	mov	r7,r5
 8003d24:	200d883a 	mov	r6,r4
 8003d28:	000b883a 	mov	r5,zero
 8003d2c:	1009883a 	mov	r4,r2
 8003d30:	183ee83a 	callr	r3

                if(persist_tcp_connection)
 8003d34:	d0a05f03 	ldbu	r2,-32388(gp)
 8003d38:	10803fcc 	andi	r2,r2,255
 8003d3c:	10000826 	beq	r2,zero,8003d60 <_ZN9EtherCard10packetLoopEt+0x62c>
                {   //Keep connection alive by sending ACK
                    make_tcp_ack_from_any(len,TCP_FLAGS_PUSH_V);
 8003d40:	e0bffd0b 	ldhu	r2,-12(fp)
 8003d44:	10bfffcc 	andi	r2,r2,65535
 8003d48:	10a0001c 	xori	r2,r2,32768
 8003d4c:	10a00004 	addi	r2,r2,-32768
 8003d50:	01400204 	movi	r5,8
 8003d54:	1009883a 	mov	r4,r2
 8003d58:	80020540 	call	8002054 <_ZL21make_tcp_ack_from_anysh>
 8003d5c:	00000906 	br	8003d84 <_ZN9EtherCard10packetLoopEt+0x650>
                }
                else
                {   //Close connection
                    make_tcp_ack_from_any(len,TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V);
 8003d60:	e0bffd0b 	ldhu	r2,-12(fp)
 8003d64:	10bfffcc 	andi	r2,r2,65535
 8003d68:	10a0001c 	xori	r2,r2,32768
 8003d6c:	10a00004 	addi	r2,r2,-32768
 8003d70:	01400244 	movi	r5,9
 8003d74:	1009883a 	mov	r4,r2
 8003d78:	80020540 	call	8002054 <_ZL21make_tcp_ack_from_anysh>
                    tcp_client_state = TCP_STATE_CLOSED;
 8003d7c:	00800184 	movi	r2,6
 8003d80:	d0a06345 	stb	r2,-32371(gp)
                }
                return 0;
 8003d84:	0005883a 	mov	r2,zero
 8003d88:	00002606 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>
            }
        }
        if (tcp_client_state != TCP_STATE_CLOSING)
 8003d8c:	d0a06343 	ldbu	r2,-32371(gp)
 8003d90:	10803fcc 	andi	r2,r2,255
 8003d94:	10800160 	cmpeqi	r2,r2,5
 8003d98:	1000201e 	bne	r2,zero,8003e1c <_ZN9EtherCard10packetLoopEt+0x6e8>
        {   //
            if (gPB[TCP_FLAGS_P] & TCP_FLAGS_FIN_V) {
 8003d9c:	00820034 	movhi	r2,2048
 8003da0:	109ac704 	addi	r2,r2,27420
 8003da4:	10800bc3 	ldbu	r2,47(r2)
 8003da8:	10803fcc 	andi	r2,r2,255
 8003dac:	1080004c 	andi	r2,r2,1
 8003db0:	10001126 	beq	r2,zero,8003df8 <_ZN9EtherCard10packetLoopEt+0x6c4>
                if(tcp_client_state == TCP_STATE_ESTABLISHED) {
 8003db4:	d0a06343 	ldbu	r2,-32371(gp)
 8003db8:	10803fcc 	andi	r2,r2,255
 8003dbc:	108000d8 	cmpnei	r2,r2,3
 8003dc0:	1000021e 	bne	r2,zero,8003dcc <_ZN9EtherCard10packetLoopEt+0x698>
                    return 0; // In some instances FIN is received *before* DATA.  If that is the case, we just return here and keep looking for the data packet
 8003dc4:	0005883a 	mov	r2,zero
 8003dc8:	00001606 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>
                }
                make_tcp_ack_from_any(len+1,TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V);
 8003dcc:	e0bffd0b 	ldhu	r2,-12(fp)
 8003dd0:	10800044 	addi	r2,r2,1
 8003dd4:	10bfffcc 	andi	r2,r2,65535
 8003dd8:	10a0001c 	xori	r2,r2,32768
 8003ddc:	10a00004 	addi	r2,r2,-32768
 8003de0:	01400244 	movi	r5,9
 8003de4:	1009883a 	mov	r4,r2
 8003de8:	80020540 	call	8002054 <_ZL21make_tcp_ack_from_anysh>
                tcp_client_state = TCP_STATE_CLOSED; // connection terminated
 8003dec:	00800184 	movi	r2,6
 8003df0:	d0a06345 	stb	r2,-32371(gp)
 8003df4:	00000906 	br	8003e1c <_ZN9EtherCard10packetLoopEt+0x6e8>
            } else if (len>0) {
 8003df8:	e0bffd0b 	ldhu	r2,-12(fp)
 8003dfc:	10000726 	beq	r2,zero,8003e1c <_ZN9EtherCard10packetLoopEt+0x6e8>
                make_tcp_ack_from_any(len,0);
 8003e00:	e0bffd0b 	ldhu	r2,-12(fp)
 8003e04:	10bfffcc 	andi	r2,r2,65535
 8003e08:	10a0001c 	xori	r2,r2,32768
 8003e0c:	10a00004 	addi	r2,r2,-32768
 8003e10:	000b883a 	mov	r5,zero
 8003e14:	1009883a 	mov	r4,r2
 8003e18:	80020540 	call	8002054 <_ZL21make_tcp_ack_from_anysh>
            }
        }
        return 0;
 8003e1c:	0005883a 	mov	r2,zero
 8003e20:	00000006 	br	8003e24 <_ZN9EtherCard10packetLoopEt+0x6f0>

#if ETHERCARD_TCPSERVER
    //If we are here then this is a TCP/IP packet targeted at us and not related to our client connection so accept
    return accept(hisport, plen);
#endif
}
 8003e24:	e037883a 	mov	sp,fp
 8003e28:	dfc00117 	ldw	ra,4(sp)
 8003e2c:	df000017 	ldw	fp,0(sp)
 8003e30:	dec00204 	addi	sp,sp,8
 8003e34:	f800283a 	ret

08003e38 <_ZN9EtherCard20persistTcpConnectionEb>:

void EtherCard::persistTcpConnection(bool persist) {
 8003e38:	defffe04 	addi	sp,sp,-8
 8003e3c:	df000115 	stw	fp,4(sp)
 8003e40:	df000104 	addi	fp,sp,4
 8003e44:	2005883a 	mov	r2,r4
 8003e48:	e0bfff05 	stb	r2,-4(fp)
    persist_tcp_connection = persist;
 8003e4c:	e0bfff03 	ldbu	r2,-4(fp)
 8003e50:	d0a05f05 	stb	r2,-32388(gp)
}
 8003e54:	0001883a 	nop
 8003e58:	e037883a 	mov	sp,fp
 8003e5c:	df000017 	ldw	fp,0(sp)
 8003e60:	dec00104 	addi	sp,sp,4
 8003e64:	f800283a 	ret

08003e68 <_ZN9EtherCard7printIpEPKcPKh>:
#include "EtherCard.h"
#include <stdio.h>
#include <string.h>

void EtherCard::printIp (const char *msg, const uint8_t *buf) {
 8003e68:	defffc04 	addi	sp,sp,-16
 8003e6c:	dfc00315 	stw	ra,12(sp)
 8003e70:	df000215 	stw	fp,8(sp)
 8003e74:	df000204 	addi	fp,sp,8
 8003e78:	e13ffe15 	stw	r4,-8(fp)
 8003e7c:	e17fff15 	stw	r5,-4(fp)
    printf("%s", msg);
 8003e80:	e17ffe17 	ldw	r5,-8(fp)
 8003e84:	01020034 	movhi	r4,2048
 8003e88:	2119a804 	addi	r4,r4,26272
 8003e8c:	8004cb80 	call	8004cb8 <printf>
    EtherCard::printIp(buf);
 8003e90:	e13fff17 	ldw	r4,-4(fp)
 8003e94:	8003eb80 	call	8003eb8 <_ZN9EtherCard7printIpEPKh>
    printf("\n");
 8003e98:	01000284 	movi	r4,10
 8003e9c:	8004d0c0 	call	8004d0c <putchar>
}
 8003ea0:	0001883a 	nop
 8003ea4:	e037883a 	mov	sp,fp
 8003ea8:	dfc00117 	ldw	ra,4(sp)
 8003eac:	df000017 	ldw	fp,0(sp)
 8003eb0:	dec00204 	addi	sp,sp,8
 8003eb4:	f800283a 	ret

08003eb8 <_ZN9EtherCard7printIpEPKh>:

void EtherCard::printIp (const uint8_t *buf) {
 8003eb8:	defffc04 	addi	sp,sp,-16
 8003ebc:	dfc00315 	stw	ra,12(sp)
 8003ec0:	df000215 	stw	fp,8(sp)
 8003ec4:	df000204 	addi	fp,sp,8
 8003ec8:	e13fff15 	stw	r4,-4(fp)
    for (uint8_t i = 0; i < IP_LEN; ++i) {
 8003ecc:	e03ffe05 	stb	zero,-8(fp)
 8003ed0:	e0bffe03 	ldbu	r2,-8(fp)
 8003ed4:	10800128 	cmpgeui	r2,r2,4
 8003ed8:	1000121e 	bne	r2,zero,8003f24 <_ZN9EtherCard7printIpEPKh+0x6c>
        printf("%d", buf[i]);
 8003edc:	e0bffe03 	ldbu	r2,-8(fp)
 8003ee0:	e0ffff17 	ldw	r3,-4(fp)
 8003ee4:	1885883a 	add	r2,r3,r2
 8003ee8:	10800003 	ldbu	r2,0(r2)
 8003eec:	10803fcc 	andi	r2,r2,255
 8003ef0:	100b883a 	mov	r5,r2
 8003ef4:	01020034 	movhi	r4,2048
 8003ef8:	2119a904 	addi	r4,r4,26276
 8003efc:	8004cb80 	call	8004cb8 <printf>
        if (i < 3)
 8003f00:	e0bffe03 	ldbu	r2,-8(fp)
 8003f04:	108000e8 	cmpgeui	r2,r2,3
 8003f08:	1000021e 	bne	r2,zero,8003f14 <_ZN9EtherCard7printIpEPKh+0x5c>
            printf(".");
 8003f0c:	01000b84 	movi	r4,46
 8003f10:	8004d0c0 	call	8004d0c <putchar>
    EtherCard::printIp(buf);
    printf("\n");
}

void EtherCard::printIp (const uint8_t *buf) {
    for (uint8_t i = 0; i < IP_LEN; ++i) {
 8003f14:	e0bffe03 	ldbu	r2,-8(fp)
 8003f18:	10800044 	addi	r2,r2,1
 8003f1c:	e0bffe05 	stb	r2,-8(fp)
 8003f20:	003feb06 	br	8003ed0 <__alt_data_end+0xfc003ed0>
        printf("%d", buf[i]);
        if (i < 3)
            printf(".");
    }
}
 8003f24:	0001883a 	nop
 8003f28:	e037883a 	mov	sp,fp
 8003f2c:	dfc00117 	ldw	ra,4(sp)
 8003f30:	df000017 	ldw	fp,0(sp)
 8003f34:	dec00204 	addi	sp,sp,8
 8003f38:	f800283a 	ret

08003f3c <_ZN9EtherCard7copyMacEPhPKh>:

void EtherCard::copyMac (uint8_t *dst, const uint8_t *src) {
 8003f3c:	defffc04 	addi	sp,sp,-16
 8003f40:	dfc00315 	stw	ra,12(sp)
 8003f44:	df000215 	stw	fp,8(sp)
 8003f48:	df000204 	addi	fp,sp,8
 8003f4c:	e13ffe15 	stw	r4,-8(fp)
 8003f50:	e17fff15 	stw	r5,-4(fp)
    memcpy(dst, src, ETH_LEN);
 8003f54:	01800184 	movi	r6,6
 8003f58:	e17fff17 	ldw	r5,-4(fp)
 8003f5c:	e13ffe17 	ldw	r4,-8(fp)
 8003f60:	8004c340 	call	8004c34 <memcpy>
}
 8003f64:	0001883a 	nop
 8003f68:	e037883a 	mov	sp,fp
 8003f6c:	dfc00117 	ldw	ra,4(sp)
 8003f70:	df000017 	ldw	fp,0(sp)
 8003f74:	dec00204 	addi	sp,sp,8
 8003f78:	f800283a 	ret

08003f7c <_ZN9EtherCard6copyIpEPhPKh>:

void EtherCard::copyIp (uint8_t *dst, const uint8_t *src) {
 8003f7c:	defffc04 	addi	sp,sp,-16
 8003f80:	dfc00315 	stw	ra,12(sp)
 8003f84:	df000215 	stw	fp,8(sp)
 8003f88:	df000204 	addi	fp,sp,8
 8003f8c:	e13ffe15 	stw	r4,-8(fp)
 8003f90:	e17fff15 	stw	r5,-4(fp)
    memcpy(dst, src, IP_LEN);
 8003f94:	01800104 	movi	r6,4
 8003f98:	e17fff17 	ldw	r5,-4(fp)
 8003f9c:	e13ffe17 	ldw	r4,-8(fp)
 8003fa0:	8004c340 	call	8004c34 <memcpy>
}
 8003fa4:	0001883a 	nop
 8003fa8:	e037883a 	mov	sp,fp
 8003fac:	dfc00117 	ldw	ra,4(sp)
 8003fb0:	df000017 	ldw	fp,0(sp)
 8003fb4:	dec00204 	addi	sp,sp,8
 8003fb8:	f800283a 	ret

08003fbc <_ZL9gotPingedPh>:
//EtherCard ether;

uint8_t Ethernet::buffer[700];

// called when a ping comes in (replies to it are automatic)
static void gotPinged(uint8_t *ptr) { ether.printIp(">>> ping from: ", ptr); }
 8003fbc:	defffd04 	addi	sp,sp,-12
 8003fc0:	dfc00215 	stw	ra,8(sp)
 8003fc4:	df000115 	stw	fp,4(sp)
 8003fc8:	df000104 	addi	fp,sp,4
 8003fcc:	e13fff15 	stw	r4,-4(fp)
 8003fd0:	e17fff17 	ldw	r5,-4(fp)
 8003fd4:	01020034 	movhi	r4,2048
 8003fd8:	2119aa04 	addi	r4,r4,26280
 8003fdc:	8003e680 	call	8003e68 <_ZN9EtherCard7printIpEPKcPKh>
 8003fe0:	0001883a 	nop
 8003fe4:	e037883a 	mov	sp,fp
 8003fe8:	dfc00117 	ldw	ra,4(sp)
 8003fec:	df000017 	ldw	fp,0(sp)
 8003ff0:	dec00204 	addi	sp,sp,8
 8003ff4:	f800283a 	ret

08003ff8 <main>:

int main() {
 8003ff8:	defffb04 	addi	sp,sp,-20
 8003ffc:	dfc00415 	stw	ra,16(sp)
 8004000:	df000315 	stw	fp,12(sp)
 8004004:	dc000215 	stw	r16,8(sp)
 8004008:	df000304 	addi	fp,sp,12
  printf("\n[pings]");
 800400c:	01020034 	movhi	r4,2048
 8004010:	2119ae04 	addi	r4,r4,26296
 8004014:	8004cb80 	call	8004cb8 <printf>


  // Change 'SS' to your Slave Select pin, if you arn't using the default pin
  if (ether.begin(sizeof ether.buffer, (const uint8_t*)mymac, SS) == 0)
 8004018:	0080af04 	movi	r2,700
 800401c:	10bfffcc 	andi	r2,r2,65535
 8004020:	000d883a 	mov	r6,zero
 8004024:	d1600644 	addi	r5,gp,-32743
 8004028:	1009883a 	mov	r4,r2
 800402c:	80001bc0 	call	80001bc <_ZN9EtherCard5beginEtPKhh>
 8004030:	10803fcc 	andi	r2,r2,255
 8004034:	1005003a 	cmpeq	r2,r2,zero
 8004038:	10803fcc 	andi	r2,r2,255
 800403c:	10000326 	beq	r2,zero,800404c <main+0x54>
    printf("Failed to access Ethernet controller");
 8004040:	01020034 	movhi	r4,2048
 8004044:	2119b104 	addi	r4,r4,26308
 8004048:	8004cb80 	call	8004cb8 <printf>
  // if (!ether.dhcpSetup())
  //   printf("DHCP failed");

  ether.printIp("IP:  ", ether.myip);
 800404c:	d16057c4 	addi	r5,gp,-32417
 8004050:	01020034 	movhi	r4,2048
 8004054:	2119bb04 	addi	r4,r4,26348
 8004058:	8003e680 	call	8003e68 <_ZN9EtherCard7printIpEPKcPKh>
  ether.printIp("GW:  ", ether.gwip);
 800405c:	d1605ac4 	addi	r5,gp,-32405
 8004060:	01020034 	movhi	r4,2048
 8004064:	2119bd04 	addi	r4,r4,26356
 8004068:	8003e680 	call	8003e68 <_ZN9EtherCard7printIpEPKcPKh>

  // use DNS to locate the IP address we want to ping
  if (!ether.dnsLookup("www.google.com"))
 800406c:	000b883a 	mov	r5,zero
 8004070:	01020034 	movhi	r4,2048
 8004074:	2119bf04 	addi	r4,r4,26364
 8004078:	80005f40 	call	80005f4 <_ZN9EtherCard9dnsLookupEPKcb>
 800407c:	1080005c 	xori	r2,r2,1
 8004080:	10803fcc 	andi	r2,r2,255
 8004084:	10000326 	beq	r2,zero,8004094 <main+0x9c>
    printf("DNS failed");
 8004088:	01020034 	movhi	r4,2048
 800408c:	2119c304 	addi	r4,r4,26380
 8004090:	8004cb80 	call	8004cb8 <printf>

  ether.printIp("SRV: ", ether.hisip);
 8004094:	d1605dc4 	addi	r5,gp,-32393
 8004098:	01020034 	movhi	r4,2048
 800409c:	2119c604 	addi	r4,r4,26392
 80040a0:	8003e680 	call	8003e68 <_ZN9EtherCard7printIpEPKcPKh>

  // call this to report others pinging us
  ether.registerPingCallback(gotPinged);
 80040a4:	01020034 	movhi	r4,2048
 80040a8:	210fef04 	addi	r4,r4,16316
 80040ac:	80035640 	call	8003564 <_ZN9EtherCard20registerPingCallbackEPFvPhE>

  //   timer = -9999999; // start timing out right away
  time_t prevTime = time(NULL);
 80040b0:	0009883a 	mov	r4,zero
 80040b4:	8004d880 	call	8004d88 <time>
 80040b8:	e0bffd15 	stw	r2,-12(fp)

  while (1) {
    uint16_t len = ether.packetReceive(); // go receive new packets
 80040bc:	80011480 	call	8001148 <_ZN8ENC28J6013packetReceiveEv>
 80040c0:	e0bffe0d 	sth	r2,-8(fp)
    uint16_t pos = ether.packetLoop(len); // respond to incoming pings
 80040c4:	e0bffe0b 	ldhu	r2,-8(fp)
 80040c8:	1009883a 	mov	r4,r2
 80040cc:	80037340 	call	8003734 <_ZN9EtherCard10packetLoopEt>
 80040d0:	e0bffe8d 	sth	r2,-6(fp)

    // report whenever a reply to our outgoing ping comes back
    if (len > 0 && ether.packetLoopIcmpCheckReply(ether.hisip))
 80040d4:	e0bffe0b 	ldhu	r2,-8(fp)
 80040d8:	10000626 	beq	r2,zero,80040f4 <main+0xfc>
 80040dc:	d1205dc4 	addi	r4,gp,-32393
 80040e0:	80035900 	call	8003590 <_ZN9EtherCard24packetLoopIcmpCheckReplyEPKh>
 80040e4:	10803fcc 	andi	r2,r2,255
 80040e8:	10000226 	beq	r2,zero,80040f4 <main+0xfc>
 80040ec:	00800044 	movi	r2,1
 80040f0:	00000106 	br	80040f8 <main+0x100>
 80040f4:	0005883a 	mov	r2,zero
 80040f8:	10803fcc 	andi	r2,r2,255
 80040fc:	10001726 	beq	r2,zero,800415c <main+0x164>
      printf("   %.f ms", difftime(time(NULL), prevTime) * 0.001);
 8004100:	0009883a 	mov	r4,zero
 8004104:	8004d880 	call	8004d88 <time>
 8004108:	e17ffd17 	ldw	r5,-12(fp)
 800410c:	1009883a 	mov	r4,r2
 8004110:	8004be80 	call	8004be8 <difftime>
 8004114:	1011883a 	mov	r8,r2
 8004118:	1813883a 	mov	r9,r3
 800411c:	01b4bcb4 	movhi	r6,54002
 8004120:	31aa7f04 	addi	r6,r6,-22020
 8004124:	01cfd434 	movhi	r7,16208
 8004128:	39d89344 	addi	r7,r7,25165
 800412c:	4009883a 	mov	r4,r8
 8004130:	480b883a 	mov	r5,r9
 8004134:	80042a40 	call	80042a4 <__muldf3>
 8004138:	1009883a 	mov	r4,r2
 800413c:	180b883a 	mov	r5,r3
 8004140:	2005883a 	mov	r2,r4
 8004144:	2807883a 	mov	r3,r5
 8004148:	100b883a 	mov	r5,r2
 800414c:	180d883a 	mov	r6,r3
 8004150:	01020034 	movhi	r4,2048
 8004154:	2119c804 	addi	r4,r4,26400
 8004158:	8004cb80 	call	8004cb8 <printf>

    // ping a remote server once every few seconds
    if (difftime(time(NULL), prevTime) >= 5) {
 800415c:	0009883a 	mov	r4,zero
 8004160:	8004d880 	call	8004d88 <time>
 8004164:	e17ffd17 	ldw	r5,-12(fp)
 8004168:	1009883a 	mov	r4,r2
 800416c:	8004be80 	call	8004be8 <difftime>
 8004170:	1011883a 	mov	r8,r2
 8004174:	1813883a 	mov	r9,r3
 8004178:	04000044 	movi	r16,1
 800417c:	000d883a 	mov	r6,zero
 8004180:	01d00534 	movhi	r7,16404
 8004184:	4009883a 	mov	r4,r8
 8004188:	480b883a 	mov	r5,r9
 800418c:	80041c80 	call	80041c8 <__gedf2>
 8004190:	1000010e 	bge	r2,zero,8004198 <main+0x1a0>
 8004194:	0021883a 	mov	r16,zero
 8004198:	80803fcc 	andi	r2,r16,255
 800419c:	103fc726 	beq	r2,zero,80040bc <__alt_data_end+0xfc0040bc>
      ether.printIp("Pinging: ", ether.hisip);
 80041a0:	d1605dc4 	addi	r5,gp,-32393
 80041a4:	01020034 	movhi	r4,2048
 80041a8:	2119cb04 	addi	r4,r4,26412
 80041ac:	8003e680 	call	8003e68 <_ZN9EtherCard7printIpEPKcPKh>
      prevTime = time(NULL);
 80041b0:	0009883a 	mov	r4,zero
 80041b4:	8004d880 	call	8004d88 <time>
 80041b8:	e0bffd15 	stw	r2,-12(fp)
      ether.clientIcmpRequest(ether.hisip);
 80041bc:	d1205dc4 	addi	r4,gp,-32393
 80041c0:	800247c0 	call	800247c <_ZN9EtherCard17clientIcmpRequestEPKh>
  ether.registerPingCallback(gotPinged);

  //   timer = -9999999; // start timing out right away
  time_t prevTime = time(NULL);

  while (1) {
 80041c4:	003fbd06 	br	80040bc <__alt_data_end+0xfc0040bc>

080041c8 <__gedf2>:
 80041c8:	2804d53a 	srli	r2,r5,20
 80041cc:	3806d53a 	srli	r3,r7,20
 80041d0:	02000434 	movhi	r8,16
 80041d4:	423fffc4 	addi	r8,r8,-1
 80041d8:	1081ffcc 	andi	r2,r2,2047
 80041dc:	0241ffc4 	movi	r9,2047
 80041e0:	2a14703a 	and	r10,r5,r8
 80041e4:	18c1ffcc 	andi	r3,r3,2047
 80041e8:	3a10703a 	and	r8,r7,r8
 80041ec:	280ad7fa 	srli	r5,r5,31
 80041f0:	380ed7fa 	srli	r7,r7,31
 80041f4:	12401d26 	beq	r2,r9,800426c <__gedf2+0xa4>
 80041f8:	0241ffc4 	movi	r9,2047
 80041fc:	1a401226 	beq	r3,r9,8004248 <__gedf2+0x80>
 8004200:	1000081e 	bne	r2,zero,8004224 <__gedf2+0x5c>
 8004204:	2296b03a 	or	r11,r4,r10
 8004208:	5813003a 	cmpeq	r9,r11,zero
 800420c:	1800091e 	bne	r3,zero,8004234 <__gedf2+0x6c>
 8004210:	3218b03a 	or	r12,r6,r8
 8004214:	6000071e 	bne	r12,zero,8004234 <__gedf2+0x6c>
 8004218:	0005883a 	mov	r2,zero
 800421c:	5800101e 	bne	r11,zero,8004260 <__gedf2+0x98>
 8004220:	f800283a 	ret
 8004224:	18000c1e 	bne	r3,zero,8004258 <__gedf2+0x90>
 8004228:	3212b03a 	or	r9,r6,r8
 800422c:	48000c26 	beq	r9,zero,8004260 <__gedf2+0x98>
 8004230:	0013883a 	mov	r9,zero
 8004234:	39c03fcc 	andi	r7,r7,255
 8004238:	48000826 	beq	r9,zero,800425c <__gedf2+0x94>
 800423c:	38000926 	beq	r7,zero,8004264 <__gedf2+0x9c>
 8004240:	00800044 	movi	r2,1
 8004244:	f800283a 	ret
 8004248:	3212b03a 	or	r9,r6,r8
 800424c:	483fec26 	beq	r9,zero,8004200 <__alt_data_end+0xfc004200>
 8004250:	00bfff84 	movi	r2,-2
 8004254:	f800283a 	ret
 8004258:	39c03fcc 	andi	r7,r7,255
 800425c:	29c00626 	beq	r5,r7,8004278 <__gedf2+0xb0>
 8004260:	283ff726 	beq	r5,zero,8004240 <__alt_data_end+0xfc004240>
 8004264:	00bfffc4 	movi	r2,-1
 8004268:	f800283a 	ret
 800426c:	2292b03a 	or	r9,r4,r10
 8004270:	483fe126 	beq	r9,zero,80041f8 <__alt_data_end+0xfc0041f8>
 8004274:	003ff606 	br	8004250 <__alt_data_end+0xfc004250>
 8004278:	18bff916 	blt	r3,r2,8004260 <__alt_data_end+0xfc004260>
 800427c:	10c00316 	blt	r2,r3,800428c <__gedf2+0xc4>
 8004280:	42bff736 	bltu	r8,r10,8004260 <__alt_data_end+0xfc004260>
 8004284:	52000326 	beq	r10,r8,8004294 <__gedf2+0xcc>
 8004288:	5200042e 	bgeu	r10,r8,800429c <__gedf2+0xd4>
 800428c:	283fec1e 	bne	r5,zero,8004240 <__alt_data_end+0xfc004240>
 8004290:	003ff406 	br	8004264 <__alt_data_end+0xfc004264>
 8004294:	313ff236 	bltu	r6,r4,8004260 <__alt_data_end+0xfc004260>
 8004298:	21bffc36 	bltu	r4,r6,800428c <__alt_data_end+0xfc00428c>
 800429c:	0005883a 	mov	r2,zero
 80042a0:	f800283a 	ret

080042a4 <__muldf3>:
 80042a4:	deffee04 	addi	sp,sp,-72
 80042a8:	dd000c15 	stw	r20,48(sp)
 80042ac:	2828d53a 	srli	r20,r5,20
 80042b0:	ddc00f15 	stw	r23,60(sp)
 80042b4:	282ed7fa 	srli	r23,r5,31
 80042b8:	dc000815 	stw	r16,32(sp)
 80042bc:	04000434 	movhi	r16,16
 80042c0:	dcc00b15 	stw	r19,44(sp)
 80042c4:	843fffc4 	addi	r16,r16,-1
 80042c8:	dfc01115 	stw	ra,68(sp)
 80042cc:	df001015 	stw	fp,64(sp)
 80042d0:	dd800e15 	stw	r22,56(sp)
 80042d4:	dd400d15 	stw	r21,52(sp)
 80042d8:	dc800a15 	stw	r18,40(sp)
 80042dc:	dc400915 	stw	r17,36(sp)
 80042e0:	a501ffcc 	andi	r20,r20,2047
 80042e4:	2c20703a 	and	r16,r5,r16
 80042e8:	b827883a 	mov	r19,r23
 80042ec:	ba403fcc 	andi	r9,r23,255
 80042f0:	a0006026 	beq	r20,zero,8004474 <__muldf3+0x1d0>
 80042f4:	0081ffc4 	movi	r2,2047
 80042f8:	202d883a 	mov	r22,r4
 80042fc:	a0803626 	beq	r20,r2,80043d8 <__muldf3+0x134>
 8004300:	84000434 	orhi	r16,r16,16
 8004304:	200ad77a 	srli	r5,r4,29
 8004308:	800490fa 	slli	r2,r16,3
 800430c:	202c90fa 	slli	r22,r4,3
 8004310:	a53f0044 	addi	r20,r20,-1023
 8004314:	28a0b03a 	or	r16,r5,r2
 8004318:	002b883a 	mov	r21,zero
 800431c:	000b883a 	mov	r5,zero
 8004320:	3804d53a 	srli	r2,r7,20
 8004324:	3838d7fa 	srli	fp,r7,31
 8004328:	04400434 	movhi	r17,16
 800432c:	8c7fffc4 	addi	r17,r17,-1
 8004330:	1081ffcc 	andi	r2,r2,2047
 8004334:	3025883a 	mov	r18,r6
 8004338:	3c62703a 	and	r17,r7,r17
 800433c:	e2803fcc 	andi	r10,fp,255
 8004340:	10006d26 	beq	r2,zero,80044f8 <__muldf3+0x254>
 8004344:	00c1ffc4 	movi	r3,2047
 8004348:	10c06526 	beq	r2,r3,80044e0 <__muldf3+0x23c>
 800434c:	8c400434 	orhi	r17,r17,16
 8004350:	300ed77a 	srli	r7,r6,29
 8004354:	880690fa 	slli	r3,r17,3
 8004358:	302490fa 	slli	r18,r6,3
 800435c:	10bf0044 	addi	r2,r2,-1023
 8004360:	38e2b03a 	or	r17,r7,r3
 8004364:	000f883a 	mov	r7,zero
 8004368:	a087883a 	add	r3,r20,r2
 800436c:	010003c4 	movi	r4,15
 8004370:	3d44b03a 	or	r2,r7,r21
 8004374:	e5ccf03a 	xor	r6,fp,r23
 8004378:	1a000044 	addi	r8,r3,1
 800437c:	20809b36 	bltu	r4,r2,80045ec <__muldf3+0x348>
 8004380:	100490ba 	slli	r2,r2,2
 8004384:	01020034 	movhi	r4,2048
 8004388:	2110e604 	addi	r4,r4,17304
 800438c:	1105883a 	add	r2,r2,r4
 8004390:	10800017 	ldw	r2,0(r2)
 8004394:	1000683a 	jmp	r2
 8004398:	080045ec 	andhi	zero,at,279
 800439c:	080043f8 	rdprs	zero,at,271
 80043a0:	080043f8 	rdprs	zero,at,271
 80043a4:	080043f4 	orhi	zero,at,271
 80043a8:	080045c8 	cmpgei	zero,at,279
 80043ac:	080045c8 	cmpgei	zero,at,279
 80043b0:	080045b0 	cmpltui	zero,at,278
 80043b4:	080043f4 	orhi	zero,at,271
 80043b8:	080045c8 	cmpgei	zero,at,279
 80043bc:	080045b0 	cmpltui	zero,at,278
 80043c0:	080045c8 	cmpgei	zero,at,279
 80043c4:	080043f4 	orhi	zero,at,271
 80043c8:	080045d8 	cmpnei	zero,at,279
 80043cc:	080045d8 	cmpnei	zero,at,279
 80043d0:	080045d8 	cmpnei	zero,at,279
 80043d4:	08004938 	rdprs	zero,at,292
 80043d8:	2404b03a 	or	r2,r4,r16
 80043dc:	1000711e 	bne	r2,zero,80045a4 <__muldf3+0x300>
 80043e0:	05400204 	movi	r21,8
 80043e4:	0021883a 	mov	r16,zero
 80043e8:	002d883a 	mov	r22,zero
 80043ec:	01400084 	movi	r5,2
 80043f0:	003fcb06 	br	8004320 <__alt_data_end+0xfc004320>
 80043f4:	500d883a 	mov	r6,r10
 80043f8:	00800084 	movi	r2,2
 80043fc:	38805926 	beq	r7,r2,8004564 <__muldf3+0x2c0>
 8004400:	008000c4 	movi	r2,3
 8004404:	3881bb26 	beq	r7,r2,8004af4 <__muldf3+0x850>
 8004408:	00800044 	movi	r2,1
 800440c:	3881961e 	bne	r7,r2,8004a68 <__muldf3+0x7c4>
 8004410:	3027883a 	mov	r19,r6
 8004414:	0005883a 	mov	r2,zero
 8004418:	0021883a 	mov	r16,zero
 800441c:	002d883a 	mov	r22,zero
 8004420:	1004953a 	slli	r2,r2,20
 8004424:	98c03fcc 	andi	r3,r19,255
 8004428:	04400434 	movhi	r17,16
 800442c:	8c7fffc4 	addi	r17,r17,-1
 8004430:	180697fa 	slli	r3,r3,31
 8004434:	8460703a 	and	r16,r16,r17
 8004438:	80a0b03a 	or	r16,r16,r2
 800443c:	80c6b03a 	or	r3,r16,r3
 8004440:	b005883a 	mov	r2,r22
 8004444:	dfc01117 	ldw	ra,68(sp)
 8004448:	df001017 	ldw	fp,64(sp)
 800444c:	ddc00f17 	ldw	r23,60(sp)
 8004450:	dd800e17 	ldw	r22,56(sp)
 8004454:	dd400d17 	ldw	r21,52(sp)
 8004458:	dd000c17 	ldw	r20,48(sp)
 800445c:	dcc00b17 	ldw	r19,44(sp)
 8004460:	dc800a17 	ldw	r18,40(sp)
 8004464:	dc400917 	ldw	r17,36(sp)
 8004468:	dc000817 	ldw	r16,32(sp)
 800446c:	dec01204 	addi	sp,sp,72
 8004470:	f800283a 	ret
 8004474:	2404b03a 	or	r2,r4,r16
 8004478:	202b883a 	mov	r21,r4
 800447c:	10004426 	beq	r2,zero,8004590 <__muldf3+0x2ec>
 8004480:	80015126 	beq	r16,zero,80049c8 <__muldf3+0x724>
 8004484:	8009883a 	mov	r4,r16
 8004488:	d9800715 	stw	r6,28(sp)
 800448c:	d9c00215 	stw	r7,8(sp)
 8004490:	da400415 	stw	r9,16(sp)
 8004494:	8004b100 	call	8004b10 <__clzsi2>
 8004498:	d9800717 	ldw	r6,28(sp)
 800449c:	d9c00217 	ldw	r7,8(sp)
 80044a0:	da400417 	ldw	r9,16(sp)
 80044a4:	113ffd44 	addi	r4,r2,-11
 80044a8:	00c00704 	movi	r3,28
 80044ac:	19014216 	blt	r3,r4,80049b8 <__muldf3+0x714>
 80044b0:	00c00744 	movi	r3,29
 80044b4:	15bffe04 	addi	r22,r2,-8
 80044b8:	1907c83a 	sub	r3,r3,r4
 80044bc:	85a0983a 	sll	r16,r16,r22
 80044c0:	a8c6d83a 	srl	r3,r21,r3
 80044c4:	adac983a 	sll	r22,r21,r22
 80044c8:	1c20b03a 	or	r16,r3,r16
 80044cc:	1080fcc4 	addi	r2,r2,1011
 80044d0:	00a9c83a 	sub	r20,zero,r2
 80044d4:	002b883a 	mov	r21,zero
 80044d8:	000b883a 	mov	r5,zero
 80044dc:	003f9006 	br	8004320 <__alt_data_end+0xfc004320>
 80044e0:	3446b03a 	or	r3,r6,r17
 80044e4:	1800281e 	bne	r3,zero,8004588 <__muldf3+0x2e4>
 80044e8:	0023883a 	mov	r17,zero
 80044ec:	0025883a 	mov	r18,zero
 80044f0:	01c00084 	movi	r7,2
 80044f4:	003f9c06 	br	8004368 <__alt_data_end+0xfc004368>
 80044f8:	3446b03a 	or	r3,r6,r17
 80044fc:	18001e26 	beq	r3,zero,8004578 <__muldf3+0x2d4>
 8004500:	88012126 	beq	r17,zero,8004988 <__muldf3+0x6e4>
 8004504:	8809883a 	mov	r4,r17
 8004508:	d9400215 	stw	r5,8(sp)
 800450c:	d9800715 	stw	r6,28(sp)
 8004510:	da400415 	stw	r9,16(sp)
 8004514:	da800315 	stw	r10,12(sp)
 8004518:	8004b100 	call	8004b10 <__clzsi2>
 800451c:	d9400217 	ldw	r5,8(sp)
 8004520:	d9800717 	ldw	r6,28(sp)
 8004524:	da400417 	ldw	r9,16(sp)
 8004528:	da800317 	ldw	r10,12(sp)
 800452c:	113ffd44 	addi	r4,r2,-11
 8004530:	00c00704 	movi	r3,28
 8004534:	19011016 	blt	r3,r4,8004978 <__muldf3+0x6d4>
 8004538:	00c00744 	movi	r3,29
 800453c:	14bffe04 	addi	r18,r2,-8
 8004540:	1907c83a 	sub	r3,r3,r4
 8004544:	8ca2983a 	sll	r17,r17,r18
 8004548:	30c6d83a 	srl	r3,r6,r3
 800454c:	34a4983a 	sll	r18,r6,r18
 8004550:	1c62b03a 	or	r17,r3,r17
 8004554:	1080fcc4 	addi	r2,r2,1011
 8004558:	0085c83a 	sub	r2,zero,r2
 800455c:	000f883a 	mov	r7,zero
 8004560:	003f8106 	br	8004368 <__alt_data_end+0xfc004368>
 8004564:	3027883a 	mov	r19,r6
 8004568:	0081ffc4 	movi	r2,2047
 800456c:	0021883a 	mov	r16,zero
 8004570:	002d883a 	mov	r22,zero
 8004574:	003faa06 	br	8004420 <__alt_data_end+0xfc004420>
 8004578:	0023883a 	mov	r17,zero
 800457c:	0025883a 	mov	r18,zero
 8004580:	01c00044 	movi	r7,1
 8004584:	003f7806 	br	8004368 <__alt_data_end+0xfc004368>
 8004588:	01c000c4 	movi	r7,3
 800458c:	003f7606 	br	8004368 <__alt_data_end+0xfc004368>
 8004590:	05400104 	movi	r21,4
 8004594:	0021883a 	mov	r16,zero
 8004598:	002d883a 	mov	r22,zero
 800459c:	01400044 	movi	r5,1
 80045a0:	003f5f06 	br	8004320 <__alt_data_end+0xfc004320>
 80045a4:	05400304 	movi	r21,12
 80045a8:	014000c4 	movi	r5,3
 80045ac:	003f5c06 	br	8004320 <__alt_data_end+0xfc004320>
 80045b0:	04000434 	movhi	r16,16
 80045b4:	0027883a 	mov	r19,zero
 80045b8:	843fffc4 	addi	r16,r16,-1
 80045bc:	05bfffc4 	movi	r22,-1
 80045c0:	0081ffc4 	movi	r2,2047
 80045c4:	003f9606 	br	8004420 <__alt_data_end+0xfc004420>
 80045c8:	8023883a 	mov	r17,r16
 80045cc:	b025883a 	mov	r18,r22
 80045d0:	280f883a 	mov	r7,r5
 80045d4:	003f8806 	br	80043f8 <__alt_data_end+0xfc0043f8>
 80045d8:	8023883a 	mov	r17,r16
 80045dc:	b025883a 	mov	r18,r22
 80045e0:	480d883a 	mov	r6,r9
 80045e4:	280f883a 	mov	r7,r5
 80045e8:	003f8306 	br	80043f8 <__alt_data_end+0xfc0043f8>
 80045ec:	b026d43a 	srli	r19,r22,16
 80045f0:	902ed43a 	srli	r23,r18,16
 80045f4:	b5bfffcc 	andi	r22,r22,65535
 80045f8:	94bfffcc 	andi	r18,r18,65535
 80045fc:	b00b883a 	mov	r5,r22
 8004600:	9009883a 	mov	r4,r18
 8004604:	d8c00515 	stw	r3,20(sp)
 8004608:	d9800715 	stw	r6,28(sp)
 800460c:	da000615 	stw	r8,24(sp)
 8004610:	8004b740 	call	8004b74 <__mulsi3>
 8004614:	980b883a 	mov	r5,r19
 8004618:	9009883a 	mov	r4,r18
 800461c:	1029883a 	mov	r20,r2
 8004620:	8004b740 	call	8004b74 <__mulsi3>
 8004624:	b80b883a 	mov	r5,r23
 8004628:	9809883a 	mov	r4,r19
 800462c:	102b883a 	mov	r21,r2
 8004630:	8004b740 	call	8004b74 <__mulsi3>
 8004634:	b809883a 	mov	r4,r23
 8004638:	b00b883a 	mov	r5,r22
 800463c:	1039883a 	mov	fp,r2
 8004640:	8004b740 	call	8004b74 <__mulsi3>
 8004644:	a008d43a 	srli	r4,r20,16
 8004648:	1545883a 	add	r2,r2,r21
 800464c:	d8c00517 	ldw	r3,20(sp)
 8004650:	2085883a 	add	r2,r4,r2
 8004654:	d9800717 	ldw	r6,28(sp)
 8004658:	da000617 	ldw	r8,24(sp)
 800465c:	1540022e 	bgeu	r2,r21,8004668 <__muldf3+0x3c4>
 8004660:	01000074 	movhi	r4,1
 8004664:	e139883a 	add	fp,fp,r4
 8004668:	100e943a 	slli	r7,r2,16
 800466c:	1004d43a 	srli	r2,r2,16
 8004670:	882ad43a 	srli	r21,r17,16
 8004674:	a53fffcc 	andi	r20,r20,65535
 8004678:	8c7fffcc 	andi	r17,r17,65535
 800467c:	3d29883a 	add	r20,r7,r20
 8004680:	b00b883a 	mov	r5,r22
 8004684:	8809883a 	mov	r4,r17
 8004688:	d8c00515 	stw	r3,20(sp)
 800468c:	d9800715 	stw	r6,28(sp)
 8004690:	da000615 	stw	r8,24(sp)
 8004694:	dd000115 	stw	r20,4(sp)
 8004698:	d8800015 	stw	r2,0(sp)
 800469c:	8004b740 	call	8004b74 <__mulsi3>
 80046a0:	980b883a 	mov	r5,r19
 80046a4:	8809883a 	mov	r4,r17
 80046a8:	d8800215 	stw	r2,8(sp)
 80046ac:	8004b740 	call	8004b74 <__mulsi3>
 80046b0:	9809883a 	mov	r4,r19
 80046b4:	a80b883a 	mov	r5,r21
 80046b8:	1029883a 	mov	r20,r2
 80046bc:	8004b740 	call	8004b74 <__mulsi3>
 80046c0:	b00b883a 	mov	r5,r22
 80046c4:	a809883a 	mov	r4,r21
 80046c8:	d8800415 	stw	r2,16(sp)
 80046cc:	8004b740 	call	8004b74 <__mulsi3>
 80046d0:	d9c00217 	ldw	r7,8(sp)
 80046d4:	1505883a 	add	r2,r2,r20
 80046d8:	d8c00517 	ldw	r3,20(sp)
 80046dc:	3826d43a 	srli	r19,r7,16
 80046e0:	d9800717 	ldw	r6,28(sp)
 80046e4:	da000617 	ldw	r8,24(sp)
 80046e8:	9885883a 	add	r2,r19,r2
 80046ec:	da400417 	ldw	r9,16(sp)
 80046f0:	1500022e 	bgeu	r2,r20,80046fc <__muldf3+0x458>
 80046f4:	01000074 	movhi	r4,1
 80046f8:	4913883a 	add	r9,r9,r4
 80046fc:	1028d43a 	srli	r20,r2,16
 8004700:	1004943a 	slli	r2,r2,16
 8004704:	802cd43a 	srli	r22,r16,16
 8004708:	843fffcc 	andi	r16,r16,65535
 800470c:	3cffffcc 	andi	r19,r7,65535
 8004710:	9009883a 	mov	r4,r18
 8004714:	800b883a 	mov	r5,r16
 8004718:	a269883a 	add	r20,r20,r9
 800471c:	d8c00515 	stw	r3,20(sp)
 8004720:	d9800715 	stw	r6,28(sp)
 8004724:	da000615 	stw	r8,24(sp)
 8004728:	14e7883a 	add	r19,r2,r19
 800472c:	8004b740 	call	8004b74 <__mulsi3>
 8004730:	9009883a 	mov	r4,r18
 8004734:	b00b883a 	mov	r5,r22
 8004738:	d8800315 	stw	r2,12(sp)
 800473c:	8004b740 	call	8004b74 <__mulsi3>
 8004740:	b809883a 	mov	r4,r23
 8004744:	b00b883a 	mov	r5,r22
 8004748:	d8800215 	stw	r2,8(sp)
 800474c:	8004b740 	call	8004b74 <__mulsi3>
 8004750:	b80b883a 	mov	r5,r23
 8004754:	8009883a 	mov	r4,r16
 8004758:	d8800415 	stw	r2,16(sp)
 800475c:	8004b740 	call	8004b74 <__mulsi3>
 8004760:	da800317 	ldw	r10,12(sp)
 8004764:	d9c00217 	ldw	r7,8(sp)
 8004768:	d9000017 	ldw	r4,0(sp)
 800476c:	502ed43a 	srli	r23,r10,16
 8004770:	11c5883a 	add	r2,r2,r7
 8004774:	24e5883a 	add	r18,r4,r19
 8004778:	b885883a 	add	r2,r23,r2
 800477c:	d8c00517 	ldw	r3,20(sp)
 8004780:	d9800717 	ldw	r6,28(sp)
 8004784:	da000617 	ldw	r8,24(sp)
 8004788:	da400417 	ldw	r9,16(sp)
 800478c:	11c0022e 	bgeu	r2,r7,8004798 <__muldf3+0x4f4>
 8004790:	01000074 	movhi	r4,1
 8004794:	4913883a 	add	r9,r9,r4
 8004798:	100ed43a 	srli	r7,r2,16
 800479c:	1004943a 	slli	r2,r2,16
 80047a0:	55ffffcc 	andi	r23,r10,65535
 80047a4:	3a53883a 	add	r9,r7,r9
 80047a8:	8809883a 	mov	r4,r17
 80047ac:	800b883a 	mov	r5,r16
 80047b0:	d8c00515 	stw	r3,20(sp)
 80047b4:	d9800715 	stw	r6,28(sp)
 80047b8:	da000615 	stw	r8,24(sp)
 80047bc:	da400415 	stw	r9,16(sp)
 80047c0:	15ef883a 	add	r23,r2,r23
 80047c4:	8004b740 	call	8004b74 <__mulsi3>
 80047c8:	8809883a 	mov	r4,r17
 80047cc:	b00b883a 	mov	r5,r22
 80047d0:	d8800215 	stw	r2,8(sp)
 80047d4:	8004b740 	call	8004b74 <__mulsi3>
 80047d8:	b00b883a 	mov	r5,r22
 80047dc:	a809883a 	mov	r4,r21
 80047e0:	d8800315 	stw	r2,12(sp)
 80047e4:	8004b740 	call	8004b74 <__mulsi3>
 80047e8:	8009883a 	mov	r4,r16
 80047ec:	a80b883a 	mov	r5,r21
 80047f0:	1023883a 	mov	r17,r2
 80047f4:	8004b740 	call	8004b74 <__mulsi3>
 80047f8:	d9c00217 	ldw	r7,8(sp)
 80047fc:	da800317 	ldw	r10,12(sp)
 8004800:	d8c00517 	ldw	r3,20(sp)
 8004804:	3808d43a 	srli	r4,r7,16
 8004808:	1285883a 	add	r2,r2,r10
 800480c:	d9800717 	ldw	r6,28(sp)
 8004810:	2085883a 	add	r2,r4,r2
 8004814:	da000617 	ldw	r8,24(sp)
 8004818:	da400417 	ldw	r9,16(sp)
 800481c:	1280022e 	bgeu	r2,r10,8004828 <__muldf3+0x584>
 8004820:	01000074 	movhi	r4,1
 8004824:	8923883a 	add	r17,r17,r4
 8004828:	1008943a 	slli	r4,r2,16
 800482c:	39ffffcc 	andi	r7,r7,65535
 8004830:	e4b9883a 	add	fp,fp,r18
 8004834:	21cf883a 	add	r7,r4,r7
 8004838:	e4e7803a 	cmpltu	r19,fp,r19
 800483c:	3d0f883a 	add	r7,r7,r20
 8004840:	bf39883a 	add	fp,r23,fp
 8004844:	99c9883a 	add	r4,r19,r7
 8004848:	e5ef803a 	cmpltu	r23,fp,r23
 800484c:	490b883a 	add	r5,r9,r4
 8004850:	1004d43a 	srli	r2,r2,16
 8004854:	b965883a 	add	r18,r23,r5
 8004858:	24c9803a 	cmpltu	r4,r4,r19
 800485c:	3d29803a 	cmpltu	r20,r7,r20
 8004860:	a128b03a 	or	r20,r20,r4
 8004864:	95ef803a 	cmpltu	r23,r18,r23
 8004868:	2a53803a 	cmpltu	r9,r5,r9
 800486c:	a0a9883a 	add	r20,r20,r2
 8004870:	4deeb03a 	or	r23,r9,r23
 8004874:	a5ef883a 	add	r23,r20,r23
 8004878:	bc63883a 	add	r17,r23,r17
 800487c:	e004927a 	slli	r2,fp,9
 8004880:	d9000117 	ldw	r4,4(sp)
 8004884:	882e927a 	slli	r23,r17,9
 8004888:	9022d5fa 	srli	r17,r18,23
 800488c:	e038d5fa 	srli	fp,fp,23
 8004890:	1104b03a 	or	r2,r2,r4
 8004894:	9024927a 	slli	r18,r18,9
 8004898:	1004c03a 	cmpne	r2,r2,zero
 800489c:	bc62b03a 	or	r17,r23,r17
 80048a0:	1738b03a 	or	fp,r2,fp
 80048a4:	8880402c 	andhi	r2,r17,256
 80048a8:	e4a4b03a 	or	r18,fp,r18
 80048ac:	10000726 	beq	r2,zero,80048cc <__muldf3+0x628>
 80048b0:	9006d07a 	srli	r3,r18,1
 80048b4:	880497fa 	slli	r2,r17,31
 80048b8:	9480004c 	andi	r18,r18,1
 80048bc:	8822d07a 	srli	r17,r17,1
 80048c0:	1ca4b03a 	or	r18,r3,r18
 80048c4:	14a4b03a 	or	r18,r2,r18
 80048c8:	4007883a 	mov	r3,r8
 80048cc:	1880ffc4 	addi	r2,r3,1023
 80048d0:	0080460e 	bge	zero,r2,80049ec <__muldf3+0x748>
 80048d4:	910001cc 	andi	r4,r18,7
 80048d8:	20000726 	beq	r4,zero,80048f8 <__muldf3+0x654>
 80048dc:	910003cc 	andi	r4,r18,15
 80048e0:	01400104 	movi	r5,4
 80048e4:	21400426 	beq	r4,r5,80048f8 <__muldf3+0x654>
 80048e8:	9149883a 	add	r4,r18,r5
 80048ec:	24a5803a 	cmpltu	r18,r4,r18
 80048f0:	8ca3883a 	add	r17,r17,r18
 80048f4:	2025883a 	mov	r18,r4
 80048f8:	8900402c 	andhi	r4,r17,256
 80048fc:	20000426 	beq	r4,zero,8004910 <__muldf3+0x66c>
 8004900:	18810004 	addi	r2,r3,1024
 8004904:	00ffc034 	movhi	r3,65280
 8004908:	18ffffc4 	addi	r3,r3,-1
 800490c:	88e2703a 	and	r17,r17,r3
 8004910:	00c1ff84 	movi	r3,2046
 8004914:	18bf1316 	blt	r3,r2,8004564 <__alt_data_end+0xfc004564>
 8004918:	882c977a 	slli	r22,r17,29
 800491c:	9024d0fa 	srli	r18,r18,3
 8004920:	8822927a 	slli	r17,r17,9
 8004924:	1081ffcc 	andi	r2,r2,2047
 8004928:	b4acb03a 	or	r22,r22,r18
 800492c:	8820d33a 	srli	r16,r17,12
 8004930:	3027883a 	mov	r19,r6
 8004934:	003eba06 	br	8004420 <__alt_data_end+0xfc004420>
 8004938:	8080022c 	andhi	r2,r16,8
 800493c:	10000926 	beq	r2,zero,8004964 <__muldf3+0x6c0>
 8004940:	8880022c 	andhi	r2,r17,8
 8004944:	1000071e 	bne	r2,zero,8004964 <__muldf3+0x6c0>
 8004948:	00800434 	movhi	r2,16
 800494c:	8c000234 	orhi	r16,r17,8
 8004950:	10bfffc4 	addi	r2,r2,-1
 8004954:	e027883a 	mov	r19,fp
 8004958:	80a0703a 	and	r16,r16,r2
 800495c:	902d883a 	mov	r22,r18
 8004960:	003f1706 	br	80045c0 <__alt_data_end+0xfc0045c0>
 8004964:	00800434 	movhi	r2,16
 8004968:	84000234 	orhi	r16,r16,8
 800496c:	10bfffc4 	addi	r2,r2,-1
 8004970:	80a0703a 	and	r16,r16,r2
 8004974:	003f1206 	br	80045c0 <__alt_data_end+0xfc0045c0>
 8004978:	147ff604 	addi	r17,r2,-40
 800497c:	3462983a 	sll	r17,r6,r17
 8004980:	0025883a 	mov	r18,zero
 8004984:	003ef306 	br	8004554 <__alt_data_end+0xfc004554>
 8004988:	3009883a 	mov	r4,r6
 800498c:	d9400215 	stw	r5,8(sp)
 8004990:	d9800715 	stw	r6,28(sp)
 8004994:	da400415 	stw	r9,16(sp)
 8004998:	da800315 	stw	r10,12(sp)
 800499c:	8004b100 	call	8004b10 <__clzsi2>
 80049a0:	10800804 	addi	r2,r2,32
 80049a4:	da800317 	ldw	r10,12(sp)
 80049a8:	da400417 	ldw	r9,16(sp)
 80049ac:	d9800717 	ldw	r6,28(sp)
 80049b0:	d9400217 	ldw	r5,8(sp)
 80049b4:	003edd06 	br	800452c <__alt_data_end+0xfc00452c>
 80049b8:	143ff604 	addi	r16,r2,-40
 80049bc:	ac20983a 	sll	r16,r21,r16
 80049c0:	002d883a 	mov	r22,zero
 80049c4:	003ec106 	br	80044cc <__alt_data_end+0xfc0044cc>
 80049c8:	d9800715 	stw	r6,28(sp)
 80049cc:	d9c00215 	stw	r7,8(sp)
 80049d0:	da400415 	stw	r9,16(sp)
 80049d4:	8004b100 	call	8004b10 <__clzsi2>
 80049d8:	10800804 	addi	r2,r2,32
 80049dc:	da400417 	ldw	r9,16(sp)
 80049e0:	d9c00217 	ldw	r7,8(sp)
 80049e4:	d9800717 	ldw	r6,28(sp)
 80049e8:	003eae06 	br	80044a4 <__alt_data_end+0xfc0044a4>
 80049ec:	00c00044 	movi	r3,1
 80049f0:	1887c83a 	sub	r3,r3,r2
 80049f4:	01000e04 	movi	r4,56
 80049f8:	20fe8516 	blt	r4,r3,8004410 <__alt_data_end+0xfc004410>
 80049fc:	010007c4 	movi	r4,31
 8004a00:	20c01b16 	blt	r4,r3,8004a70 <__muldf3+0x7cc>
 8004a04:	00800804 	movi	r2,32
 8004a08:	10c5c83a 	sub	r2,r2,r3
 8004a0c:	888a983a 	sll	r5,r17,r2
 8004a10:	90c8d83a 	srl	r4,r18,r3
 8004a14:	9084983a 	sll	r2,r18,r2
 8004a18:	88e2d83a 	srl	r17,r17,r3
 8004a1c:	2906b03a 	or	r3,r5,r4
 8004a20:	1004c03a 	cmpne	r2,r2,zero
 8004a24:	1886b03a 	or	r3,r3,r2
 8004a28:	188001cc 	andi	r2,r3,7
 8004a2c:	10000726 	beq	r2,zero,8004a4c <__muldf3+0x7a8>
 8004a30:	188003cc 	andi	r2,r3,15
 8004a34:	01000104 	movi	r4,4
 8004a38:	11000426 	beq	r2,r4,8004a4c <__muldf3+0x7a8>
 8004a3c:	1805883a 	mov	r2,r3
 8004a40:	10c00104 	addi	r3,r2,4
 8004a44:	1885803a 	cmpltu	r2,r3,r2
 8004a48:	88a3883a 	add	r17,r17,r2
 8004a4c:	8880202c 	andhi	r2,r17,128
 8004a50:	10001c26 	beq	r2,zero,8004ac4 <__muldf3+0x820>
 8004a54:	3027883a 	mov	r19,r6
 8004a58:	00800044 	movi	r2,1
 8004a5c:	0021883a 	mov	r16,zero
 8004a60:	002d883a 	mov	r22,zero
 8004a64:	003e6e06 	br	8004420 <__alt_data_end+0xfc004420>
 8004a68:	4007883a 	mov	r3,r8
 8004a6c:	003f9706 	br	80048cc <__alt_data_end+0xfc0048cc>
 8004a70:	017ff844 	movi	r5,-31
 8004a74:	2885c83a 	sub	r2,r5,r2
 8004a78:	888ad83a 	srl	r5,r17,r2
 8004a7c:	00800804 	movi	r2,32
 8004a80:	18801a26 	beq	r3,r2,8004aec <__muldf3+0x848>
 8004a84:	01001004 	movi	r4,64
 8004a88:	20c7c83a 	sub	r3,r4,r3
 8004a8c:	88e2983a 	sll	r17,r17,r3
 8004a90:	8ca4b03a 	or	r18,r17,r18
 8004a94:	9004c03a 	cmpne	r2,r18,zero
 8004a98:	2884b03a 	or	r2,r5,r2
 8004a9c:	144001cc 	andi	r17,r2,7
 8004aa0:	88000d1e 	bne	r17,zero,8004ad8 <__muldf3+0x834>
 8004aa4:	0021883a 	mov	r16,zero
 8004aa8:	102cd0fa 	srli	r22,r2,3
 8004aac:	3027883a 	mov	r19,r6
 8004ab0:	0005883a 	mov	r2,zero
 8004ab4:	b46cb03a 	or	r22,r22,r17
 8004ab8:	003e5906 	br	8004420 <__alt_data_end+0xfc004420>
 8004abc:	1007883a 	mov	r3,r2
 8004ac0:	0023883a 	mov	r17,zero
 8004ac4:	8820927a 	slli	r16,r17,9
 8004ac8:	1805883a 	mov	r2,r3
 8004acc:	8822977a 	slli	r17,r17,29
 8004ad0:	8020d33a 	srli	r16,r16,12
 8004ad4:	003ff406 	br	8004aa8 <__alt_data_end+0xfc004aa8>
 8004ad8:	10c003cc 	andi	r3,r2,15
 8004adc:	01000104 	movi	r4,4
 8004ae0:	193ff626 	beq	r3,r4,8004abc <__alt_data_end+0xfc004abc>
 8004ae4:	0023883a 	mov	r17,zero
 8004ae8:	003fd506 	br	8004a40 <__alt_data_end+0xfc004a40>
 8004aec:	0023883a 	mov	r17,zero
 8004af0:	003fe706 	br	8004a90 <__alt_data_end+0xfc004a90>
 8004af4:	00800434 	movhi	r2,16
 8004af8:	8c000234 	orhi	r16,r17,8
 8004afc:	10bfffc4 	addi	r2,r2,-1
 8004b00:	3027883a 	mov	r19,r6
 8004b04:	80a0703a 	and	r16,r16,r2
 8004b08:	902d883a 	mov	r22,r18
 8004b0c:	003eac06 	br	80045c0 <__alt_data_end+0xfc0045c0>

08004b10 <__clzsi2>:
 8004b10:	00bfffd4 	movui	r2,65535
 8004b14:	11000536 	bltu	r2,r4,8004b2c <__clzsi2+0x1c>
 8004b18:	00803fc4 	movi	r2,255
 8004b1c:	11000f36 	bltu	r2,r4,8004b5c <__clzsi2+0x4c>
 8004b20:	00800804 	movi	r2,32
 8004b24:	0007883a 	mov	r3,zero
 8004b28:	00000506 	br	8004b40 <__clzsi2+0x30>
 8004b2c:	00804034 	movhi	r2,256
 8004b30:	10bfffc4 	addi	r2,r2,-1
 8004b34:	11000c2e 	bgeu	r2,r4,8004b68 <__clzsi2+0x58>
 8004b38:	00800204 	movi	r2,8
 8004b3c:	00c00604 	movi	r3,24
 8004b40:	20c8d83a 	srl	r4,r4,r3
 8004b44:	00c20034 	movhi	r3,2048
 8004b48:	18d9cd84 	addi	r3,r3,26422
 8004b4c:	1909883a 	add	r4,r3,r4
 8004b50:	20c00003 	ldbu	r3,0(r4)
 8004b54:	10c5c83a 	sub	r2,r2,r3
 8004b58:	f800283a 	ret
 8004b5c:	00800604 	movi	r2,24
 8004b60:	00c00204 	movi	r3,8
 8004b64:	003ff606 	br	8004b40 <__alt_data_end+0xfc004b40>
 8004b68:	00800404 	movi	r2,16
 8004b6c:	1007883a 	mov	r3,r2
 8004b70:	003ff306 	br	8004b40 <__alt_data_end+0xfc004b40>

08004b74 <__mulsi3>:
 8004b74:	0005883a 	mov	r2,zero
 8004b78:	20000726 	beq	r4,zero,8004b98 <__mulsi3+0x24>
 8004b7c:	20c0004c 	andi	r3,r4,1
 8004b80:	2008d07a 	srli	r4,r4,1
 8004b84:	18000126 	beq	r3,zero,8004b8c <__mulsi3+0x18>
 8004b88:	1145883a 	add	r2,r2,r5
 8004b8c:	294b883a 	add	r5,r5,r5
 8004b90:	203ffa1e 	bne	r4,zero,8004b7c <__alt_data_end+0xfc004b7c>
 8004b94:	f800283a 	ret
 8004b98:	f800283a 	ret

08004b9c <clock>:
 8004b9c:	00820034 	movhi	r2,2048
 8004ba0:	109a4f04 	addi	r2,r2,26940
 8004ba4:	11000017 	ldw	r4,0(r2)
 8004ba8:	defffb04 	addi	sp,sp,-20
 8004bac:	d80b883a 	mov	r5,sp
 8004bb0:	dfc00415 	stw	ra,16(sp)
 8004bb4:	8004dd80 	call	8004dd8 <_times_r>
 8004bb8:	00ffffc4 	movi	r3,-1
 8004bbc:	10c00726 	beq	r2,r3,8004bdc <clock+0x40>
 8004bc0:	d8c00017 	ldw	r3,0(sp)
 8004bc4:	d8800117 	ldw	r2,4(sp)
 8004bc8:	1885883a 	add	r2,r3,r2
 8004bcc:	d8c00217 	ldw	r3,8(sp)
 8004bd0:	10c5883a 	add	r2,r2,r3
 8004bd4:	d8c00317 	ldw	r3,12(sp)
 8004bd8:	10c5883a 	add	r2,r2,r3
 8004bdc:	dfc00417 	ldw	ra,16(sp)
 8004be0:	dec00504 	addi	sp,sp,20
 8004be4:	f800283a 	ret

08004be8 <difftime>:
 8004be8:	deffff04 	addi	sp,sp,-4
 8004bec:	2149c83a 	sub	r4,r4,r5
 8004bf0:	dfc00015 	stw	ra,0(sp)
 8004bf4:	80057740 	call	8005774 <__floatsidf>
 8004bf8:	dfc00017 	ldw	ra,0(sp)
 8004bfc:	dec00104 	addi	sp,sp,4
 8004c00:	f800283a 	ret

08004c04 <memcmp>:
 8004c04:	218d883a 	add	r6,r4,r6
 8004c08:	21800826 	beq	r4,r6,8004c2c <memcmp+0x28>
 8004c0c:	20800003 	ldbu	r2,0(r4)
 8004c10:	28c00003 	ldbu	r3,0(r5)
 8004c14:	10c00226 	beq	r2,r3,8004c20 <memcmp+0x1c>
 8004c18:	10c5c83a 	sub	r2,r2,r3
 8004c1c:	f800283a 	ret
 8004c20:	21000044 	addi	r4,r4,1
 8004c24:	29400044 	addi	r5,r5,1
 8004c28:	003ff706 	br	8004c08 <__alt_data_end+0xfc004c08>
 8004c2c:	0005883a 	mov	r2,zero
 8004c30:	f800283a 	ret

08004c34 <memcpy>:
 8004c34:	2005883a 	mov	r2,r4
 8004c38:	2007883a 	mov	r3,r4
 8004c3c:	218d883a 	add	r6,r4,r6
 8004c40:	19800526 	beq	r3,r6,8004c58 <memcpy+0x24>
 8004c44:	29000003 	ldbu	r4,0(r5)
 8004c48:	18c00044 	addi	r3,r3,1
 8004c4c:	29400044 	addi	r5,r5,1
 8004c50:	193fffc5 	stb	r4,-1(r3)
 8004c54:	003ffa06 	br	8004c40 <__alt_data_end+0xfc004c40>
 8004c58:	f800283a 	ret

08004c5c <memset>:
 8004c5c:	2005883a 	mov	r2,r4
 8004c60:	2007883a 	mov	r3,r4
 8004c64:	218d883a 	add	r6,r4,r6
 8004c68:	19800326 	beq	r3,r6,8004c78 <memset+0x1c>
 8004c6c:	19400005 	stb	r5,0(r3)
 8004c70:	18c00044 	addi	r3,r3,1
 8004c74:	003ffc06 	br	8004c68 <__alt_data_end+0xfc004c68>
 8004c78:	f800283a 	ret

08004c7c <_printf_r>:
 8004c7c:	defffd04 	addi	sp,sp,-12
 8004c80:	dfc00015 	stw	ra,0(sp)
 8004c84:	d9800115 	stw	r6,4(sp)
 8004c88:	d9c00215 	stw	r7,8(sp)
 8004c8c:	20c00217 	ldw	r3,8(r4)
 8004c90:	01820034 	movhi	r6,2048
 8004c94:	3194e504 	addi	r6,r6,21396
 8004c98:	19800115 	stw	r6,4(r3)
 8004c9c:	280d883a 	mov	r6,r5
 8004ca0:	21400217 	ldw	r5,8(r4)
 8004ca4:	d9c00104 	addi	r7,sp,4
 8004ca8:	8004e4c0 	call	8004e4c <___vfprintf_internal_r>
 8004cac:	dfc00017 	ldw	ra,0(sp)
 8004cb0:	dec00304 	addi	sp,sp,12
 8004cb4:	f800283a 	ret

08004cb8 <printf>:
 8004cb8:	defffc04 	addi	sp,sp,-16
 8004cbc:	dfc00015 	stw	ra,0(sp)
 8004cc0:	d9400115 	stw	r5,4(sp)
 8004cc4:	d9800215 	stw	r6,8(sp)
 8004cc8:	d9c00315 	stw	r7,12(sp)
 8004ccc:	00820034 	movhi	r2,2048
 8004cd0:	109a4f04 	addi	r2,r2,26940
 8004cd4:	10800017 	ldw	r2,0(r2)
 8004cd8:	01420034 	movhi	r5,2048
 8004cdc:	2954e504 	addi	r5,r5,21396
 8004ce0:	10c00217 	ldw	r3,8(r2)
 8004ce4:	d9800104 	addi	r6,sp,4
 8004ce8:	19400115 	stw	r5,4(r3)
 8004cec:	200b883a 	mov	r5,r4
 8004cf0:	11000217 	ldw	r4,8(r2)
 8004cf4:	80053780 	call	8005378 <__vfprintf_internal>
 8004cf8:	dfc00017 	ldw	ra,0(sp)
 8004cfc:	dec00404 	addi	sp,sp,16
 8004d00:	f800283a 	ret

08004d04 <_putchar_r>:
 8004d04:	21800217 	ldw	r6,8(r4)
 8004d08:	80054f41 	jmpi	80054f4 <_putc_r>

08004d0c <putchar>:
 8004d0c:	00820034 	movhi	r2,2048
 8004d10:	109a4f04 	addi	r2,r2,26940
 8004d14:	10800017 	ldw	r2,0(r2)
 8004d18:	200b883a 	mov	r5,r4
 8004d1c:	11800217 	ldw	r6,8(r2)
 8004d20:	1009883a 	mov	r4,r2
 8004d24:	80054f41 	jmpi	80054f4 <_putc_r>

08004d28 <strncmp>:
 8004d28:	30001526 	beq	r6,zero,8004d80 <strncmp+0x58>
 8004d2c:	31bfffc4 	addi	r6,r6,-1
 8004d30:	218d883a 	add	r6,r4,r6
 8004d34:	20800003 	ldbu	r2,0(r4)
 8004d38:	28c00003 	ldbu	r3,0(r5)
 8004d3c:	11c03fcc 	andi	r7,r2,255
 8004d40:	1a003fcc 	andi	r8,r3,255
 8004d44:	39c0201c 	xori	r7,r7,128
 8004d48:	4200201c 	xori	r8,r8,128
 8004d4c:	39ffe004 	addi	r7,r7,-128
 8004d50:	423fe004 	addi	r8,r8,-128
 8004d54:	3a00061e 	bne	r7,r8,8004d70 <strncmp+0x48>
 8004d58:	21800426 	beq	r4,r6,8004d6c <strncmp+0x44>
 8004d5c:	38000326 	beq	r7,zero,8004d6c <strncmp+0x44>
 8004d60:	21000044 	addi	r4,r4,1
 8004d64:	29400044 	addi	r5,r5,1
 8004d68:	003ff206 	br	8004d34 <__alt_data_end+0xfc004d34>
 8004d6c:	1007883a 	mov	r3,r2
 8004d70:	18c03fcc 	andi	r3,r3,255
 8004d74:	10803fcc 	andi	r2,r2,255
 8004d78:	10c5c83a 	sub	r2,r2,r3
 8004d7c:	f800283a 	ret
 8004d80:	0005883a 	mov	r2,zero
 8004d84:	f800283a 	ret

08004d88 <time>:
 8004d88:	00820034 	movhi	r2,2048
 8004d8c:	defffc04 	addi	sp,sp,-16
 8004d90:	109a4f04 	addi	r2,r2,26940
 8004d94:	dc000215 	stw	r16,8(sp)
 8004d98:	2021883a 	mov	r16,r4
 8004d9c:	11000017 	ldw	r4,0(r2)
 8004da0:	000d883a 	mov	r6,zero
 8004da4:	d80b883a 	mov	r5,sp
 8004da8:	dfc00315 	stw	ra,12(sp)
 8004dac:	800544c0 	call	800544c <_gettimeofday_r>
 8004db0:	10000416 	blt	r2,zero,8004dc4 <time+0x3c>
 8004db4:	d8800017 	ldw	r2,0(sp)
 8004db8:	80000326 	beq	r16,zero,8004dc8 <time+0x40>
 8004dbc:	80800015 	stw	r2,0(r16)
 8004dc0:	00000106 	br	8004dc8 <time+0x40>
 8004dc4:	00bfffc4 	movi	r2,-1
 8004dc8:	dfc00317 	ldw	ra,12(sp)
 8004dcc:	dc000217 	ldw	r16,8(sp)
 8004dd0:	dec00404 	addi	sp,sp,16
 8004dd4:	f800283a 	ret

08004dd8 <_times_r>:
 8004dd8:	2809883a 	mov	r4,r5
 8004ddc:	8005c841 	jmpi	8005c84 <times>

08004de0 <print_repeat>:
 8004de0:	defffb04 	addi	sp,sp,-20
 8004de4:	dc800315 	stw	r18,12(sp)
 8004de8:	dc400215 	stw	r17,8(sp)
 8004dec:	dc000115 	stw	r16,4(sp)
 8004df0:	dfc00415 	stw	ra,16(sp)
 8004df4:	2025883a 	mov	r18,r4
 8004df8:	2823883a 	mov	r17,r5
 8004dfc:	d9800005 	stb	r6,0(sp)
 8004e00:	3821883a 	mov	r16,r7
 8004e04:	04000a0e 	bge	zero,r16,8004e30 <print_repeat+0x50>
 8004e08:	88800117 	ldw	r2,4(r17)
 8004e0c:	01c00044 	movi	r7,1
 8004e10:	d80d883a 	mov	r6,sp
 8004e14:	880b883a 	mov	r5,r17
 8004e18:	9009883a 	mov	r4,r18
 8004e1c:	103ee83a 	callr	r2
 8004e20:	843fffc4 	addi	r16,r16,-1
 8004e24:	103ff726 	beq	r2,zero,8004e04 <__alt_data_end+0xfc004e04>
 8004e28:	00bfffc4 	movi	r2,-1
 8004e2c:	00000106 	br	8004e34 <print_repeat+0x54>
 8004e30:	0005883a 	mov	r2,zero
 8004e34:	dfc00417 	ldw	ra,16(sp)
 8004e38:	dc800317 	ldw	r18,12(sp)
 8004e3c:	dc400217 	ldw	r17,8(sp)
 8004e40:	dc000117 	ldw	r16,4(sp)
 8004e44:	dec00504 	addi	sp,sp,20
 8004e48:	f800283a 	ret

08004e4c <___vfprintf_internal_r>:
 8004e4c:	deffe504 	addi	sp,sp,-108
 8004e50:	d8c00804 	addi	r3,sp,32
 8004e54:	ddc01815 	stw	r23,96(sp)
 8004e58:	dd801715 	stw	r22,92(sp)
 8004e5c:	dd401615 	stw	r21,88(sp)
 8004e60:	dd001515 	stw	r20,84(sp)
 8004e64:	dcc01415 	stw	r19,80(sp)
 8004e68:	dc801315 	stw	r18,76(sp)
 8004e6c:	dc401215 	stw	r17,72(sp)
 8004e70:	dc001115 	stw	r16,68(sp)
 8004e74:	dfc01a15 	stw	ra,104(sp)
 8004e78:	df001915 	stw	fp,100(sp)
 8004e7c:	2029883a 	mov	r20,r4
 8004e80:	2823883a 	mov	r17,r5
 8004e84:	382d883a 	mov	r22,r7
 8004e88:	d9800f15 	stw	r6,60(sp)
 8004e8c:	0021883a 	mov	r16,zero
 8004e90:	d8000e15 	stw	zero,56(sp)
 8004e94:	d8000a15 	stw	zero,40(sp)
 8004e98:	002b883a 	mov	r21,zero
 8004e9c:	0027883a 	mov	r19,zero
 8004ea0:	0025883a 	mov	r18,zero
 8004ea4:	d8000c15 	stw	zero,48(sp)
 8004ea8:	d8000b15 	stw	zero,44(sp)
 8004eac:	002f883a 	mov	r23,zero
 8004eb0:	d8c00915 	stw	r3,36(sp)
 8004eb4:	d8c00f17 	ldw	r3,60(sp)
 8004eb8:	19000003 	ldbu	r4,0(r3)
 8004ebc:	20803fcc 	andi	r2,r4,255
 8004ec0:	1080201c 	xori	r2,r2,128
 8004ec4:	10bfe004 	addi	r2,r2,-128
 8004ec8:	10011e26 	beq	r2,zero,8005344 <___vfprintf_internal_r+0x4f8>
 8004ecc:	00c00044 	movi	r3,1
 8004ed0:	b8c01426 	beq	r23,r3,8004f24 <___vfprintf_internal_r+0xd8>
 8004ed4:	1dc00216 	blt	r3,r23,8004ee0 <___vfprintf_internal_r+0x94>
 8004ed8:	b8000626 	beq	r23,zero,8004ef4 <___vfprintf_internal_r+0xa8>
 8004edc:	00011506 	br	8005334 <___vfprintf_internal_r+0x4e8>
 8004ee0:	01400084 	movi	r5,2
 8004ee4:	b9401d26 	beq	r23,r5,8004f5c <___vfprintf_internal_r+0x110>
 8004ee8:	014000c4 	movi	r5,3
 8004eec:	b9402b26 	beq	r23,r5,8004f9c <___vfprintf_internal_r+0x150>
 8004ef0:	00011006 	br	8005334 <___vfprintf_internal_r+0x4e8>
 8004ef4:	01400944 	movi	r5,37
 8004ef8:	1140fc26 	beq	r2,r5,80052ec <___vfprintf_internal_r+0x4a0>
 8004efc:	88800117 	ldw	r2,4(r17)
 8004f00:	d9000005 	stb	r4,0(sp)
 8004f04:	01c00044 	movi	r7,1
 8004f08:	d80d883a 	mov	r6,sp
 8004f0c:	880b883a 	mov	r5,r17
 8004f10:	a009883a 	mov	r4,r20
 8004f14:	103ee83a 	callr	r2
 8004f18:	1000d81e 	bne	r2,zero,800527c <___vfprintf_internal_r+0x430>
 8004f1c:	84000044 	addi	r16,r16,1
 8004f20:	00010406 	br	8005334 <___vfprintf_internal_r+0x4e8>
 8004f24:	01400c04 	movi	r5,48
 8004f28:	1140fa26 	beq	r2,r5,8005314 <___vfprintf_internal_r+0x4c8>
 8004f2c:	01400944 	movi	r5,37
 8004f30:	11400a1e 	bne	r2,r5,8004f5c <___vfprintf_internal_r+0x110>
 8004f34:	d8800005 	stb	r2,0(sp)
 8004f38:	88800117 	ldw	r2,4(r17)
 8004f3c:	b80f883a 	mov	r7,r23
 8004f40:	d80d883a 	mov	r6,sp
 8004f44:	880b883a 	mov	r5,r17
 8004f48:	a009883a 	mov	r4,r20
 8004f4c:	103ee83a 	callr	r2
 8004f50:	1000ca1e 	bne	r2,zero,800527c <___vfprintf_internal_r+0x430>
 8004f54:	84000044 	addi	r16,r16,1
 8004f58:	0000f506 	br	8005330 <___vfprintf_internal_r+0x4e4>
 8004f5c:	25fff404 	addi	r23,r4,-48
 8004f60:	bdc03fcc 	andi	r23,r23,255
 8004f64:	00c00244 	movi	r3,9
 8004f68:	1dc00936 	bltu	r3,r23,8004f90 <___vfprintf_internal_r+0x144>
 8004f6c:	00bfffc4 	movi	r2,-1
 8004f70:	90800426 	beq	r18,r2,8004f84 <___vfprintf_internal_r+0x138>
 8004f74:	01400284 	movi	r5,10
 8004f78:	9009883a 	mov	r4,r18
 8004f7c:	8004b740 	call	8004b74 <__mulsi3>
 8004f80:	00000106 	br	8004f88 <___vfprintf_internal_r+0x13c>
 8004f84:	0005883a 	mov	r2,zero
 8004f88:	b8a5883a 	add	r18,r23,r2
 8004f8c:	0000e206 	br	8005318 <___vfprintf_internal_r+0x4cc>
 8004f90:	01400b84 	movi	r5,46
 8004f94:	1140e426 	beq	r2,r5,8005328 <___vfprintf_internal_r+0x4dc>
 8004f98:	05c00084 	movi	r23,2
 8004f9c:	213ff404 	addi	r4,r4,-48
 8004fa0:	27003fcc 	andi	fp,r4,255
 8004fa4:	00c00244 	movi	r3,9
 8004fa8:	1f000936 	bltu	r3,fp,8004fd0 <___vfprintf_internal_r+0x184>
 8004fac:	00bfffc4 	movi	r2,-1
 8004fb0:	98800426 	beq	r19,r2,8004fc4 <___vfprintf_internal_r+0x178>
 8004fb4:	01400284 	movi	r5,10
 8004fb8:	9809883a 	mov	r4,r19
 8004fbc:	8004b740 	call	8004b74 <__mulsi3>
 8004fc0:	00000106 	br	8004fc8 <___vfprintf_internal_r+0x17c>
 8004fc4:	0005883a 	mov	r2,zero
 8004fc8:	e0a7883a 	add	r19,fp,r2
 8004fcc:	0000d906 	br	8005334 <___vfprintf_internal_r+0x4e8>
 8004fd0:	00c01b04 	movi	r3,108
 8004fd4:	10c0d226 	beq	r2,r3,8005320 <___vfprintf_internal_r+0x4d4>
 8004fd8:	013fffc4 	movi	r4,-1
 8004fdc:	99000226 	beq	r19,r4,8004fe8 <___vfprintf_internal_r+0x19c>
 8004fe0:	d8000b15 	stw	zero,44(sp)
 8004fe4:	00000106 	br	8004fec <___vfprintf_internal_r+0x1a0>
 8004fe8:	04c00044 	movi	r19,1
 8004fec:	01001a44 	movi	r4,105
 8004ff0:	11001626 	beq	r2,r4,800504c <___vfprintf_internal_r+0x200>
 8004ff4:	20800916 	blt	r4,r2,800501c <___vfprintf_internal_r+0x1d0>
 8004ff8:	010018c4 	movi	r4,99
 8004ffc:	11008826 	beq	r2,r4,8005220 <___vfprintf_internal_r+0x3d4>
 8005000:	01001904 	movi	r4,100
 8005004:	11001126 	beq	r2,r4,800504c <___vfprintf_internal_r+0x200>
 8005008:	01001604 	movi	r4,88
 800500c:	1100c81e 	bne	r2,r4,8005330 <___vfprintf_internal_r+0x4e4>
 8005010:	00c00044 	movi	r3,1
 8005014:	d8c00e15 	stw	r3,56(sp)
 8005018:	00001506 	br	8005070 <___vfprintf_internal_r+0x224>
 800501c:	01001cc4 	movi	r4,115
 8005020:	11009826 	beq	r2,r4,8005284 <___vfprintf_internal_r+0x438>
 8005024:	20800416 	blt	r4,r2,8005038 <___vfprintf_internal_r+0x1ec>
 8005028:	01001bc4 	movi	r4,111
 800502c:	1100c01e 	bne	r2,r4,8005330 <___vfprintf_internal_r+0x4e4>
 8005030:	05400204 	movi	r21,8
 8005034:	00000f06 	br	8005074 <___vfprintf_internal_r+0x228>
 8005038:	01001d44 	movi	r4,117
 800503c:	11000d26 	beq	r2,r4,8005074 <___vfprintf_internal_r+0x228>
 8005040:	01001e04 	movi	r4,120
 8005044:	11000a26 	beq	r2,r4,8005070 <___vfprintf_internal_r+0x224>
 8005048:	0000b906 	br	8005330 <___vfprintf_internal_r+0x4e4>
 800504c:	d8c00a17 	ldw	r3,40(sp)
 8005050:	b7000104 	addi	fp,r22,4
 8005054:	18000726 	beq	r3,zero,8005074 <___vfprintf_internal_r+0x228>
 8005058:	df000d15 	stw	fp,52(sp)
 800505c:	b5c00017 	ldw	r23,0(r22)
 8005060:	b800080e 	bge	r23,zero,8005084 <___vfprintf_internal_r+0x238>
 8005064:	05efc83a 	sub	r23,zero,r23
 8005068:	02400044 	movi	r9,1
 800506c:	00000606 	br	8005088 <___vfprintf_internal_r+0x23c>
 8005070:	05400404 	movi	r21,16
 8005074:	b0c00104 	addi	r3,r22,4
 8005078:	d8c00d15 	stw	r3,52(sp)
 800507c:	b5c00017 	ldw	r23,0(r22)
 8005080:	d8000a15 	stw	zero,40(sp)
 8005084:	0013883a 	mov	r9,zero
 8005088:	d839883a 	mov	fp,sp
 800508c:	b8001726 	beq	r23,zero,80050ec <___vfprintf_internal_r+0x2a0>
 8005090:	a80b883a 	mov	r5,r21
 8005094:	b809883a 	mov	r4,r23
 8005098:	da401015 	stw	r9,64(sp)
 800509c:	80056b80 	call	80056b8 <__udivsi3>
 80050a0:	a80b883a 	mov	r5,r21
 80050a4:	1009883a 	mov	r4,r2
 80050a8:	102d883a 	mov	r22,r2
 80050ac:	8004b740 	call	8004b74 <__mulsi3>
 80050b0:	b885c83a 	sub	r2,r23,r2
 80050b4:	00c00244 	movi	r3,9
 80050b8:	da401017 	ldw	r9,64(sp)
 80050bc:	18800216 	blt	r3,r2,80050c8 <___vfprintf_internal_r+0x27c>
 80050c0:	10800c04 	addi	r2,r2,48
 80050c4:	00000506 	br	80050dc <___vfprintf_internal_r+0x290>
 80050c8:	d8c00e17 	ldw	r3,56(sp)
 80050cc:	18000226 	beq	r3,zero,80050d8 <___vfprintf_internal_r+0x28c>
 80050d0:	10800dc4 	addi	r2,r2,55
 80050d4:	00000106 	br	80050dc <___vfprintf_internal_r+0x290>
 80050d8:	108015c4 	addi	r2,r2,87
 80050dc:	e0800005 	stb	r2,0(fp)
 80050e0:	b02f883a 	mov	r23,r22
 80050e4:	e7000044 	addi	fp,fp,1
 80050e8:	003fe806 	br	800508c <__alt_data_end+0xfc00508c>
 80050ec:	e6efc83a 	sub	r23,fp,sp
 80050f0:	9dc5c83a 	sub	r2,r19,r23
 80050f4:	0080090e 	bge	zero,r2,800511c <___vfprintf_internal_r+0x2d0>
 80050f8:	e085883a 	add	r2,fp,r2
 80050fc:	01400c04 	movi	r5,48
 8005100:	d8c00917 	ldw	r3,36(sp)
 8005104:	e009883a 	mov	r4,fp
 8005108:	e0c0032e 	bgeu	fp,r3,8005118 <___vfprintf_internal_r+0x2cc>
 800510c:	e7000044 	addi	fp,fp,1
 8005110:	21400005 	stb	r5,0(r4)
 8005114:	e0bffa1e 	bne	fp,r2,8005100 <__alt_data_end+0xfc005100>
 8005118:	e6efc83a 	sub	r23,fp,sp
 800511c:	d8c00b17 	ldw	r3,44(sp)
 8005120:	4dd1883a 	add	r8,r9,r23
 8005124:	922dc83a 	sub	r22,r18,r8
 8005128:	18001626 	beq	r3,zero,8005184 <___vfprintf_internal_r+0x338>
 800512c:	48000a26 	beq	r9,zero,8005158 <___vfprintf_internal_r+0x30c>
 8005130:	00800b44 	movi	r2,45
 8005134:	d8800805 	stb	r2,32(sp)
 8005138:	88800117 	ldw	r2,4(r17)
 800513c:	01c00044 	movi	r7,1
 8005140:	d9800804 	addi	r6,sp,32
 8005144:	880b883a 	mov	r5,r17
 8005148:	a009883a 	mov	r4,r20
 800514c:	103ee83a 	callr	r2
 8005150:	10004a1e 	bne	r2,zero,800527c <___vfprintf_internal_r+0x430>
 8005154:	84000044 	addi	r16,r16,1
 8005158:	0580070e 	bge	zero,r22,8005178 <___vfprintf_internal_r+0x32c>
 800515c:	b00f883a 	mov	r7,r22
 8005160:	01800c04 	movi	r6,48
 8005164:	880b883a 	mov	r5,r17
 8005168:	a009883a 	mov	r4,r20
 800516c:	8004de00 	call	8004de0 <print_repeat>
 8005170:	1000421e 	bne	r2,zero,800527c <___vfprintf_internal_r+0x430>
 8005174:	85a1883a 	add	r16,r16,r22
 8005178:	e02d883a 	mov	r22,fp
 800517c:	bf2fc83a 	sub	r23,r23,fp
 8005180:	00002006 	br	8005204 <___vfprintf_internal_r+0x3b8>
 8005184:	0580090e 	bge	zero,r22,80051ac <___vfprintf_internal_r+0x360>
 8005188:	b00f883a 	mov	r7,r22
 800518c:	01800804 	movi	r6,32
 8005190:	880b883a 	mov	r5,r17
 8005194:	a009883a 	mov	r4,r20
 8005198:	da401015 	stw	r9,64(sp)
 800519c:	8004de00 	call	8004de0 <print_repeat>
 80051a0:	da401017 	ldw	r9,64(sp)
 80051a4:	1000351e 	bne	r2,zero,800527c <___vfprintf_internal_r+0x430>
 80051a8:	85a1883a 	add	r16,r16,r22
 80051ac:	483ff226 	beq	r9,zero,8005178 <__alt_data_end+0xfc005178>
 80051b0:	00800b44 	movi	r2,45
 80051b4:	d8800805 	stb	r2,32(sp)
 80051b8:	88800117 	ldw	r2,4(r17)
 80051bc:	01c00044 	movi	r7,1
 80051c0:	d9800804 	addi	r6,sp,32
 80051c4:	880b883a 	mov	r5,r17
 80051c8:	a009883a 	mov	r4,r20
 80051cc:	103ee83a 	callr	r2
 80051d0:	10002a1e 	bne	r2,zero,800527c <___vfprintf_internal_r+0x430>
 80051d4:	84000044 	addi	r16,r16,1
 80051d8:	003fe706 	br	8005178 <__alt_data_end+0xfc005178>
 80051dc:	b5bfffc4 	addi	r22,r22,-1
 80051e0:	b0800003 	ldbu	r2,0(r22)
 80051e4:	01c00044 	movi	r7,1
 80051e8:	d9800804 	addi	r6,sp,32
 80051ec:	d8800805 	stb	r2,32(sp)
 80051f0:	88800117 	ldw	r2,4(r17)
 80051f4:	880b883a 	mov	r5,r17
 80051f8:	a009883a 	mov	r4,r20
 80051fc:	103ee83a 	callr	r2
 8005200:	10001e1e 	bne	r2,zero,800527c <___vfprintf_internal_r+0x430>
 8005204:	8585c83a 	sub	r2,r16,r22
 8005208:	b5c9883a 	add	r4,r22,r23
 800520c:	e085883a 	add	r2,fp,r2
 8005210:	013ff216 	blt	zero,r4,80051dc <__alt_data_end+0xfc0051dc>
 8005214:	1021883a 	mov	r16,r2
 8005218:	dd800d17 	ldw	r22,52(sp)
 800521c:	00004406 	br	8005330 <___vfprintf_internal_r+0x4e4>
 8005220:	00800044 	movi	r2,1
 8005224:	1480080e 	bge	r2,r18,8005248 <___vfprintf_internal_r+0x3fc>
 8005228:	95ffffc4 	addi	r23,r18,-1
 800522c:	b80f883a 	mov	r7,r23
 8005230:	01800804 	movi	r6,32
 8005234:	880b883a 	mov	r5,r17
 8005238:	a009883a 	mov	r4,r20
 800523c:	8004de00 	call	8004de0 <print_repeat>
 8005240:	10000e1e 	bne	r2,zero,800527c <___vfprintf_internal_r+0x430>
 8005244:	85e1883a 	add	r16,r16,r23
 8005248:	b0800017 	ldw	r2,0(r22)
 800524c:	01c00044 	movi	r7,1
 8005250:	d80d883a 	mov	r6,sp
 8005254:	d8800005 	stb	r2,0(sp)
 8005258:	88800117 	ldw	r2,4(r17)
 800525c:	880b883a 	mov	r5,r17
 8005260:	a009883a 	mov	r4,r20
 8005264:	b5c00104 	addi	r23,r22,4
 8005268:	103ee83a 	callr	r2
 800526c:	1000031e 	bne	r2,zero,800527c <___vfprintf_internal_r+0x430>
 8005270:	84000044 	addi	r16,r16,1
 8005274:	b82d883a 	mov	r22,r23
 8005278:	00002d06 	br	8005330 <___vfprintf_internal_r+0x4e4>
 800527c:	00bfffc4 	movi	r2,-1
 8005280:	00003106 	br	8005348 <___vfprintf_internal_r+0x4fc>
 8005284:	b5c00017 	ldw	r23,0(r22)
 8005288:	b7000104 	addi	fp,r22,4
 800528c:	b809883a 	mov	r4,r23
 8005290:	800554c0 	call	800554c <strlen>
 8005294:	9091c83a 	sub	r8,r18,r2
 8005298:	102d883a 	mov	r22,r2
 800529c:	0200090e 	bge	zero,r8,80052c4 <___vfprintf_internal_r+0x478>
 80052a0:	400f883a 	mov	r7,r8
 80052a4:	01800804 	movi	r6,32
 80052a8:	880b883a 	mov	r5,r17
 80052ac:	a009883a 	mov	r4,r20
 80052b0:	da001015 	stw	r8,64(sp)
 80052b4:	8004de00 	call	8004de0 <print_repeat>
 80052b8:	da001017 	ldw	r8,64(sp)
 80052bc:	103fef1e 	bne	r2,zero,800527c <__alt_data_end+0xfc00527c>
 80052c0:	8221883a 	add	r16,r16,r8
 80052c4:	88800117 	ldw	r2,4(r17)
 80052c8:	b00f883a 	mov	r7,r22
 80052cc:	b80d883a 	mov	r6,r23
 80052d0:	880b883a 	mov	r5,r17
 80052d4:	a009883a 	mov	r4,r20
 80052d8:	103ee83a 	callr	r2
 80052dc:	103fe71e 	bne	r2,zero,800527c <__alt_data_end+0xfc00527c>
 80052e0:	85a1883a 	add	r16,r16,r22
 80052e4:	e02d883a 	mov	r22,fp
 80052e8:	00001106 	br	8005330 <___vfprintf_internal_r+0x4e4>
 80052ec:	00c00044 	movi	r3,1
 80052f0:	04ffffc4 	movi	r19,-1
 80052f4:	d8000e15 	stw	zero,56(sp)
 80052f8:	d8c00a15 	stw	r3,40(sp)
 80052fc:	05400284 	movi	r21,10
 8005300:	9825883a 	mov	r18,r19
 8005304:	d8000c15 	stw	zero,48(sp)
 8005308:	d8000b15 	stw	zero,44(sp)
 800530c:	182f883a 	mov	r23,r3
 8005310:	00000806 	br	8005334 <___vfprintf_internal_r+0x4e8>
 8005314:	ddc00b15 	stw	r23,44(sp)
 8005318:	05c00084 	movi	r23,2
 800531c:	00000506 	br	8005334 <___vfprintf_internal_r+0x4e8>
 8005320:	00c00044 	movi	r3,1
 8005324:	d8c00c15 	stw	r3,48(sp)
 8005328:	05c000c4 	movi	r23,3
 800532c:	00000106 	br	8005334 <___vfprintf_internal_r+0x4e8>
 8005330:	002f883a 	mov	r23,zero
 8005334:	d8c00f17 	ldw	r3,60(sp)
 8005338:	18c00044 	addi	r3,r3,1
 800533c:	d8c00f15 	stw	r3,60(sp)
 8005340:	003edc06 	br	8004eb4 <__alt_data_end+0xfc004eb4>
 8005344:	8005883a 	mov	r2,r16
 8005348:	dfc01a17 	ldw	ra,104(sp)
 800534c:	df001917 	ldw	fp,100(sp)
 8005350:	ddc01817 	ldw	r23,96(sp)
 8005354:	dd801717 	ldw	r22,92(sp)
 8005358:	dd401617 	ldw	r21,88(sp)
 800535c:	dd001517 	ldw	r20,84(sp)
 8005360:	dcc01417 	ldw	r19,80(sp)
 8005364:	dc801317 	ldw	r18,76(sp)
 8005368:	dc401217 	ldw	r17,72(sp)
 800536c:	dc001117 	ldw	r16,68(sp)
 8005370:	dec01b04 	addi	sp,sp,108
 8005374:	f800283a 	ret

08005378 <__vfprintf_internal>:
 8005378:	00820034 	movhi	r2,2048
 800537c:	109a4f04 	addi	r2,r2,26940
 8005380:	300f883a 	mov	r7,r6
 8005384:	280d883a 	mov	r6,r5
 8005388:	200b883a 	mov	r5,r4
 800538c:	11000017 	ldw	r4,0(r2)
 8005390:	8004e4c1 	jmpi	8004e4c <___vfprintf_internal_r>

08005394 <__sfvwrite_small_dev>:
 8005394:	2880000b 	ldhu	r2,0(r5)
 8005398:	1080020c 	andi	r2,r2,8
 800539c:	10002126 	beq	r2,zero,8005424 <__sfvwrite_small_dev+0x90>
 80053a0:	2880008f 	ldh	r2,2(r5)
 80053a4:	defffa04 	addi	sp,sp,-24
 80053a8:	dc000015 	stw	r16,0(sp)
 80053ac:	dfc00515 	stw	ra,20(sp)
 80053b0:	dd000415 	stw	r20,16(sp)
 80053b4:	dcc00315 	stw	r19,12(sp)
 80053b8:	dc800215 	stw	r18,8(sp)
 80053bc:	dc400115 	stw	r17,4(sp)
 80053c0:	2821883a 	mov	r16,r5
 80053c4:	10001216 	blt	r2,zero,8005410 <__sfvwrite_small_dev+0x7c>
 80053c8:	2027883a 	mov	r19,r4
 80053cc:	3025883a 	mov	r18,r6
 80053d0:	3823883a 	mov	r17,r7
 80053d4:	05010004 	movi	r20,1024
 80053d8:	04400b0e 	bge	zero,r17,8005408 <__sfvwrite_small_dev+0x74>
 80053dc:	880f883a 	mov	r7,r17
 80053e0:	a440010e 	bge	r20,r17,80053e8 <__sfvwrite_small_dev+0x54>
 80053e4:	01c10004 	movi	r7,1024
 80053e8:	8140008f 	ldh	r5,2(r16)
 80053ec:	900d883a 	mov	r6,r18
 80053f0:	9809883a 	mov	r4,r19
 80053f4:	80055680 	call	8005568 <_write_r>
 80053f8:	0080050e 	bge	zero,r2,8005410 <__sfvwrite_small_dev+0x7c>
 80053fc:	88a3c83a 	sub	r17,r17,r2
 8005400:	90a5883a 	add	r18,r18,r2
 8005404:	003ff406 	br	80053d8 <__alt_data_end+0xfc0053d8>
 8005408:	0005883a 	mov	r2,zero
 800540c:	00000706 	br	800542c <__sfvwrite_small_dev+0x98>
 8005410:	8080000b 	ldhu	r2,0(r16)
 8005414:	10801014 	ori	r2,r2,64
 8005418:	8080000d 	sth	r2,0(r16)
 800541c:	00bfffc4 	movi	r2,-1
 8005420:	00000206 	br	800542c <__sfvwrite_small_dev+0x98>
 8005424:	00bfffc4 	movi	r2,-1
 8005428:	f800283a 	ret
 800542c:	dfc00517 	ldw	ra,20(sp)
 8005430:	dd000417 	ldw	r20,16(sp)
 8005434:	dcc00317 	ldw	r19,12(sp)
 8005438:	dc800217 	ldw	r18,8(sp)
 800543c:	dc400117 	ldw	r17,4(sp)
 8005440:	dc000017 	ldw	r16,0(sp)
 8005444:	dec00604 	addi	sp,sp,24
 8005448:	f800283a 	ret

0800544c <_gettimeofday_r>:
 800544c:	defffd04 	addi	sp,sp,-12
 8005450:	dc000015 	stw	r16,0(sp)
 8005454:	04020034 	movhi	r16,2048
 8005458:	dc400115 	stw	r17,4(sp)
 800545c:	841abb04 	addi	r16,r16,27372
 8005460:	2023883a 	mov	r17,r4
 8005464:	2809883a 	mov	r4,r5
 8005468:	300b883a 	mov	r5,r6
 800546c:	dfc00215 	stw	ra,8(sp)
 8005470:	80000015 	stw	zero,0(r16)
 8005474:	80058500 	call	8005850 <gettimeofday>
 8005478:	00ffffc4 	movi	r3,-1
 800547c:	10c0031e 	bne	r2,r3,800548c <_gettimeofday_r+0x40>
 8005480:	80c00017 	ldw	r3,0(r16)
 8005484:	18000126 	beq	r3,zero,800548c <_gettimeofday_r+0x40>
 8005488:	88c00015 	stw	r3,0(r17)
 800548c:	dfc00217 	ldw	ra,8(sp)
 8005490:	dc400117 	ldw	r17,4(sp)
 8005494:	dc000017 	ldw	r16,0(sp)
 8005498:	dec00304 	addi	sp,sp,12
 800549c:	f800283a 	ret

080054a0 <putc>:
 80054a0:	defffd04 	addi	sp,sp,-12
 80054a4:	00820034 	movhi	r2,2048
 80054a8:	dc000115 	stw	r16,4(sp)
 80054ac:	dfc00215 	stw	ra,8(sp)
 80054b0:	1094e504 	addi	r2,r2,21396
 80054b4:	28800115 	stw	r2,4(r5)
 80054b8:	00820034 	movhi	r2,2048
 80054bc:	109a4f04 	addi	r2,r2,26940
 80054c0:	d9000005 	stb	r4,0(sp)
 80054c4:	2021883a 	mov	r16,r4
 80054c8:	11000017 	ldw	r4,0(r2)
 80054cc:	01c00044 	movi	r7,1
 80054d0:	d80d883a 	mov	r6,sp
 80054d4:	80053940 	call	8005394 <__sfvwrite_small_dev>
 80054d8:	00ffffc4 	movi	r3,-1
 80054dc:	10c00126 	beq	r2,r3,80054e4 <putc+0x44>
 80054e0:	8005883a 	mov	r2,r16
 80054e4:	dfc00217 	ldw	ra,8(sp)
 80054e8:	dc000117 	ldw	r16,4(sp)
 80054ec:	dec00304 	addi	sp,sp,12
 80054f0:	f800283a 	ret

080054f4 <_putc_r>:
 80054f4:	defffd04 	addi	sp,sp,-12
 80054f8:	00820034 	movhi	r2,2048
 80054fc:	dc000115 	stw	r16,4(sp)
 8005500:	dfc00215 	stw	ra,8(sp)
 8005504:	1094e504 	addi	r2,r2,21396
 8005508:	30800115 	stw	r2,4(r6)
 800550c:	00820034 	movhi	r2,2048
 8005510:	109a4f04 	addi	r2,r2,26940
 8005514:	11000017 	ldw	r4,0(r2)
 8005518:	2821883a 	mov	r16,r5
 800551c:	01c00044 	movi	r7,1
 8005520:	300b883a 	mov	r5,r6
 8005524:	d80d883a 	mov	r6,sp
 8005528:	dc000005 	stb	r16,0(sp)
 800552c:	80053940 	call	8005394 <__sfvwrite_small_dev>
 8005530:	00ffffc4 	movi	r3,-1
 8005534:	10c00126 	beq	r2,r3,800553c <_putc_r+0x48>
 8005538:	8005883a 	mov	r2,r16
 800553c:	dfc00217 	ldw	ra,8(sp)
 8005540:	dc000117 	ldw	r16,4(sp)
 8005544:	dec00304 	addi	sp,sp,12
 8005548:	f800283a 	ret

0800554c <strlen>:
 800554c:	2005883a 	mov	r2,r4
 8005550:	10c00007 	ldb	r3,0(r2)
 8005554:	18000226 	beq	r3,zero,8005560 <strlen+0x14>
 8005558:	10800044 	addi	r2,r2,1
 800555c:	003ffc06 	br	8005550 <__alt_data_end+0xfc005550>
 8005560:	1105c83a 	sub	r2,r2,r4
 8005564:	f800283a 	ret

08005568 <_write_r>:
 8005568:	defffd04 	addi	sp,sp,-12
 800556c:	dc000015 	stw	r16,0(sp)
 8005570:	04020034 	movhi	r16,2048
 8005574:	dc400115 	stw	r17,4(sp)
 8005578:	841abb04 	addi	r16,r16,27372
 800557c:	2023883a 	mov	r17,r4
 8005580:	2809883a 	mov	r4,r5
 8005584:	300b883a 	mov	r5,r6
 8005588:	380d883a 	mov	r6,r7
 800558c:	dfc00215 	stw	ra,8(sp)
 8005590:	80000015 	stw	zero,0(r16)
 8005594:	8005ce40 	call	8005ce4 <write>
 8005598:	00ffffc4 	movi	r3,-1
 800559c:	10c0031e 	bne	r2,r3,80055ac <_write_r+0x44>
 80055a0:	80c00017 	ldw	r3,0(r16)
 80055a4:	18000126 	beq	r3,zero,80055ac <_write_r+0x44>
 80055a8:	88c00015 	stw	r3,0(r17)
 80055ac:	dfc00217 	ldw	ra,8(sp)
 80055b0:	dc400117 	ldw	r17,4(sp)
 80055b4:	dc000017 	ldw	r16,0(sp)
 80055b8:	dec00304 	addi	sp,sp,12
 80055bc:	f800283a 	ret

080055c0 <__divsi3>:
 80055c0:	20001b16 	blt	r4,zero,8005630 <__divsi3+0x70>
 80055c4:	000f883a 	mov	r7,zero
 80055c8:	28001616 	blt	r5,zero,8005624 <__divsi3+0x64>
 80055cc:	200d883a 	mov	r6,r4
 80055d0:	29001a2e 	bgeu	r5,r4,800563c <__divsi3+0x7c>
 80055d4:	00800804 	movi	r2,32
 80055d8:	00c00044 	movi	r3,1
 80055dc:	00000106 	br	80055e4 <__divsi3+0x24>
 80055e0:	10000d26 	beq	r2,zero,8005618 <__divsi3+0x58>
 80055e4:	294b883a 	add	r5,r5,r5
 80055e8:	10bfffc4 	addi	r2,r2,-1
 80055ec:	18c7883a 	add	r3,r3,r3
 80055f0:	293ffb36 	bltu	r5,r4,80055e0 <__alt_data_end+0xfc0055e0>
 80055f4:	0005883a 	mov	r2,zero
 80055f8:	18000726 	beq	r3,zero,8005618 <__divsi3+0x58>
 80055fc:	0005883a 	mov	r2,zero
 8005600:	31400236 	bltu	r6,r5,800560c <__divsi3+0x4c>
 8005604:	314dc83a 	sub	r6,r6,r5
 8005608:	10c4b03a 	or	r2,r2,r3
 800560c:	1806d07a 	srli	r3,r3,1
 8005610:	280ad07a 	srli	r5,r5,1
 8005614:	183ffa1e 	bne	r3,zero,8005600 <__alt_data_end+0xfc005600>
 8005618:	38000126 	beq	r7,zero,8005620 <__divsi3+0x60>
 800561c:	0085c83a 	sub	r2,zero,r2
 8005620:	f800283a 	ret
 8005624:	014bc83a 	sub	r5,zero,r5
 8005628:	39c0005c 	xori	r7,r7,1
 800562c:	003fe706 	br	80055cc <__alt_data_end+0xfc0055cc>
 8005630:	0109c83a 	sub	r4,zero,r4
 8005634:	01c00044 	movi	r7,1
 8005638:	003fe306 	br	80055c8 <__alt_data_end+0xfc0055c8>
 800563c:	00c00044 	movi	r3,1
 8005640:	003fee06 	br	80055fc <__alt_data_end+0xfc0055fc>

08005644 <__modsi3>:
 8005644:	20001716 	blt	r4,zero,80056a4 <__modsi3+0x60>
 8005648:	000f883a 	mov	r7,zero
 800564c:	2005883a 	mov	r2,r4
 8005650:	28001216 	blt	r5,zero,800569c <__modsi3+0x58>
 8005654:	2900162e 	bgeu	r5,r4,80056b0 <__modsi3+0x6c>
 8005658:	01800804 	movi	r6,32
 800565c:	00c00044 	movi	r3,1
 8005660:	00000106 	br	8005668 <__modsi3+0x24>
 8005664:	30000a26 	beq	r6,zero,8005690 <__modsi3+0x4c>
 8005668:	294b883a 	add	r5,r5,r5
 800566c:	31bfffc4 	addi	r6,r6,-1
 8005670:	18c7883a 	add	r3,r3,r3
 8005674:	293ffb36 	bltu	r5,r4,8005664 <__alt_data_end+0xfc005664>
 8005678:	18000526 	beq	r3,zero,8005690 <__modsi3+0x4c>
 800567c:	1806d07a 	srli	r3,r3,1
 8005680:	11400136 	bltu	r2,r5,8005688 <__modsi3+0x44>
 8005684:	1145c83a 	sub	r2,r2,r5
 8005688:	280ad07a 	srli	r5,r5,1
 800568c:	183ffb1e 	bne	r3,zero,800567c <__alt_data_end+0xfc00567c>
 8005690:	38000126 	beq	r7,zero,8005698 <__modsi3+0x54>
 8005694:	0085c83a 	sub	r2,zero,r2
 8005698:	f800283a 	ret
 800569c:	014bc83a 	sub	r5,zero,r5
 80056a0:	003fec06 	br	8005654 <__alt_data_end+0xfc005654>
 80056a4:	0109c83a 	sub	r4,zero,r4
 80056a8:	01c00044 	movi	r7,1
 80056ac:	003fe706 	br	800564c <__alt_data_end+0xfc00564c>
 80056b0:	00c00044 	movi	r3,1
 80056b4:	003ff106 	br	800567c <__alt_data_end+0xfc00567c>

080056b8 <__udivsi3>:
 80056b8:	200d883a 	mov	r6,r4
 80056bc:	2900152e 	bgeu	r5,r4,8005714 <__udivsi3+0x5c>
 80056c0:	28001416 	blt	r5,zero,8005714 <__udivsi3+0x5c>
 80056c4:	00800804 	movi	r2,32
 80056c8:	00c00044 	movi	r3,1
 80056cc:	00000206 	br	80056d8 <__udivsi3+0x20>
 80056d0:	10000e26 	beq	r2,zero,800570c <__udivsi3+0x54>
 80056d4:	28000516 	blt	r5,zero,80056ec <__udivsi3+0x34>
 80056d8:	294b883a 	add	r5,r5,r5
 80056dc:	10bfffc4 	addi	r2,r2,-1
 80056e0:	18c7883a 	add	r3,r3,r3
 80056e4:	293ffa36 	bltu	r5,r4,80056d0 <__alt_data_end+0xfc0056d0>
 80056e8:	18000826 	beq	r3,zero,800570c <__udivsi3+0x54>
 80056ec:	0005883a 	mov	r2,zero
 80056f0:	31400236 	bltu	r6,r5,80056fc <__udivsi3+0x44>
 80056f4:	314dc83a 	sub	r6,r6,r5
 80056f8:	10c4b03a 	or	r2,r2,r3
 80056fc:	1806d07a 	srli	r3,r3,1
 8005700:	280ad07a 	srli	r5,r5,1
 8005704:	183ffa1e 	bne	r3,zero,80056f0 <__alt_data_end+0xfc0056f0>
 8005708:	f800283a 	ret
 800570c:	0005883a 	mov	r2,zero
 8005710:	f800283a 	ret
 8005714:	00c00044 	movi	r3,1
 8005718:	003ff406 	br	80056ec <__alt_data_end+0xfc0056ec>

0800571c <__umodsi3>:
 800571c:	2005883a 	mov	r2,r4
 8005720:	2900122e 	bgeu	r5,r4,800576c <__umodsi3+0x50>
 8005724:	28001116 	blt	r5,zero,800576c <__umodsi3+0x50>
 8005728:	01800804 	movi	r6,32
 800572c:	00c00044 	movi	r3,1
 8005730:	00000206 	br	800573c <__umodsi3+0x20>
 8005734:	30000c26 	beq	r6,zero,8005768 <__umodsi3+0x4c>
 8005738:	28000516 	blt	r5,zero,8005750 <__umodsi3+0x34>
 800573c:	294b883a 	add	r5,r5,r5
 8005740:	31bfffc4 	addi	r6,r6,-1
 8005744:	18c7883a 	add	r3,r3,r3
 8005748:	293ffa36 	bltu	r5,r4,8005734 <__alt_data_end+0xfc005734>
 800574c:	18000626 	beq	r3,zero,8005768 <__umodsi3+0x4c>
 8005750:	1806d07a 	srli	r3,r3,1
 8005754:	11400136 	bltu	r2,r5,800575c <__umodsi3+0x40>
 8005758:	1145c83a 	sub	r2,r2,r5
 800575c:	280ad07a 	srli	r5,r5,1
 8005760:	183ffb1e 	bne	r3,zero,8005750 <__alt_data_end+0xfc005750>
 8005764:	f800283a 	ret
 8005768:	f800283a 	ret
 800576c:	00c00044 	movi	r3,1
 8005770:	003ff706 	br	8005750 <__alt_data_end+0xfc005750>

08005774 <__floatsidf>:
 8005774:	defffd04 	addi	sp,sp,-12
 8005778:	dfc00215 	stw	ra,8(sp)
 800577c:	dc400115 	stw	r17,4(sp)
 8005780:	dc000015 	stw	r16,0(sp)
 8005784:	20002b26 	beq	r4,zero,8005834 <__floatsidf+0xc0>
 8005788:	2023883a 	mov	r17,r4
 800578c:	2020d7fa 	srli	r16,r4,31
 8005790:	20002d16 	blt	r4,zero,8005848 <__floatsidf+0xd4>
 8005794:	8809883a 	mov	r4,r17
 8005798:	8004b100 	call	8004b10 <__clzsi2>
 800579c:	01410784 	movi	r5,1054
 80057a0:	288bc83a 	sub	r5,r5,r2
 80057a4:	01010cc4 	movi	r4,1075
 80057a8:	2149c83a 	sub	r4,r4,r5
 80057ac:	00c007c4 	movi	r3,31
 80057b0:	1900160e 	bge	r3,r4,800580c <__floatsidf+0x98>
 80057b4:	00c104c4 	movi	r3,1043
 80057b8:	1947c83a 	sub	r3,r3,r5
 80057bc:	88c6983a 	sll	r3,r17,r3
 80057c0:	00800434 	movhi	r2,16
 80057c4:	10bfffc4 	addi	r2,r2,-1
 80057c8:	1886703a 	and	r3,r3,r2
 80057cc:	2941ffcc 	andi	r5,r5,2047
 80057d0:	800d883a 	mov	r6,r16
 80057d4:	0005883a 	mov	r2,zero
 80057d8:	280a953a 	slli	r5,r5,20
 80057dc:	31803fcc 	andi	r6,r6,255
 80057e0:	01000434 	movhi	r4,16
 80057e4:	300c97fa 	slli	r6,r6,31
 80057e8:	213fffc4 	addi	r4,r4,-1
 80057ec:	1906703a 	and	r3,r3,r4
 80057f0:	1946b03a 	or	r3,r3,r5
 80057f4:	1986b03a 	or	r3,r3,r6
 80057f8:	dfc00217 	ldw	ra,8(sp)
 80057fc:	dc400117 	ldw	r17,4(sp)
 8005800:	dc000017 	ldw	r16,0(sp)
 8005804:	dec00304 	addi	sp,sp,12
 8005808:	f800283a 	ret
 800580c:	00c002c4 	movi	r3,11
 8005810:	1887c83a 	sub	r3,r3,r2
 8005814:	88c6d83a 	srl	r3,r17,r3
 8005818:	8904983a 	sll	r2,r17,r4
 800581c:	01000434 	movhi	r4,16
 8005820:	213fffc4 	addi	r4,r4,-1
 8005824:	2941ffcc 	andi	r5,r5,2047
 8005828:	1906703a 	and	r3,r3,r4
 800582c:	800d883a 	mov	r6,r16
 8005830:	003fe906 	br	80057d8 <__alt_data_end+0xfc0057d8>
 8005834:	000d883a 	mov	r6,zero
 8005838:	000b883a 	mov	r5,zero
 800583c:	0007883a 	mov	r3,zero
 8005840:	0005883a 	mov	r2,zero
 8005844:	003fe406 	br	80057d8 <__alt_data_end+0xfc0057d8>
 8005848:	0123c83a 	sub	r17,zero,r4
 800584c:	003fd106 	br	8005794 <__alt_data_end+0xfc005794>

08005850 <gettimeofday>:
 */
 

#if defined (__GNUC__) && (__GNUC__ >= 4)
int ALT_GETTIMEOFDAY (struct timeval  *ptimeval, void *ptimezone_vptr)
{
 8005850:	defffb04 	addi	sp,sp,-20
 8005854:	dc800215 	stw	r18,8(sp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 8005858:	d4a07f17 	ldw	r18,-32260(gp)
 800585c:	dcc00315 	stw	r19,12(sp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 8005860:	d4e07e17 	ldw	r19,-32264(gp)
 8005864:	dfc00415 	stw	ra,16(sp)
 8005868:	dc400115 	stw	r17,4(sp)
 800586c:	dc000015 	stw	r16,0(sp)
   * non-zero system clock rate. If the system clock is not running, an error
   * is generated and the contents of "ptimeval" and "ptimezone" are not
   * updated.
   */

  if (tick_rate)
 8005870:	90003a26 	beq	r18,zero,800595c <gettimeofday+0x10c>
 8005874:	2021883a 	mov	r16,r4
 8005878:	2823883a 	mov	r17,r5
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
 800587c:	9809883a 	mov	r4,r19
 8005880:	900b883a 	mov	r5,r18
 8005884:	80056b80 	call	80056b8 <__udivsi3>
 8005888:	d0e07617 	ldw	r3,-32296(gp)
    ptimeval->tv_usec = alt_resettime.tv_usec +
 800588c:	010003f4 	movhi	r4,15
 8005890:	900b883a 	mov	r5,r18
   * updated.
   */

  if (tick_rate)
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
 8005894:	1885883a 	add	r2,r3,r2
    ptimeval->tv_usec = alt_resettime.tv_usec +
 8005898:	21109004 	addi	r4,r4,16960
   * updated.
   */

  if (tick_rate)
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
 800589c:	80800015 	stw	r2,0(r16)
    ptimeval->tv_usec = alt_resettime.tv_usec +
 80058a0:	80056b80 	call	80056b8 <__udivsi3>
 80058a4:	980d883a 	mov	r6,r19
 80058a8:	000f883a 	mov	r7,zero
 80058ac:	1009883a 	mov	r4,r2
 80058b0:	000b883a 	mov	r5,zero
 80058b4:	8005fa40 	call	8005fa4 <__muldi3>
 80058b8:	018003f4 	movhi	r6,15
 80058bc:	1009883a 	mov	r4,r2
 80058c0:	31909004 	addi	r6,r6,16960
 80058c4:	000f883a 	mov	r7,zero
 80058c8:	180b883a 	mov	r5,r3
 80058cc:	80060b00 	call	80060b0 <__umoddi3>
 80058d0:	d0e07717 	ldw	r3,-32292(gp)
          break;
      }
      else
      {
          ptimeval->tv_sec--;
          ptimeval->tv_usec += ALT_US;
 80058d4:	010003f4 	movhi	r4,15
 80058d8:	21109004 	addi	r4,r4,16960
   */

  if (tick_rate)
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
    ptimeval->tv_usec = alt_resettime.tv_usec +
 80058dc:	1885883a 	add	r2,r3,r2
 80058e0:	80800115 	stw	r2,4(r16)
     (alt_u32)(((alt_u64)nticks*(ALT_US/tick_rate))%ALT_US);
      
    while(ptimeval->tv_usec < 0) {
 80058e4:	80800117 	ldw	r2,4(r16)
 80058e8:	10000a0e 	bge	r2,zero,8005914 <gettimeofday+0xc4>
      if (ptimeval->tv_sec <= 0)
 80058ec:	80c00017 	ldw	r3,0(r16)
 80058f0:	00c00316 	blt	zero,r3,8005900 <gettimeofday+0xb0>
      {
          ptimeval->tv_sec = 0;
 80058f4:	80000015 	stw	zero,0(r16)
          ptimeval->tv_usec = 0;
 80058f8:	80000115 	stw	zero,4(r16)
 80058fc:	00001106 	br	8005944 <gettimeofday+0xf4>
          break;
      }
      else
      {
          ptimeval->tv_sec--;
 8005900:	18ffffc4 	addi	r3,r3,-1
          ptimeval->tv_usec += ALT_US;
 8005904:	1105883a 	add	r2,r2,r4
          ptimeval->tv_usec = 0;
          break;
      }
      else
      {
          ptimeval->tv_sec--;
 8005908:	80c00015 	stw	r3,0(r16)
          ptimeval->tv_usec += ALT_US;
 800590c:	80800115 	stw	r2,4(r16)
 8005910:	003ff406 	br	80058e4 <__alt_data_end+0xfc0058e4>
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
 8005914:	010003f4 	movhi	r4,15
      ptimeval->tv_sec++;
      ptimeval->tv_usec -= ALT_US;
 8005918:	017ffc74 	movhi	r5,65521
          ptimeval->tv_sec--;
          ptimeval->tv_usec += ALT_US;
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
 800591c:	21108fc4 	addi	r4,r4,16959
      ptimeval->tv_sec++;
      ptimeval->tv_usec -= ALT_US;
 8005920:	296f7004 	addi	r5,r5,-16960
          ptimeval->tv_sec--;
          ptimeval->tv_usec += ALT_US;
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
 8005924:	80800117 	ldw	r2,4(r16)
 8005928:	2080060e 	bge	r4,r2,8005944 <gettimeofday+0xf4>
      ptimeval->tv_sec++;
 800592c:	80c00017 	ldw	r3,0(r16)
      ptimeval->tv_usec -= ALT_US;
 8005930:	1145883a 	add	r2,r2,r5
 8005934:	80800115 	stw	r2,4(r16)
          ptimeval->tv_usec += ALT_US;
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
      ptimeval->tv_sec++;
 8005938:	18c00044 	addi	r3,r3,1
 800593c:	80c00015 	stw	r3,0(r16)
 8005940:	003ff806 	br	8005924 <__alt_data_end+0xfc005924>
      ptimeval->tv_usec -= ALT_US;
    }
      
    if (ptimezone)
 8005944:	88000726 	beq	r17,zero,8005964 <gettimeofday+0x114>
    { 
      ptimezone->tz_minuteswest = alt_timezone.tz_minuteswest;
 8005948:	d0a07817 	ldw	r2,-32288(gp)
 800594c:	88800015 	stw	r2,0(r17)
      ptimezone->tz_dsttime     = alt_timezone.tz_dsttime;
 8005950:	d0a07917 	ldw	r2,-32284(gp)
 8005954:	88800115 	stw	r2,4(r17)
 8005958:	00000206 	br	8005964 <gettimeofday+0x114>
    }

    return 0;
  }

  return -ENOTSUP;
 800595c:	00bfde84 	movi	r2,-134
 8005960:	00000106 	br	8005968 <gettimeofday+0x118>
    { 
      ptimezone->tz_minuteswest = alt_timezone.tz_minuteswest;
      ptimezone->tz_dsttime     = alt_timezone.tz_dsttime;
    }

    return 0;
 8005964:	0005883a 	mov	r2,zero
  }

  return -ENOTSUP;
}
 8005968:	dfc00417 	ldw	ra,16(sp)
 800596c:	dcc00317 	ldw	r19,12(sp)
 8005970:	dc800217 	ldw	r18,8(sp)
 8005974:	dc400117 	ldw	r17,4(sp)
 8005978:	dc000017 	ldw	r16,0(sp)
 800597c:	dec00504 	addi	sp,sp,20
 8005980:	f800283a 	ret

08005984 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 8005984:	8005a101 	jmpi	8005a10 <alt_iic_isr_register>

08005988 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8005988:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800598c:	00bfff84 	movi	r2,-2
 8005990:	2084703a 	and	r2,r4,r2
 8005994:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
 8005998:	00c00044 	movi	r3,1
 800599c:	d0a07a17 	ldw	r2,-32280(gp)
 80059a0:	194a983a 	sll	r5,r3,r5
 80059a4:	288ab03a 	or	r5,r5,r2
 80059a8:	d1607a15 	stw	r5,-32280(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 80059ac:	d0a07a17 	ldw	r2,-32280(gp)
 80059b0:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 80059b4:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
 80059b8:	0005883a 	mov	r2,zero
 80059bc:	f800283a 	ret

080059c0 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 80059c0:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 80059c4:	00bfff84 	movi	r2,-2
 80059c8:	2084703a 	and	r2,r4,r2
 80059cc:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
 80059d0:	00ffff84 	movi	r3,-2
 80059d4:	d0a07a17 	ldw	r2,-32280(gp)
 80059d8:	194a183a 	rol	r5,r3,r5
 80059dc:	288a703a 	and	r5,r5,r2
 80059e0:	d1607a15 	stw	r5,-32280(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 80059e4:	d0a07a17 	ldw	r2,-32280(gp)
 80059e8:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 80059ec:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
 80059f0:	0005883a 	mov	r2,zero
 80059f4:	f800283a 	ret

080059f8 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 80059f8:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
 80059fc:	00800044 	movi	r2,1
 8005a00:	1144983a 	sll	r2,r2,r5
 8005a04:	10c4703a 	and	r2,r2,r3
}
 8005a08:	1004c03a 	cmpne	r2,r2,zero
 8005a0c:	f800283a 	ret

08005a10 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
 8005a10:	00c007c4 	movi	r3,31
 8005a14:	19401616 	blt	r3,r5,8005a70 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 8005a18:	defffe04 	addi	sp,sp,-8
 8005a1c:	dfc00115 	stw	ra,4(sp)
 8005a20:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8005a24:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8005a28:	00ffff84 	movi	r3,-2
 8005a2c:	80c6703a 	and	r3,r16,r3
 8005a30:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
 8005a34:	280490fa 	slli	r2,r5,3
 8005a38:	00c20034 	movhi	r3,2048
 8005a3c:	18db7604 	addi	r3,r3,28120
 8005a40:	1885883a 	add	r2,r3,r2
 8005a44:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
 8005a48:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 8005a4c:	30000226 	beq	r6,zero,8005a58 <alt_iic_isr_register+0x48>
 8005a50:	80059880 	call	8005988 <alt_ic_irq_enable>
 8005a54:	00000106 	br	8005a5c <alt_iic_isr_register+0x4c>
 8005a58:	80059c00 	call	80059c0 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8005a5c:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
 8005a60:	dfc00117 	ldw	ra,4(sp)
 8005a64:	dc000017 	ldw	r16,0(sp)
 8005a68:	dec00204 	addi	sp,sp,8
 8005a6c:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
 8005a70:	00bffa84 	movi	r2,-22
 8005a74:	f800283a 	ret

08005a78 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 8005a78:	deffff04 	addi	sp,sp,-4
 8005a7c:	01020034 	movhi	r4,2048
 8005a80:	01420034 	movhi	r5,2048
 8005a84:	dfc00015 	stw	ra,0(sp)
 8005a88:	211a0e04 	addi	r4,r4,26680
 8005a8c:	295a5504 	addi	r5,r5,26964

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 8005a90:	2140061e 	bne	r4,r5,8005aac <alt_load+0x34>
 8005a94:	01020034 	movhi	r4,2048
 8005a98:	01420034 	movhi	r5,2048
 8005a9c:	21000804 	addi	r4,r4,32
 8005aa0:	29400804 	addi	r5,r5,32
 8005aa4:	2140121e 	bne	r4,r5,8005af0 <alt_load+0x78>
 8005aa8:	00000b06 	br	8005ad8 <alt_load+0x60>
 8005aac:	00c20034 	movhi	r3,2048
 8005ab0:	18da5504 	addi	r3,r3,26964
 8005ab4:	1907c83a 	sub	r3,r3,r4
 8005ab8:	0005883a 	mov	r2,zero
  {
    while( to != end )
 8005abc:	10fff526 	beq	r2,r3,8005a94 <__alt_data_end+0xfc005a94>
    {
      *to++ = *from++;
 8005ac0:	114f883a 	add	r7,r2,r5
 8005ac4:	39c00017 	ldw	r7,0(r7)
 8005ac8:	110d883a 	add	r6,r2,r4
 8005acc:	10800104 	addi	r2,r2,4
 8005ad0:	31c00015 	stw	r7,0(r6)
 8005ad4:	003ff906 	br	8005abc <__alt_data_end+0xfc005abc>
 8005ad8:	01020034 	movhi	r4,2048
 8005adc:	01420034 	movhi	r5,2048
 8005ae0:	21199d04 	addi	r4,r4,26228
 8005ae4:	29599d04 	addi	r5,r5,26228

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 8005ae8:	2140101e 	bne	r4,r5,8005b2c <alt_load+0xb4>
 8005aec:	00000b06 	br	8005b1c <alt_load+0xa4>
 8005af0:	00c20034 	movhi	r3,2048
 8005af4:	18c06004 	addi	r3,r3,384
 8005af8:	1907c83a 	sub	r3,r3,r4
 8005afc:	0005883a 	mov	r2,zero
  {
    while( to != end )
 8005b00:	10fff526 	beq	r2,r3,8005ad8 <__alt_data_end+0xfc005ad8>
    {
      *to++ = *from++;
 8005b04:	114f883a 	add	r7,r2,r5
 8005b08:	39c00017 	ldw	r7,0(r7)
 8005b0c:	110d883a 	add	r6,r2,r4
 8005b10:	10800104 	addi	r2,r2,4
 8005b14:	31c00015 	stw	r7,0(r6)
 8005b18:	003ff906 	br	8005b00 <__alt_data_end+0xfc005b00>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 8005b1c:	8005ec40 	call	8005ec4 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
 8005b20:	dfc00017 	ldw	ra,0(sp)
 8005b24:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
 8005b28:	8005f241 	jmpi	8005f24 <alt_icache_flush_all>
 8005b2c:	00c20034 	movhi	r3,2048
 8005b30:	18da0e04 	addi	r3,r3,26680
 8005b34:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 8005b38:	0005883a 	mov	r2,zero
  {
    while( to != end )
 8005b3c:	18bff726 	beq	r3,r2,8005b1c <__alt_data_end+0xfc005b1c>
    {
      *to++ = *from++;
 8005b40:	114f883a 	add	r7,r2,r5
 8005b44:	39c00017 	ldw	r7,0(r7)
 8005b48:	110d883a 	add	r6,r2,r4
 8005b4c:	10800104 	addi	r2,r2,4
 8005b50:	31c00015 	stw	r7,0(r6)
 8005b54:	003ff906 	br	8005b3c <__alt_data_end+0xfc005b3c>

08005b58 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 8005b58:	defffe04 	addi	sp,sp,-8
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 8005b5c:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 8005b60:	dfc00115 	stw	ra,4(sp)
 8005b64:	dc000015 	stw	r16,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 8005b68:	8005d440 	call	8005d44 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 8005b6c:	8005d640 	call	8005d64 <alt_sys_init>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 8005b70:	8005ec80 	call	8005ec8 <_do_ctors>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 8005b74:	d1a07b17 	ldw	r6,-32276(gp)
 8005b78:	d1607c17 	ldw	r5,-32272(gp)
 8005b7c:	d1207d17 	ldw	r4,-32268(gp)
 8005b80:	8003ff80 	call	8003ff8 <main>
  close(STDOUT_FILENO);
 8005b84:	01000044 	movi	r4,1
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 8005b88:	1021883a 	mov	r16,r2
  close(STDOUT_FILENO);
 8005b8c:	8005e840 	call	8005e84 <close>
  exit (result);
 8005b90:	8009883a 	mov	r4,r16
 8005b94:	8005f100 	call	8005f10 <_exit>

08005b98 <alt_alarm_stop>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8005b98:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8005b9c:	00bfff84 	movi	r2,-2
 8005ba0:	1884703a 	and	r2,r3,r2
 8005ba4:	1001703a 	wrctl	status,r2
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 8005ba8:	21400117 	ldw	r5,4(r4)
 8005bac:	20800017 	ldw	r2,0(r4)
 8005bb0:	11400115 	stw	r5,4(r2)
  entry->previous->next = entry->next;
 8005bb4:	21400117 	ldw	r5,4(r4)
 8005bb8:	28800015 	stw	r2,0(r5)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 8005bbc:	21000115 	stw	r4,4(r4)
  entry->next     = entry;
 8005bc0:	21000015 	stw	r4,0(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8005bc4:	1801703a 	wrctl	status,r3
 8005bc8:	f800283a 	ret

08005bcc <alt_tick>:

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 8005bcc:	d0a07e17 	ldw	r2,-32264(gp)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 8005bd0:	defffb04 	addi	sp,sp,-20
 8005bd4:	dc000015 	stw	r16,0(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 8005bd8:	d4200b17 	ldw	r16,-32724(gp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 8005bdc:	10800044 	addi	r2,r2,1
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 8005be0:	dc800215 	stw	r18,8(sp)
 8005be4:	dc400115 	stw	r17,4(sp)
 8005be8:	dfc00415 	stw	ra,16(sp)
 8005bec:	dcc00315 	stw	r19,12(sp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 8005bf0:	d0a07e15 	stw	r2,-32264(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 8005bf4:	d4600b04 	addi	r17,gp,-32724
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
        {
          alarm->rollover = 1;
 8005bf8:	04800044 	movi	r18,1

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 8005bfc:	84401a26 	beq	r16,r17,8005c68 <alt_tick+0x9c>
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 8005c00:	80800403 	ldbu	r2,16(r16)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  {
    next = (alt_alarm*) alarm->llist.next;
 8005c04:	84c00017 	ldw	r19,0(r16)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 8005c08:	10000326 	beq	r2,zero,8005c18 <alt_tick+0x4c>
 8005c0c:	d0a07e17 	ldw	r2,-32264(gp)
 8005c10:	1000011e 	bne	r2,zero,8005c18 <alt_tick+0x4c>
    {
      alarm->rollover = 0;
 8005c14:	80000405 	stb	zero,16(r16)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 8005c18:	d0e07e17 	ldw	r3,-32264(gp)
 8005c1c:	80800217 	ldw	r2,8(r16)
 8005c20:	18800f36 	bltu	r3,r2,8005c60 <alt_tick+0x94>
 8005c24:	80800403 	ldbu	r2,16(r16)
 8005c28:	10000d1e 	bne	r2,zero,8005c60 <alt_tick+0x94>
    {
      next_callback = alarm->callback (alarm->context);
 8005c2c:	80800317 	ldw	r2,12(r16)
 8005c30:	81000517 	ldw	r4,20(r16)
 8005c34:	103ee83a 	callr	r2

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 8005c38:	1000031e 	bne	r2,zero,8005c48 <alt_tick+0x7c>
      {
        alt_alarm_stop (alarm);
 8005c3c:	8009883a 	mov	r4,r16
 8005c40:	8005b980 	call	8005b98 <alt_alarm_stop>
 8005c44:	00000606 	br	8005c60 <alt_tick+0x94>
      }
      else
      {
        alarm->time += next_callback;
 8005c48:	80c00217 	ldw	r3,8(r16)
 8005c4c:	10c5883a 	add	r2,r2,r3
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 8005c50:	d0e07e17 	ldw	r3,-32264(gp)
      {
        alt_alarm_stop (alarm);
      }
      else
      {
        alarm->time += next_callback;
 8005c54:	80800215 	stw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 8005c58:	10c0012e 	bgeu	r2,r3,8005c60 <alt_tick+0x94>
        {
          alarm->rollover = 1;
 8005c5c:	84800405 	stb	r18,16(r16)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 8005c60:	9821883a 	mov	r16,r19
 8005c64:	003fe506 	br	8005bfc <__alt_data_end+0xfc005bfc>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
 8005c68:	dfc00417 	ldw	ra,16(sp)
 8005c6c:	dcc00317 	ldw	r19,12(sp)
 8005c70:	dc800217 	ldw	r18,8(sp)
 8005c74:	dc400117 	ldw	r17,4(sp)
 8005c78:	dc000017 	ldw	r16,0(sp)
 8005c7c:	dec00504 	addi	sp,sp,20
 8005c80:	f800283a 	ret

08005c84 <times>:
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 8005c84:	d0e07f17 	ldw	r3,-32260(gp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 8005c88:	d0a07e17 	ldw	r2,-32264(gp)
{
  clock_t ticks = alt_nticks(); 

  /* If there is no system clock present, generate an error */

  if (!alt_ticks_per_second())
 8005c8c:	1800101e 	bne	r3,zero,8005cd0 <times+0x4c>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
 8005c90:	d0a00e17 	ldw	r2,-32712(gp)
 8005c94:	10000926 	beq	r2,zero,8005cbc <times+0x38>
 *
 * ALT_TIMES is mapped onto the times() system call in alt_syscall.h
 */
 
clock_t ALT_TIMES (struct tms *buf)
{
 8005c98:	deffff04 	addi	sp,sp,-4
 8005c9c:	dfc00015 	stw	ra,0(sp)
 8005ca0:	103ee83a 	callr	r2

  /* If there is no system clock present, generate an error */

  if (!alt_ticks_per_second())
  {
    ALT_ERRNO = ENOSYS;
 8005ca4:	00c01604 	movi	r3,88
 8005ca8:	10c00015 	stw	r3,0(r2)
    return 0;
 8005cac:	0005883a 	mov	r2,zero
  buf->tms_stime  = ticks;
  buf->tms_cutime = 0;
  buf->tms_cstime = 0;

  return ticks;
}
 8005cb0:	dfc00017 	ldw	ra,0(sp)
 8005cb4:	dec00104 	addi	sp,sp,4
 8005cb8:	f800283a 	ret
 8005cbc:	d0a07504 	addi	r2,gp,-32300

  /* If there is no system clock present, generate an error */

  if (!alt_ticks_per_second())
  {
    ALT_ERRNO = ENOSYS;
 8005cc0:	00c01604 	movi	r3,88
 8005cc4:	10c00015 	stw	r3,0(r2)
    return 0;
 8005cc8:	0005883a 	mov	r2,zero
  buf->tms_stime  = ticks;
  buf->tms_cutime = 0;
  buf->tms_cstime = 0;

  return ticks;
}
 8005ccc:	f800283a 	ret
    return 0;
  }

  /* Otherwise return the elapsed time */

  buf->tms_utime  = 0;
 8005cd0:	20000015 	stw	zero,0(r4)
  buf->tms_stime  = ticks;
 8005cd4:	20800115 	stw	r2,4(r4)
  buf->tms_cutime = 0;
 8005cd8:	20000215 	stw	zero,8(r4)
  buf->tms_cstime = 0;
 8005cdc:	20000315 	stw	zero,12(r4)

  return ticks;
 8005ce0:	f800283a 	ret

08005ce4 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
 8005ce4:	00800044 	movi	r2,1
 8005ce8:	20800226 	beq	r4,r2,8005cf4 <write+0x10>
 8005cec:	00800084 	movi	r2,2
 8005cf0:	2080041e 	bne	r4,r2,8005d04 <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
 8005cf4:	01020034 	movhi	r4,2048
 8005cf8:	000f883a 	mov	r7,zero
 8005cfc:	211a5304 	addi	r4,r4,26956
 8005d00:	8005d681 	jmpi	8005d68 <altera_avalon_jtag_uart_write>
 8005d04:	d0a00e17 	ldw	r2,-32712(gp)
 8005d08:	10000926 	beq	r2,zero,8005d30 <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 8005d0c:	deffff04 	addi	sp,sp,-4
 8005d10:	dfc00015 	stw	ra,0(sp)
 8005d14:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
 8005d18:	00c01444 	movi	r3,81
 8005d1c:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
 8005d20:	00bfffc4 	movi	r2,-1
 8005d24:	dfc00017 	ldw	ra,0(sp)
 8005d28:	dec00104 	addi	sp,sp,4
 8005d2c:	f800283a 	ret
 8005d30:	d0a07504 	addi	r2,gp,-32300
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
 8005d34:	00c01444 	movi	r3,81
 8005d38:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
 8005d3c:	00bfffc4 	movi	r2,-1
 8005d40:	f800283a 	ret

08005d44 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 8005d44:	deffff04 	addi	sp,sp,-4
 8005d48:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
 8005d4c:	8005f9c0 	call	8005f9c <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 8005d50:	00800044 	movi	r2,1
 8005d54:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 8005d58:	dfc00017 	ldw	ra,0(sp)
 8005d5c:	dec00104 	addi	sp,sp,4
 8005d60:	f800283a 	ret

08005d64 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 8005d64:	f800283a 	ret

08005d68 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
 8005d68:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 8005d6c:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
 8005d70:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
 8005d74:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
 8005d78:	2980072e 	bgeu	r5,r6,8005d98 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
 8005d7c:	38c00037 	ldwio	r3,0(r7)
 8005d80:	18ffffec 	andhi	r3,r3,65535
 8005d84:	183ffc26 	beq	r3,zero,8005d78 <__alt_data_end+0xfc005d78>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
 8005d88:	28c00007 	ldb	r3,0(r5)
 8005d8c:	20c00035 	stwio	r3,0(r4)
 8005d90:	29400044 	addi	r5,r5,1
 8005d94:	003ff806 	br	8005d78 <__alt_data_end+0xfc005d78>

  return count;
}
 8005d98:	f800283a 	ret

08005d9c <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 8005d9c:	d8800017 	ldw	r2,0(sp)
 8005da0:	da000117 	ldw	r8,4(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 8005da4:	00c00044 	movi	r3,1

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 8005da8:	da400217 	ldw	r9,8(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 8005dac:	194a983a 	sll	r5,r3,r5
int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  const alt_u8 * write_end = write_data + write_length;
 8005db0:	399d883a 	add	r14,r7,r6
  alt_u8 * read_end = read_data + read_length;
 8005db4:	409f883a 	add	r15,r8,r2
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 8005db8:	21400535 	stwio	r5,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
 8005dbc:	48c0008c 	andi	r3,r9,2
 8005dc0:	1800021e 	bne	r3,zero,8005dcc <alt_avalon_spi_command+0x30>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 8005dc4:	00c10004 	movi	r3,1024
 8005dc8:	20c00335 	stwio	r3,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
 8005dcc:	20c00037 	ldwio	r3,0(r4)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
 8005dd0:	00c00044 	movi	r3,1
                           alt_u32 flags)
{
  const alt_u8 * write_end = write_data + write_length;
  alt_u8 * read_end = read_data + read_length;

  alt_u32 write_zeros = read_length;
 8005dd4:	1015883a 	mov	r10,r2
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 8005dd8:	22c00204 	addi	r11,r4,8
      if (write_data < write_end)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
      else if (write_zeros > 0)
      {
        write_zeros--;
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 8005ddc:	23000104 	addi	r12,r4,4
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 8005de0:	59400037 	ldwio	r5,0(r11)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 8005de4:	2b40100c 	andi	r13,r5,64
 8005de8:	2940200c 	andi	r5,r5,128
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 8005dec:	68000126 	beq	r13,zero,8005df4 <alt_avalon_spi_command+0x58>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 8005df0:	1800031e 	bne	r3,zero,8005e00 <alt_avalon_spi_command+0x64>
 8005df4:	283ffa26 	beq	r5,zero,8005de0 <__alt_data_end+0xfc005de0>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
 8005df8:	68000e26 	beq	r13,zero,8005e34 <alt_avalon_spi_command+0x98>
 8005dfc:	00001e06 	br	8005e78 <alt_avalon_spi_command+0xdc>
 8005e00:	00c00c0e 	bge	zero,r3,8005e34 <alt_avalon_spi_command+0x98>
    {
      credits--;
 8005e04:	18ffffc4 	addi	r3,r3,-1

      if (write_data < write_end)
 8005e08:	3b80052e 	bgeu	r7,r14,8005e20 <alt_avalon_spi_command+0x84>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
 8005e0c:	3b400044 	addi	r13,r7,1
 8005e10:	39c00003 	ldbu	r7,0(r7)
 8005e14:	61c00035 	stwio	r7,0(r12)
 8005e18:	680f883a 	mov	r7,r13
 8005e1c:	00000506 	br	8005e34 <alt_avalon_spi_command+0x98>
      else if (write_zeros > 0)
 8005e20:	50000326 	beq	r10,zero,8005e30 <alt_avalon_spi_command+0x94>
      {
        write_zeros--;
 8005e24:	52bfffc4 	addi	r10,r10,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 8005e28:	60000035 	stwio	zero,0(r12)
 8005e2c:	00000106 	br	8005e34 <alt_avalon_spi_command+0x98>
      }
      else
        credits = -1024;
 8005e30:	00ff0004 	movi	r3,-1024
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
 8005e34:	283fea26 	beq	r5,zero,8005de0 <__alt_data_end+0xfc005de0>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
 8005e38:	21400037 	ldwio	r5,0(r4)

      if (read_ignore > 0)
 8005e3c:	30000226 	beq	r6,zero,8005e48 <alt_avalon_spi_command+0xac>
        read_ignore--;
 8005e40:	31bfffc4 	addi	r6,r6,-1
 8005e44:	00000206 	br	8005e50 <alt_avalon_spi_command+0xb4>
      else
        *read_data++ = (alt_u8)rxdata;
 8005e48:	41400005 	stb	r5,0(r8)
 8005e4c:	42000044 	addi	r8,r8,1
      credits++;
 8005e50:	18c00044 	addi	r3,r3,1

      if (read_ignore == 0 && read_data == read_end)
 8005e54:	303fe21e 	bne	r6,zero,8005de0 <__alt_data_end+0xfc005de0>
 8005e58:	43ffe11e 	bne	r8,r15,8005de0 <__alt_data_end+0xfc005de0>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 8005e5c:	58c00037 	ldwio	r3,0(r11)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
 8005e60:	18c0080c 	andi	r3,r3,32
 8005e64:	183ffd26 	beq	r3,zero,8005e5c <__alt_data_end+0xfc005e5c>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
 8005e68:	4a40004c 	andi	r9,r9,1
 8005e6c:	4800041e 	bne	r9,zero,8005e80 <alt_avalon_spi_command+0xe4>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
 8005e70:	20000335 	stwio	zero,12(r4)

  return read_length;
 8005e74:	f800283a 	ret
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
 8005e78:	00ffef0e 	bge	zero,r3,8005e38 <__alt_data_end+0xfc005e38>
 8005e7c:	003fe106 	br	8005e04 <__alt_data_end+0xfc005e04>
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);

  return read_length;
}
 8005e80:	f800283a 	ret

08005e84 <close>:
 8005e84:	d0a00e17 	ldw	r2,-32712(gp)
 8005e88:	10000926 	beq	r2,zero,8005eb0 <close+0x2c>
#include "os/alt_syscall.h"

#ifdef ALT_USE_DIRECT_DRIVERS

int ALT_CLOSE (int fildes)
{
 8005e8c:	deffff04 	addi	sp,sp,-4
 8005e90:	dfc00015 	stw	ra,0(sp)
 8005e94:	103ee83a 	callr	r2
  
  ALT_STUB_WARNING(close);
  
  /* Indicate an error */
  
  ALT_ERRNO = ENOSYS;
 8005e98:	00c01604 	movi	r3,88
 8005e9c:	10c00015 	stw	r3,0(r2)
  return -1;
}
 8005ea0:	00bfffc4 	movi	r2,-1
 8005ea4:	dfc00017 	ldw	ra,0(sp)
 8005ea8:	dec00104 	addi	sp,sp,4
 8005eac:	f800283a 	ret
 8005eb0:	d0a07504 	addi	r2,gp,-32300
  
  ALT_STUB_WARNING(close);
  
  /* Indicate an error */
  
  ALT_ERRNO = ENOSYS;
 8005eb4:	00c01604 	movi	r3,88
 8005eb8:	10c00015 	stw	r3,0(r2)
  return -1;
}
 8005ebc:	00bfffc4 	movi	r2,-1
 8005ec0:	f800283a 	ret

08005ec4 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 8005ec4:	f800283a 	ret

08005ec8 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 8005ec8:	defffd04 	addi	sp,sp,-12
 8005ecc:	dc400115 	stw	r17,4(sp)
 8005ed0:	dc000015 	stw	r16,0(sp)
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 8005ed4:	04420034 	movhi	r17,2048
 8005ed8:	04020034 	movhi	r16,2048
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 8005edc:	dfc00215 	stw	ra,8(sp)
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 8005ee0:	84199c04 	addi	r16,r16,26224
 8005ee4:	8c599d04 	addi	r17,r17,26228
 8005ee8:	84400436 	bltu	r16,r17,8005efc <_do_ctors+0x34>
        (*ctor) (); 
 8005eec:	80800017 	ldw	r2,0(r16)

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 8005ef0:	843fff04 	addi	r16,r16,-4
        (*ctor) (); 
 8005ef4:	103ee83a 	callr	r2
 8005ef8:	003ffb06 	br	8005ee8 <__alt_data_end+0xfc005ee8>
}
 8005efc:	dfc00217 	ldw	ra,8(sp)
 8005f00:	dc400117 	ldw	r17,4(sp)
 8005f04:	dc000017 	ldw	r16,0(sp)
 8005f08:	dec00304 	addi	sp,sp,12
 8005f0c:	f800283a 	ret

08005f10 <_exit>:
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 8005f10:	20000226 	beq	r4,zero,8005f1c <_exit+0xc>
    ALT_SIM_FAIL();
 8005f14:	002af070 	cmpltui	zero,zero,43969
 8005f18:	00000106 	br	8005f20 <_exit+0x10>
  } else {
    ALT_SIM_PASS();
 8005f1c:	002af0b0 	cmpltui	zero,zero,43970
 8005f20:	003fff06 	br	8005f20 <__alt_data_end+0xfc005f20>

08005f24 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 8005f24:	f800283a 	ret

08005f28 <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
 8005f28:	213ffe84 	addi	r4,r4,-6
 8005f2c:	008003c4 	movi	r2,15
 8005f30:	11001636 	bltu	r2,r4,8005f8c <alt_exception_cause_generated_bad_addr+0x64>
 8005f34:	200890ba 	slli	r4,r4,2
 8005f38:	00820034 	movhi	r2,2048
 8005f3c:	1097d304 	addi	r2,r2,24396
 8005f40:	2089883a 	add	r4,r4,r2
 8005f44:	20800017 	ldw	r2,0(r4)
 8005f48:	1000683a 	jmp	r2
 8005f4c:	08005f94 	ori	zero,at,382
 8005f50:	08005f94 	ori	zero,at,382
 8005f54:	08005f8c 	andi	zero,at,382
 8005f58:	08005f8c 	andi	zero,at,382
 8005f5c:	08005f8c 	andi	zero,at,382
 8005f60:	08005f94 	ori	zero,at,382
 8005f64:	08005f8c 	andi	zero,at,382
 8005f68:	08005f8c 	andi	zero,at,382
 8005f6c:	08005f94 	ori	zero,at,382
 8005f70:	08005f94 	ori	zero,at,382
 8005f74:	08005f8c 	andi	zero,at,382
 8005f78:	08005f94 	ori	zero,at,382
 8005f7c:	08005f8c 	andi	zero,at,382
 8005f80:	08005f8c 	andi	zero,at,382
 8005f84:	08005f8c 	andi	zero,at,382
 8005f88:	08005f94 	ori	zero,at,382
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 8005f8c:	0005883a 	mov	r2,zero
 8005f90:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 8005f94:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
 8005f98:	f800283a 	ret

08005f9c <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
 8005f9c:	000170fa 	wrctl	ienable,zero
 8005fa0:	f800283a 	ret

08005fa4 <__muldi3>:
 8005fa4:	defff604 	addi	sp,sp,-40
 8005fa8:	dd800615 	stw	r22,24(sp)
 8005fac:	dd400515 	stw	r21,20(sp)
 8005fb0:	dc400115 	stw	r17,4(sp)
 8005fb4:	357fffcc 	andi	r21,r6,65535
 8005fb8:	2022d43a 	srli	r17,r4,16
 8005fbc:	25bfffcc 	andi	r22,r4,65535
 8005fc0:	dcc00315 	stw	r19,12(sp)
 8005fc4:	dc800215 	stw	r18,8(sp)
 8005fc8:	2027883a 	mov	r19,r4
 8005fcc:	2825883a 	mov	r18,r5
 8005fd0:	b009883a 	mov	r4,r22
 8005fd4:	a80b883a 	mov	r5,r21
 8005fd8:	dfc00915 	stw	ra,36(sp)
 8005fdc:	df000815 	stw	fp,32(sp)
 8005fe0:	ddc00715 	stw	r23,28(sp)
 8005fe4:	3839883a 	mov	fp,r7
 8005fe8:	302ed43a 	srli	r23,r6,16
 8005fec:	dd000415 	stw	r20,16(sp)
 8005ff0:	dc000015 	stw	r16,0(sp)
 8005ff4:	3029883a 	mov	r20,r6
 8005ff8:	8004b740 	call	8004b74 <__mulsi3>
 8005ffc:	a80b883a 	mov	r5,r21
 8006000:	8809883a 	mov	r4,r17
 8006004:	1021883a 	mov	r16,r2
 8006008:	8004b740 	call	8004b74 <__mulsi3>
 800600c:	8809883a 	mov	r4,r17
 8006010:	b80b883a 	mov	r5,r23
 8006014:	102b883a 	mov	r21,r2
 8006018:	8004b740 	call	8004b74 <__mulsi3>
 800601c:	b80b883a 	mov	r5,r23
 8006020:	b009883a 	mov	r4,r22
 8006024:	1023883a 	mov	r17,r2
 8006028:	8004b740 	call	8004b74 <__mulsi3>
 800602c:	8006d43a 	srli	r3,r16,16
 8006030:	1545883a 	add	r2,r2,r21
 8006034:	1885883a 	add	r2,r3,r2
 8006038:	1540022e 	bgeu	r2,r21,8006044 <__muldi3+0xa0>
 800603c:	00c00074 	movhi	r3,1
 8006040:	88e3883a 	add	r17,r17,r3
 8006044:	1006d43a 	srli	r3,r2,16
 8006048:	1004943a 	slli	r2,r2,16
 800604c:	e00b883a 	mov	r5,fp
 8006050:	9809883a 	mov	r4,r19
 8006054:	843fffcc 	andi	r16,r16,65535
 8006058:	1c63883a 	add	r17,r3,r17
 800605c:	1421883a 	add	r16,r2,r16
 8006060:	8004b740 	call	8004b74 <__mulsi3>
 8006064:	900b883a 	mov	r5,r18
 8006068:	a009883a 	mov	r4,r20
 800606c:	1027883a 	mov	r19,r2
 8006070:	8004b740 	call	8004b74 <__mulsi3>
 8006074:	9885883a 	add	r2,r19,r2
 8006078:	1447883a 	add	r3,r2,r17
 800607c:	8005883a 	mov	r2,r16
 8006080:	dfc00917 	ldw	ra,36(sp)
 8006084:	df000817 	ldw	fp,32(sp)
 8006088:	ddc00717 	ldw	r23,28(sp)
 800608c:	dd800617 	ldw	r22,24(sp)
 8006090:	dd400517 	ldw	r21,20(sp)
 8006094:	dd000417 	ldw	r20,16(sp)
 8006098:	dcc00317 	ldw	r19,12(sp)
 800609c:	dc800217 	ldw	r18,8(sp)
 80060a0:	dc400117 	ldw	r17,4(sp)
 80060a4:	dc000017 	ldw	r16,0(sp)
 80060a8:	dec00a04 	addi	sp,sp,40
 80060ac:	f800283a 	ret

080060b0 <__umoddi3>:
 80060b0:	defff304 	addi	sp,sp,-52
 80060b4:	df000b15 	stw	fp,44(sp)
 80060b8:	dc400415 	stw	r17,16(sp)
 80060bc:	dc000315 	stw	r16,12(sp)
 80060c0:	dfc00c15 	stw	ra,48(sp)
 80060c4:	ddc00a15 	stw	r23,40(sp)
 80060c8:	dd800915 	stw	r22,36(sp)
 80060cc:	dd400815 	stw	r21,32(sp)
 80060d0:	dd000715 	stw	r20,28(sp)
 80060d4:	dcc00615 	stw	r19,24(sp)
 80060d8:	dc800515 	stw	r18,20(sp)
 80060dc:	2021883a 	mov	r16,r4
 80060e0:	2823883a 	mov	r17,r5
 80060e4:	2839883a 	mov	fp,r5
 80060e8:	3800401e 	bne	r7,zero,80061ec <__umoddi3+0x13c>
 80060ec:	3027883a 	mov	r19,r6
 80060f0:	2029883a 	mov	r20,r4
 80060f4:	2980552e 	bgeu	r5,r6,800624c <__umoddi3+0x19c>
 80060f8:	00bfffd4 	movui	r2,65535
 80060fc:	1180a236 	bltu	r2,r6,8006388 <__umoddi3+0x2d8>
 8006100:	01003fc4 	movi	r4,255
 8006104:	2189803a 	cmpltu	r4,r4,r6
 8006108:	200890fa 	slli	r4,r4,3
 800610c:	3104d83a 	srl	r2,r6,r4
 8006110:	00c20034 	movhi	r3,2048
 8006114:	18d9cd84 	addi	r3,r3,26422
 8006118:	1885883a 	add	r2,r3,r2
 800611c:	10c00003 	ldbu	r3,0(r2)
 8006120:	00800804 	movi	r2,32
 8006124:	1909883a 	add	r4,r3,r4
 8006128:	1125c83a 	sub	r18,r2,r4
 800612c:	90000526 	beq	r18,zero,8006144 <__umoddi3+0x94>
 8006130:	8ca2983a 	sll	r17,r17,r18
 8006134:	8108d83a 	srl	r4,r16,r4
 8006138:	34a6983a 	sll	r19,r6,r18
 800613c:	84a8983a 	sll	r20,r16,r18
 8006140:	2478b03a 	or	fp,r4,r17
 8006144:	982cd43a 	srli	r22,r19,16
 8006148:	e009883a 	mov	r4,fp
 800614c:	9dffffcc 	andi	r23,r19,65535
 8006150:	b00b883a 	mov	r5,r22
 8006154:	800571c0 	call	800571c <__umodsi3>
 8006158:	b00b883a 	mov	r5,r22
 800615c:	e009883a 	mov	r4,fp
 8006160:	102b883a 	mov	r21,r2
 8006164:	80056b80 	call	80056b8 <__udivsi3>
 8006168:	100b883a 	mov	r5,r2
 800616c:	b809883a 	mov	r4,r23
 8006170:	8004b740 	call	8004b74 <__mulsi3>
 8006174:	a82a943a 	slli	r21,r21,16
 8006178:	a006d43a 	srli	r3,r20,16
 800617c:	1d46b03a 	or	r3,r3,r21
 8006180:	1880032e 	bgeu	r3,r2,8006190 <__umoddi3+0xe0>
 8006184:	1cc7883a 	add	r3,r3,r19
 8006188:	1cc00136 	bltu	r3,r19,8006190 <__umoddi3+0xe0>
 800618c:	18813136 	bltu	r3,r2,8006654 <__umoddi3+0x5a4>
 8006190:	18a1c83a 	sub	r16,r3,r2
 8006194:	b00b883a 	mov	r5,r22
 8006198:	8009883a 	mov	r4,r16
 800619c:	800571c0 	call	800571c <__umodsi3>
 80061a0:	b00b883a 	mov	r5,r22
 80061a4:	8009883a 	mov	r4,r16
 80061a8:	1023883a 	mov	r17,r2
 80061ac:	80056b80 	call	80056b8 <__udivsi3>
 80061b0:	100b883a 	mov	r5,r2
 80061b4:	b809883a 	mov	r4,r23
 80061b8:	8822943a 	slli	r17,r17,16
 80061bc:	8004b740 	call	8004b74 <__mulsi3>
 80061c0:	a0ffffcc 	andi	r3,r20,65535
 80061c4:	1c46b03a 	or	r3,r3,r17
 80061c8:	1880042e 	bgeu	r3,r2,80061dc <__umoddi3+0x12c>
 80061cc:	1cc7883a 	add	r3,r3,r19
 80061d0:	1cc00236 	bltu	r3,r19,80061dc <__umoddi3+0x12c>
 80061d4:	1880012e 	bgeu	r3,r2,80061dc <__umoddi3+0x12c>
 80061d8:	1cc7883a 	add	r3,r3,r19
 80061dc:	1885c83a 	sub	r2,r3,r2
 80061e0:	1484d83a 	srl	r2,r2,r18
 80061e4:	0007883a 	mov	r3,zero
 80061e8:	00005306 	br	8006338 <__umoddi3+0x288>
 80061ec:	29c05036 	bltu	r5,r7,8006330 <__umoddi3+0x280>
 80061f0:	00bfffd4 	movui	r2,65535
 80061f4:	11c05c2e 	bgeu	r2,r7,8006368 <__umoddi3+0x2b8>
 80061f8:	00804034 	movhi	r2,256
 80061fc:	10bfffc4 	addi	r2,r2,-1
 8006200:	11c10636 	bltu	r2,r7,800661c <__umoddi3+0x56c>
 8006204:	01000404 	movi	r4,16
 8006208:	3904d83a 	srl	r2,r7,r4
 800620c:	00c20034 	movhi	r3,2048
 8006210:	18d9cd84 	addi	r3,r3,26422
 8006214:	1885883a 	add	r2,r3,r2
 8006218:	14c00003 	ldbu	r19,0(r2)
 800621c:	00c00804 	movi	r3,32
 8006220:	9927883a 	add	r19,r19,r4
 8006224:	1ce9c83a 	sub	r20,r3,r19
 8006228:	a0005c1e 	bne	r20,zero,800639c <__umoddi3+0x2ec>
 800622c:	3c400136 	bltu	r7,r17,8006234 <__umoddi3+0x184>
 8006230:	81810a36 	bltu	r16,r6,800665c <__umoddi3+0x5ac>
 8006234:	8185c83a 	sub	r2,r16,r6
 8006238:	89e3c83a 	sub	r17,r17,r7
 800623c:	8089803a 	cmpltu	r4,r16,r2
 8006240:	8939c83a 	sub	fp,r17,r4
 8006244:	e007883a 	mov	r3,fp
 8006248:	00003b06 	br	8006338 <__umoddi3+0x288>
 800624c:	3000041e 	bne	r6,zero,8006260 <__umoddi3+0x1b0>
 8006250:	000b883a 	mov	r5,zero
 8006254:	01000044 	movi	r4,1
 8006258:	80056b80 	call	80056b8 <__udivsi3>
 800625c:	1027883a 	mov	r19,r2
 8006260:	00bfffd4 	movui	r2,65535
 8006264:	14c0442e 	bgeu	r2,r19,8006378 <__umoddi3+0x2c8>
 8006268:	00804034 	movhi	r2,256
 800626c:	10bfffc4 	addi	r2,r2,-1
 8006270:	14c0ec36 	bltu	r2,r19,8006624 <__umoddi3+0x574>
 8006274:	00800404 	movi	r2,16
 8006278:	9886d83a 	srl	r3,r19,r2
 800627c:	01020034 	movhi	r4,2048
 8006280:	2119cd84 	addi	r4,r4,26422
 8006284:	20c7883a 	add	r3,r4,r3
 8006288:	18c00003 	ldbu	r3,0(r3)
 800628c:	1887883a 	add	r3,r3,r2
 8006290:	00800804 	movi	r2,32
 8006294:	10e5c83a 	sub	r18,r2,r3
 8006298:	9000ab1e 	bne	r18,zero,8006548 <__umoddi3+0x498>
 800629c:	982cd43a 	srli	r22,r19,16
 80062a0:	8ce3c83a 	sub	r17,r17,r19
 80062a4:	9dffffcc 	andi	r23,r19,65535
 80062a8:	b00b883a 	mov	r5,r22
 80062ac:	8809883a 	mov	r4,r17
 80062b0:	800571c0 	call	800571c <__umodsi3>
 80062b4:	b00b883a 	mov	r5,r22
 80062b8:	8809883a 	mov	r4,r17
 80062bc:	102b883a 	mov	r21,r2
 80062c0:	80056b80 	call	80056b8 <__udivsi3>
 80062c4:	b80b883a 	mov	r5,r23
 80062c8:	1009883a 	mov	r4,r2
 80062cc:	8004b740 	call	8004b74 <__mulsi3>
 80062d0:	a82a943a 	slli	r21,r21,16
 80062d4:	a006d43a 	srli	r3,r20,16
 80062d8:	1d46b03a 	or	r3,r3,r21
 80062dc:	1880042e 	bgeu	r3,r2,80062f0 <__umoddi3+0x240>
 80062e0:	1cc7883a 	add	r3,r3,r19
 80062e4:	1cc00236 	bltu	r3,r19,80062f0 <__umoddi3+0x240>
 80062e8:	1880012e 	bgeu	r3,r2,80062f0 <__umoddi3+0x240>
 80062ec:	1cc7883a 	add	r3,r3,r19
 80062f0:	18a1c83a 	sub	r16,r3,r2
 80062f4:	b00b883a 	mov	r5,r22
 80062f8:	8009883a 	mov	r4,r16
 80062fc:	800571c0 	call	800571c <__umodsi3>
 8006300:	1023883a 	mov	r17,r2
 8006304:	b00b883a 	mov	r5,r22
 8006308:	8009883a 	mov	r4,r16
 800630c:	80056b80 	call	80056b8 <__udivsi3>
 8006310:	8822943a 	slli	r17,r17,16
 8006314:	b80b883a 	mov	r5,r23
 8006318:	1009883a 	mov	r4,r2
 800631c:	8004b740 	call	8004b74 <__mulsi3>
 8006320:	a53fffcc 	andi	r20,r20,65535
 8006324:	a446b03a 	or	r3,r20,r17
 8006328:	18bfac2e 	bgeu	r3,r2,80061dc <__alt_data_end+0xfc0061dc>
 800632c:	003fa706 	br	80061cc <__alt_data_end+0xfc0061cc>
 8006330:	2005883a 	mov	r2,r4
 8006334:	2807883a 	mov	r3,r5
 8006338:	dfc00c17 	ldw	ra,48(sp)
 800633c:	df000b17 	ldw	fp,44(sp)
 8006340:	ddc00a17 	ldw	r23,40(sp)
 8006344:	dd800917 	ldw	r22,36(sp)
 8006348:	dd400817 	ldw	r21,32(sp)
 800634c:	dd000717 	ldw	r20,28(sp)
 8006350:	dcc00617 	ldw	r19,24(sp)
 8006354:	dc800517 	ldw	r18,20(sp)
 8006358:	dc400417 	ldw	r17,16(sp)
 800635c:	dc000317 	ldw	r16,12(sp)
 8006360:	dec00d04 	addi	sp,sp,52
 8006364:	f800283a 	ret
 8006368:	04c03fc4 	movi	r19,255
 800636c:	99c9803a 	cmpltu	r4,r19,r7
 8006370:	200890fa 	slli	r4,r4,3
 8006374:	003fa406 	br	8006208 <__alt_data_end+0xfc006208>
 8006378:	00803fc4 	movi	r2,255
 800637c:	14c5803a 	cmpltu	r2,r2,r19
 8006380:	100490fa 	slli	r2,r2,3
 8006384:	003fbc06 	br	8006278 <__alt_data_end+0xfc006278>
 8006388:	00804034 	movhi	r2,256
 800638c:	10bfffc4 	addi	r2,r2,-1
 8006390:	1180a636 	bltu	r2,r6,800662c <__umoddi3+0x57c>
 8006394:	01000404 	movi	r4,16
 8006398:	003f5c06 	br	800610c <__alt_data_end+0xfc00610c>
 800639c:	3d0e983a 	sll	r7,r7,r20
 80063a0:	34ead83a 	srl	r21,r6,r19
 80063a4:	8cc6d83a 	srl	r3,r17,r19
 80063a8:	8d10983a 	sll	r8,r17,r20
 80063ac:	3d6ab03a 	or	r21,r7,r21
 80063b0:	a82cd43a 	srli	r22,r21,16
 80063b4:	84e2d83a 	srl	r17,r16,r19
 80063b8:	1809883a 	mov	r4,r3
 80063bc:	b00b883a 	mov	r5,r22
 80063c0:	8a22b03a 	or	r17,r17,r8
 80063c4:	3524983a 	sll	r18,r6,r20
 80063c8:	dc400015 	stw	r17,0(sp)
 80063cc:	d8c00115 	stw	r3,4(sp)
 80063d0:	800571c0 	call	800571c <__umodsi3>
 80063d4:	d8c00117 	ldw	r3,4(sp)
 80063d8:	b00b883a 	mov	r5,r22
 80063dc:	1039883a 	mov	fp,r2
 80063e0:	1809883a 	mov	r4,r3
 80063e4:	80056b80 	call	80056b8 <__udivsi3>
 80063e8:	adffffcc 	andi	r23,r21,65535
 80063ec:	100b883a 	mov	r5,r2
 80063f0:	b809883a 	mov	r4,r23
 80063f4:	1023883a 	mov	r17,r2
 80063f8:	8004b740 	call	8004b74 <__mulsi3>
 80063fc:	d9400017 	ldw	r5,0(sp)
 8006400:	e008943a 	slli	r4,fp,16
 8006404:	8520983a 	sll	r16,r16,r20
 8006408:	2806d43a 	srli	r3,r5,16
 800640c:	1906b03a 	or	r3,r3,r4
 8006410:	1880042e 	bgeu	r3,r2,8006424 <__umoddi3+0x374>
 8006414:	1d47883a 	add	r3,r3,r21
 8006418:	893fffc4 	addi	r4,r17,-1
 800641c:	1d40892e 	bgeu	r3,r21,8006644 <__umoddi3+0x594>
 8006420:	2023883a 	mov	r17,r4
 8006424:	18b9c83a 	sub	fp,r3,r2
 8006428:	b00b883a 	mov	r5,r22
 800642c:	e009883a 	mov	r4,fp
 8006430:	800571c0 	call	800571c <__umodsi3>
 8006434:	b00b883a 	mov	r5,r22
 8006438:	e009883a 	mov	r4,fp
 800643c:	d8800215 	stw	r2,8(sp)
 8006440:	80056b80 	call	80056b8 <__udivsi3>
 8006444:	100b883a 	mov	r5,r2
 8006448:	b809883a 	mov	r4,r23
 800644c:	102d883a 	mov	r22,r2
 8006450:	8004b740 	call	8004b74 <__mulsi3>
 8006454:	d9800217 	ldw	r6,8(sp)
 8006458:	d8c00017 	ldw	r3,0(sp)
 800645c:	300c943a 	slli	r6,r6,16
 8006460:	1a3fffcc 	andi	r8,r3,65535
 8006464:	4190b03a 	or	r8,r8,r6
 8006468:	4080042e 	bgeu	r8,r2,800647c <__umoddi3+0x3cc>
 800646c:	4551883a 	add	r8,r8,r21
 8006470:	b0ffffc4 	addi	r3,r22,-1
 8006474:	45406f2e 	bgeu	r8,r21,8006634 <__umoddi3+0x584>
 8006478:	182d883a 	mov	r22,r3
 800647c:	880e943a 	slli	r7,r17,16
 8006480:	9006d43a 	srli	r3,r18,16
 8006484:	91bfffcc 	andi	r6,r18,65535
 8006488:	3dacb03a 	or	r22,r7,r22
 800648c:	b02ed43a 	srli	r23,r22,16
 8006490:	b5bfffcc 	andi	r22,r22,65535
 8006494:	300b883a 	mov	r5,r6
 8006498:	b009883a 	mov	r4,r22
 800649c:	40a3c83a 	sub	r17,r8,r2
 80064a0:	d8c00115 	stw	r3,4(sp)
 80064a4:	d9800215 	stw	r6,8(sp)
 80064a8:	8004b740 	call	8004b74 <__mulsi3>
 80064ac:	d9800217 	ldw	r6,8(sp)
 80064b0:	b809883a 	mov	r4,r23
 80064b4:	1039883a 	mov	fp,r2
 80064b8:	300b883a 	mov	r5,r6
 80064bc:	8004b740 	call	8004b74 <__mulsi3>
 80064c0:	d8c00117 	ldw	r3,4(sp)
 80064c4:	b809883a 	mov	r4,r23
 80064c8:	d8800215 	stw	r2,8(sp)
 80064cc:	180b883a 	mov	r5,r3
 80064d0:	8004b740 	call	8004b74 <__mulsi3>
 80064d4:	d8c00117 	ldw	r3,4(sp)
 80064d8:	b009883a 	mov	r4,r22
 80064dc:	102f883a 	mov	r23,r2
 80064e0:	180b883a 	mov	r5,r3
 80064e4:	8004b740 	call	8004b74 <__mulsi3>
 80064e8:	d9800217 	ldw	r6,8(sp)
 80064ec:	e006d43a 	srli	r3,fp,16
 80064f0:	1185883a 	add	r2,r2,r6
 80064f4:	1885883a 	add	r2,r3,r2
 80064f8:	1180022e 	bgeu	r2,r6,8006504 <__umoddi3+0x454>
 80064fc:	00c00074 	movhi	r3,1
 8006500:	b8ef883a 	add	r23,r23,r3
 8006504:	1006d43a 	srli	r3,r2,16
 8006508:	1004943a 	slli	r2,r2,16
 800650c:	e73fffcc 	andi	fp,fp,65535
 8006510:	1dc7883a 	add	r3,r3,r23
 8006514:	1739883a 	add	fp,r2,fp
 8006518:	88c03a36 	bltu	r17,r3,8006604 <__umoddi3+0x554>
 800651c:	88c05126 	beq	r17,r3,8006664 <__umoddi3+0x5b4>
 8006520:	88c9c83a 	sub	r4,r17,r3
 8006524:	e00f883a 	mov	r7,fp
 8006528:	81cfc83a 	sub	r7,r16,r7
 800652c:	81c7803a 	cmpltu	r3,r16,r7
 8006530:	20c7c83a 	sub	r3,r4,r3
 8006534:	1cc4983a 	sll	r2,r3,r19
 8006538:	3d0ed83a 	srl	r7,r7,r20
 800653c:	1d06d83a 	srl	r3,r3,r20
 8006540:	11c4b03a 	or	r2,r2,r7
 8006544:	003f7c06 	br	8006338 <__alt_data_end+0xfc006338>
 8006548:	9ca6983a 	sll	r19,r19,r18
 800654c:	88f8d83a 	srl	fp,r17,r3
 8006550:	80c4d83a 	srl	r2,r16,r3
 8006554:	982cd43a 	srli	r22,r19,16
 8006558:	8ca2983a 	sll	r17,r17,r18
 800655c:	e009883a 	mov	r4,fp
 8006560:	b00b883a 	mov	r5,r22
 8006564:	146ab03a 	or	r21,r2,r17
 8006568:	800571c0 	call	800571c <__umodsi3>
 800656c:	b00b883a 	mov	r5,r22
 8006570:	e009883a 	mov	r4,fp
 8006574:	1029883a 	mov	r20,r2
 8006578:	9dffffcc 	andi	r23,r19,65535
 800657c:	80056b80 	call	80056b8 <__udivsi3>
 8006580:	b809883a 	mov	r4,r23
 8006584:	100b883a 	mov	r5,r2
 8006588:	8004b740 	call	8004b74 <__mulsi3>
 800658c:	a008943a 	slli	r4,r20,16
 8006590:	a806d43a 	srli	r3,r21,16
 8006594:	84a8983a 	sll	r20,r16,r18
 8006598:	1906b03a 	or	r3,r3,r4
 800659c:	1880042e 	bgeu	r3,r2,80065b0 <__umoddi3+0x500>
 80065a0:	1cc7883a 	add	r3,r3,r19
 80065a4:	1cc00236 	bltu	r3,r19,80065b0 <__umoddi3+0x500>
 80065a8:	1880012e 	bgeu	r3,r2,80065b0 <__umoddi3+0x500>
 80065ac:	1cc7883a 	add	r3,r3,r19
 80065b0:	18a3c83a 	sub	r17,r3,r2
 80065b4:	b00b883a 	mov	r5,r22
 80065b8:	8809883a 	mov	r4,r17
 80065bc:	800571c0 	call	800571c <__umodsi3>
 80065c0:	b00b883a 	mov	r5,r22
 80065c4:	8809883a 	mov	r4,r17
 80065c8:	1021883a 	mov	r16,r2
 80065cc:	80056b80 	call	80056b8 <__udivsi3>
 80065d0:	100b883a 	mov	r5,r2
 80065d4:	b809883a 	mov	r4,r23
 80065d8:	8020943a 	slli	r16,r16,16
 80065dc:	8004b740 	call	8004b74 <__mulsi3>
 80065e0:	a8ffffcc 	andi	r3,r21,65535
 80065e4:	1c06b03a 	or	r3,r3,r16
 80065e8:	1880042e 	bgeu	r3,r2,80065fc <__umoddi3+0x54c>
 80065ec:	1cc7883a 	add	r3,r3,r19
 80065f0:	1cc00236 	bltu	r3,r19,80065fc <__umoddi3+0x54c>
 80065f4:	1880012e 	bgeu	r3,r2,80065fc <__umoddi3+0x54c>
 80065f8:	1cc7883a 	add	r3,r3,r19
 80065fc:	18a3c83a 	sub	r17,r3,r2
 8006600:	003f2906 	br	80062a8 <__alt_data_end+0xfc0062a8>
 8006604:	e48fc83a 	sub	r7,fp,r18
 8006608:	1d49c83a 	sub	r4,r3,r21
 800660c:	e1f9803a 	cmpltu	fp,fp,r7
 8006610:	2739c83a 	sub	fp,r4,fp
 8006614:	8f09c83a 	sub	r4,r17,fp
 8006618:	003fc306 	br	8006528 <__alt_data_end+0xfc006528>
 800661c:	01000604 	movi	r4,24
 8006620:	003ef906 	br	8006208 <__alt_data_end+0xfc006208>
 8006624:	00800604 	movi	r2,24
 8006628:	003f1306 	br	8006278 <__alt_data_end+0xfc006278>
 800662c:	01000604 	movi	r4,24
 8006630:	003eb606 	br	800610c <__alt_data_end+0xfc00610c>
 8006634:	40bf902e 	bgeu	r8,r2,8006478 <__alt_data_end+0xfc006478>
 8006638:	b5bfff84 	addi	r22,r22,-2
 800663c:	4551883a 	add	r8,r8,r21
 8006640:	003f8e06 	br	800647c <__alt_data_end+0xfc00647c>
 8006644:	18bf762e 	bgeu	r3,r2,8006420 <__alt_data_end+0xfc006420>
 8006648:	8c7fff84 	addi	r17,r17,-2
 800664c:	1d47883a 	add	r3,r3,r21
 8006650:	003f7406 	br	8006424 <__alt_data_end+0xfc006424>
 8006654:	1cc7883a 	add	r3,r3,r19
 8006658:	003ecd06 	br	8006190 <__alt_data_end+0xfc006190>
 800665c:	8005883a 	mov	r2,r16
 8006660:	003ef806 	br	8006244 <__alt_data_end+0xfc006244>
 8006664:	873fe736 	bltu	r16,fp,8006604 <__alt_data_end+0xfc006604>
 8006668:	e00f883a 	mov	r7,fp
 800666c:	0009883a 	mov	r4,zero
 8006670:	003fad06 	br	8006528 <__alt_data_end+0xfc006528>
